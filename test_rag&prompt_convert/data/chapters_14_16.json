[
  {
    "page": 172,
    "text": "14 Query statements\n14.1\n<composite query statement>\nFunction\nSet the current working table to the result of a <composite query expression>.\nFormat\n<composite query statement> ::=\n<composite query expression>\nSyntax Rules\n1)\nLet CQS be the <composite query statement> and let CQE be the <composite query expression>\nimmediately contained in CQS.\n2)\nThe declared type of the outgoing working record of CQS is the declared type of the incoming\nworking record of CQS.\n3)\nThe declared type of the outgoing working table of CQS is the declared type of CQE.\n4)\nThe declared type of CQS is the declared type of CQE.\nGeneral Rules\n1)\nLet NEW_TABLE be the result of CQE.\n« WG3:CMN-019 P00-USA-351 »\n2)\nThe current working table is set to NEW_TABLE.\n3)\nThe current execution outcome is set to a successful outcome with NEW_TABLE as its result.\nConformance Rules\nNone.\n158\nIWD 39075:2023(E)"
  },
  {
    "page": 173,
    "text": "14.2\n<composite query expression>\nFunction\nSpecify binding table compositions.\nFormat\n<composite query expression> ::=\n<composite query expression> <query conjunction> <composite query primary>\n| <composite query primary>\n<query conjunction> ::=\n<set operator>\n| OTHERWISE\n<set operator> ::=\nUNION [ <set quantifier> ]\n| EXCEPT [ <set quantifier> ]\n| INTERSECT [ <set quantifier> ]\n<composite query primary> ::=\n<linear query statement>\nSyntax Rules\n1)\nIf <set operator> is specified and <set quantifier> is not specified, then DISTINCT is implicit.\n2)\nLet CQE be the <composite query expression>.\n3)\nIfa<queryconjunction>QCisimmediatelycontainedinCQE,thenevery<queryconjunction>directly\ncontained in CQE shall be QC.\n4)\nIf CQE directly contains a <focused linear query statement>, then CQE shall not directly contain an\n<ambient linear query statement>.\nNOTE 132 — As a consequence of this rule, focused statements and ambient statement are mutually\nexclusive within a <composite query expression>, so that the following is true as well: If CQE directly\ncontains an <ambient linear query statement>, then CQE does not directly contain a <focused linear query\nstatement>.\n5)\nIf CQE directly contains a <primitive result statement> that is FINISH, then CQE shall directly contain\nat most one <composite query primary>.\n6)\nLet CQP be the <composite query primary> immediately contained in CQE.\n7)\nLet LQS be the <linear query statement> immediately contained in CQP.\n8)\nThe declared type of the incoming working record of CQE is the declared type of the incoming\nworking record of CQE.\n9)\nThe declared type of the incoming working table of CQE is the declared type of the incoming\nworking table of CQE.\n10)\nCase:\na)\nIf <query conjunction> is specified, then:\ni)\nLet ICQE be the <composite query expression> immediately contained in CQE.\n159\nIWD 39075:2023(E)\n14.2 <composite query expression>"
  },
  {
    "page": 174,
    "text": "ii)\nThe declared type of the incoming working record of ICQE is the declared type of the\nincoming working record of CQE.\niii)\nThe declared type of the incoming working table of ICQE is the declared type of the\nincoming working table of CQE.\niv)\nLet FCQE be the set of the columns of the declared type of the outgoing working table\nof ICQE and let FLQE be the set of the columns of the declared type of the outgoing\nworking table of CQP.\nv)\nFCQE and FLQE shall be column name-equal and column-combinable.\nvi)\nLet COLS be the combined columns of FCQE and FLQE.\nvii)\nIf the GQL-implementation does not support Feature GA04, “Universal comparison”,\nthen there shall be no column COL in COLS such that:\n1)\nThe value type of COL is a dynamic union type DUT.\n2)\nThere exists a pair of different component types CT1 and CT2 of DUT such that\nCT1 and CT2 are not comparable.\nviii)\nIf <set operator> is UNION DISTINCT, EXCEPT ALL, EXCEPT DISTINCT, INTERSECT\nALL, or INTERSECT DISTINCT, then each column in COLS is an operand of a grouping\noperation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping\noperations”, apply.\nix)\nThe declared type of CQE is the material binding table whose set of columns is COLS.\nb)\nOtherwise, the declared type of CQE is the declared type of the outgoing working table of CQP.\nGeneral Rules\n1)\nThe result of CQP is the result of LQS.\n2)\nCase:\na)\nIf <query conjunction> is specified, then:\ni)\nLet ICQER be the binding table that is the result of ICQE.\nii)\nLet CQPR be the binding table that is the result of CQP.\niii)\nLet FCQER be a new binding table whose columns are COLS.\niv)\nIf <set operator> is specified, then FCQER contains the following records:\n« WG3:CMN-019 P00-USA-207 »\n1)\nLet R be a record that is a duplicate of some record in ICQER or of some record\nin CQPR or both. Let M be the number of duplicates of R in ICQER and let N be the\nnumber of duplicates of R in CQPR, where M ≥0 (zero) and N ≥0 (zero).\n2)\nIf DISTINCT is specified or implicit, then\nCase:\nA)\nIf UNION is specified, then FCQER contains exactly one duplicate of R.\nNOTE 133 — R exists as a result of GR 2)a)iv)1), guaranteeing that FCQER\nalways contains a duplicate of R.\nB)\nIf EXCEPT is specified, then\n160\nIWD 39075:2023(E)\n14.2 <composite query expression>"
  },
  {
    "page": 175,
    "text": "Case:\n« WG3:CMN-019 P00-USA-207 »\nI)\nIf M > 0 (zero) and N = 0 (zero), then FCQER contains exactly one\nduplicate of R.\nII)\nOtherwise, FCQER contains no duplicate of R.\nC)\nIf INTERSECT is specified, then\nCase:\n« WG3:CMN-019 P00-USA-207 »\nI)\nIf M > 0 (zero) and N > 0 (zero), then FCQER contains exactly one\nduplicate of R.\nII)\nOtherwise, FCQER contains no duplicates of R.\n3)\nIf ALL is specified, then\nCase:\n« WG3:CMN-019 P00-USA-207 »\nA)\nIf UNION is specified,then the number of duplicates of R that FCQER contains\nis (M + N).\nB)\nIf EXCEPT is specified, then the number of duplicates of R that FCQER con-\ntains is the maximum of (M −N) and 0 (zero).\nC)\nIf INTERSECT is specified, then the number of duplicates of R that FCQER\ncontains is the minimum of M and N.\nv)\nIf OTHERWISE is specified, then\nCase:\n1)\nIf ICQER contains at least one record, then let FCQER be ICQER.\n2)\nOtherwise, let FCQER be CQPR.\nvi)\nThe result of CQE is FCQER.\nb)\nOtherwise, the result of CQE is the result of CQP.\nConformance Rules\n1)\nWithoutFeature GQ02,“Composite query:OTHERWISE”, conformingGQL language shall not contain\na <composite query expression> that immediately contains a <query conjunction> OTHERWISE.\n2)\nWithout Feature GQ03, “Composite query: UNION”, conforming GQL language shall not contain a\n<composite query expression> that immediately contains a <query conjunction> UNION.\n3)\nWithout Feature GQ04, “Composite query: EXCEPT DISTINCT”, conforming GQL language shall not\ncontain a <composite query expression>that immediately contains a <query conjunction>EXCEPT.\n4)\nWithout Feature GQ05, “Composite query: EXCEPT ALL”, conforming GQL language shall not contain\na <composite query expression> that immediately contains a <query conjunction> EXCEPT ALL.\n161\nIWD 39075:2023(E)\n14.2 <composite query expression>"
  },
  {
    "page": 176,
    "text": "5)\nWithout Feature GQ06, “Composite query: INTERSECT DISTINCT”, conforming GQL language shall\nnot contain a <composite query expression> that immediately contains a <query conjunction>\nINTERSECT.\n6)\nWithout Feature GQ07, “Composite query: INTERSECT ALL”, conforming GQL language shall not\ncontain a <composite query expression> that immediately contains a <query conjunction> INTER-\nSECT ALL.\n162\nIWD 39075:2023(E)\n14.2 <composite query expression>"
  },
  {
    "page": 177,
    "text": "14.3\n<linear query statement> and <simple query statement>\nFunction\nSpecify a linear composition of <simple query statement>s that returns a result.\nFormat\n<linear query statement> ::=\n<focused linear query statement>\n| <ambient linear query statement>\n<focused linear query statement> ::=\n[ <focused linear query statement part>... ]\n<focused linear query and primitive result statement part>\n| <focused primitive result statement>\n| <focused nested query specification>\n| <select statement>\n<focused linear query statement part> ::=\n<use graph clause> <simple linear query statement>\n<focused linear query and primitive result statement part> ::=\n<use graph clause> <simple linear query statement> <primitive result statement>\n<focused primitive result statement> ::=\n<use graph clause> <primitive result statement>\n<focused nested query specification> ::=\n<use graph clause> <nested query specification>\n<ambient linear query statement> ::=\n[ <simple linear query statement> ] <primitive result statement>\n| <nested query specification>\n<simple linear query statement> ::=\n<simple query statement>...\n<simple query statement> ::=\n<primitive query statement>\n| <call query statement>\n<primitive query statement> ::=\n<match statement>\n| <let statement>\n| <for statement>\n| <filter statement>\n| <order by and page statement>\nSyntax Rules\n1)\nLet LQS be the <linear query statement>.\n« WG3:CMN-019 P00-NLD-050 »\n« WG3:CMN-019 P00-USA-207 »\n2)\nLet STMSEQ be the sequence of <simple query statement>s, the <primitive result statement>, the\n<nested query specification>, and the <select statement> directly contained in LQS. Let N be the\nnumber of elements of STMSEQ. For i, 1 (one) ≤i ≤N, let STMi be the i-th element of STMSEQ.\n163\nIWD 39075:2023(E)\n14.3 <linear query statement> and <simple query statement>"
  },
  {
    "page": 178,
    "text": "3)\nThe declared type of the incoming working record of STM1 is the declared type of the incoming\nworking record of LQS.\n4)\nThe declared type of the incoming working table of STM1 is the declared type of the incoming\nworking table of LQS.\n« WG3:CMN-019 P00-USA-207 »\n5)\nFor 2 (two) ≤i ≤N:\na)\nThe declared type of the incoming working record of STMi is the declared type of the outgoing\nworking record of STMi-1.\nb)\nThe declared type of the incoming working table of STMi is the declared type of the outgoing\nworking table of STMi-1.\n« WG3:CMN-019 P00-USA-207 »\n6)\nThe declared type of LQS is the declared type of STMN.\nGeneral Rules\nNone.\nConformance Rules\n1)\nWithout Feature GQ01, “USE graph clause”, conforming GQL language shall not contain a <focused\nlinear query statement>.\n164\nIWD 39075:2023(E)\n14.3 <linear query statement> and <simple query statement>"
  },
  {
    "page": 179,
    "text": "14.4\n<match statement>\nFunction\nExpand the current working table with matches from a graph pattern.\nFormat\n<match statement> ::=\n<simple match statement>\n| <optional match statement>\n<simple match statement> ::=\nMATCH <graph pattern binding table>\n<optional match statement> ::=\nOPTIONAL <optional operand>\n<optional operand> ::=\n<simple match statement>\n| <left brace> <match statement block> <right brace>\n| <left paren> <match statement block> <right paren>\n<match statement block> ::=\n<match statement>...\nSyntax Rules\n1)\nLet MS be the <match statement>.\n2)\nLet IREDT be the declared type of the incoming working record of MS and let IREDTFNS be the set\nof field names of IREDT.\n3)\nLet ITART be the record type of the declared type of the incoming working table of MS and let\nITARTFNS be the set of field names of ITART.\n4)\nIf MS immediately contains <optional match statement>, then:\na)\nLet IFNS be the union of IREDTFNS and ITARTFNS.\nb)\nLet IBVRL be an implementation-dependent (US010) comma-separated list of all incoming\n<binding variable reference>s corresponding to <binding variable>s whose names are in IFNS.\nc)\nA <graph pattern binding table> T supplies output bindings to a <match statement> S if at\nleast one of the following is true:\ni)\nS is a <simple match statement> that immediately contains T.\nii)\nS is an <optional match statement> whose <optional operand> is a <simple match\nstatement> that immediately contains T.\niii)\nS is an <optional match statement> whose <optional operand> immediately contains\na <match statement block> B and T supplies output bindings to a <match statement>\nimmediately contained in B.\nNOTE 134 — This is a recursive definition.An <exists predicate> contained in S provides an example\nof a <graph pattern binding table> that does not supply output bindings to S.\n165\nIWD 39075:2023(E)\n14.4 <match statement>"
  },
  {
    "page": 180,
    "text": "d)\nLet OBVRL be an implementation-dependent (US010) comma-separated list of <binding\nvariable reference>s corresponding to <binding variable>s whose names are column names\nof the declared type of any <graph pattern binding table> that supplies output bindings to MS\nthat are not included in IFNS.\ne)\nLet RETURN be defined as follows.\nCase:\ni)\nIf OBVRL is the empty list, then RETURN is:\nRETURN NO BINDINGS\nii)\nOtherwise, OBVRL is not empty and RETURN is:\nRETURN OBVRL\nf)\nLet OO be the <optional operand> simply contained in MS.\nCase:\ni)\nIf OO immediately contains a <simple match statement> SMS, then MS is effectively\nreplaced by:\nOPTIONAL CALL (IBVRL) { \nSMS\nRETURN\n}\nii)\nIf OO immediately contains a <match statement block> MSB, then MS is effectively\nreplaced by:\nOPTIONAL CALL (IBVRL) { \nMSB\nRETURN\n}\n« WG3:CMN-019 P00-ISO-023 »\nNOTE 135 — This transformation is applied recursively if MSB contains one or more nested\n<optional match statement>s. IBVRL and OBVRL are computed separately for each trans-\nformation.\n5)\nIf MS is a <simple match statement>, then:\na)\nLet GPBT be the <graph pattern binding table> that is simply contained in MS.\nb)\nLet GPBTRT be the record type of the declared type of GPBT.\nc)\nThe declared type of the outgoing working record of MS is IREDT amended with the record\ntype that is GPBTRT restricted to the fields identified by IREDTFNS.\nNOTE 136 — It is possible that the declared type of a graph pattern variable changes by changing\nthe corresponding declared type of the incoming working record or the corresponding declared\ntype of the incoming working table at certain sites.\nd)\nThe declared type of the outgoing working table of MS is the binding table type whose record\ntype is ITART amended with the record type that is GPBTRT without the fields identified by\nIREDTFNS.\nNOTE 137 — It is possible that the declared type of a graph pattern variable changes by changing\nthe corresponding declared type of the incoming working record or the corresponding declared\ntype of the incoming working table at certain sites.\n« WG3:CMN-019 P00-USA-072 »\n166\nIWD 39075:2023(E)\n14.4 <match statement>"
  },
  {
    "page": 181,
    "text": "6)\nMS has no declared type.\nGeneral Rules\n1)\nLet NEW_TABLE be the binding table obtained as a copy of the result of GPBT without the columns\nidentified by IREDTFNS.\nNOTE 138 — After the application of all Syntax Rules, MS is a <simple match statement> and thus GPBT\nis available here as defined by SR 5)a).\n« WG3:CMN-019 P00-USA-351 »\n2)\nThe current working table is set to NEW_TABLE.\n3)\nThe current execution outcome is set to a successful outcome with an omitted result.\nConformance Rules\n« WG3:CMN-019 P00-USA-073 »\n1)\nWithout Feature GQ21, “OPTIONAL: Multiple MATCH statements”, conforming GQL language shall\nnot contain an <optional match statement> that contains a <match statement block>.\n167\nIWD 39075:2023(E)\n14.4 <match statement>"
  },
  {
    "page": 182,
    "text": "14.5\n<call query statement>\nFunction\nExecute a query.\nFormat\n<call query statement> ::=\n<call procedure statement>\nSyntax Rules\n1)\nLet CQS be the <call query statement>, let CPS be the <call procedure statement> immediately\ncontained in CQS, and let PC be the <procedure call> immediately contained in CPS.\n2)\nIf PC is an <inline procedure call> that immediately contains the <nested procedure specification>\nPROC, then PROC shall immediately contain a <query specification>.\n3)\nIf PC is a <named procedure call> that immediately contains the <procedure reference> that iden-\ntifies a procedure PROC, then PROC shall have the QUERY PROCEDURE indication.\nGeneral Rules\nNone.\nConformance Rules\nNone.\n168\nIWD 39075:2023(E)\n14.5 <call query statement>"
  },
  {
    "page": 183,
    "text": "14.6\n<filter statement>\nFunction\nSelect a subset of the records of the current working table.\nFormat\n<filter statement> ::=\nFILTER { <where clause> | <search condition> }\nSyntax Rules\n1)\nLet FS be the <filter statement>.\n2)\nIf FS immediately contains the <search condition> SC, then it effectively is replaced by the <filter\nstatement>:\nFILTER WHERE SC\n3)\nLet WC be the <where clause> that is immediately contained in FS.\n4)\nLet DTIWR be the declared type of the incoming working record of FS.\n5)\nLet DTIWT be the declared type of the incoming working table of FS.\n6)\nThe declared type of the incoming working record of WC is DTIWR.\n7)\nThe declared type of the incoming working table of WC is DTIWT.\n8)\nThe declared type of the outgoing working record of FS is DTIWR.\n9)\nThe declared type of the outgoing working table of FS is DTIWT.\n10)\nFS has no declared type.\nGeneral Rules\n« WG3:CMN-019 P00-USA-351 »\n1)\nThe current working table is set to the result of WC.\n2)\nThe current execution outcome is set to a successful outcome with an omitted result.\nConformance Rules\n1)\nWithout Feature GQ08, “FILTER statement”, conforming GQL language shall not contain a <filter\nstatement>.\n169\nIWD 39075:2023(E)\n14.6 <filter statement>"
  },
  {
    "page": 184,
    "text": "14.7\n<let statement>\nFunction\nAdd columns to the current working table.\nFormat\n<let statement> ::=\nLET <let variable definition list>\n<let variable definition list> ::=\n<let variable definition> [ { <comma> <let variable definition> }... ]\n<let variable definition> ::=\n<value variable definition>\n| <value variable> <equals operator> <value expression>\nSyntax Rules\n1)\nLet LS be the <let statement>.\n2)\nLet LVDL be the <let variable definition list> immediately contained in LS.\n3)\nFor every <let variable definition> LVD that is immediately contained in LVDL and immediately\ncontains a <value variable>, LVD is effectively replaced by:\nVALUE LVD\n4)\nLet IREDT be the declared type of the incoming working record of LS and let IREDTFNS be the set\nof field names of IREDT.\n5)\nLet ITART be the record type of the declared type of the incoming working table of LS and let\nITARTFNS be the set of field names of ITART.\n6)\nLet IFNS be the union of IREDTFNS and ITARTFNS.\n7)\nLet IBVRL be an implementation-dependent(US010) comma-separated list of all incoming <binding\nvariable reference>s corresponding to <binding variable>s whose names are in IFNS.\n8)\nLet the <binding variable definition block> BVDBLK be the space-separated concatenation of all\n<let variable definition>s immediately contained in LVDL.\n9)\nLet the <return item list> RIL be the comma-separated list of all <value variable>s simply contained\nin LVDL.\n10)\nLS is effectively replaced by:\nCALL (IBVRL) {\nBVDBLK\nRETURN RIL\n}\nGeneral Rules\nNone.\n170\nIWD 39075:2023(E)\n14.7 <let statement>"
  },
  {
    "page": 185,
    "text": "Conformance Rules\n1)\nWithout Feature GQ09, “LET statement”, conforming GQL language shall not contain a <let state-\nment>.\n171\nIWD 39075:2023(E)\n14.7 <let statement>"
  },
  {
    "page": 186,
    "text": "14.8\n<for statement>\nFunction\nProvide unnesting of a list by expanding the current working table.\nFormat\n<for statement> ::=\nFOR <for item> [ <for ordinality or offset> ]\n<for item> ::=\n<for item alias> <list value expression>\n<for item alias> ::=\n<identifier> IN\n<for ordinality or offset> ::=\nWITH { ORDINALITY | OFFSET } <identifier>\nSyntax Rules\n1)\nLet FS be the <for statement>.\n2)\nLet FI be the <for item> immediately contained in FS.\n3)\nLet FIA be the <for item alias> immediately contained in FI.\n4)\nLet ANAME be the canonical name form of the <identifier> immediately contained in FIA.\n5)\nLet LVE be the <list value expression> immediately contained in FI.\n6)\nIf <for ordinality or offset> is specified, then let FOO be the <for ordinality or offset>; otherwise, let\nFOO be the zero-length character string.\n7)\nThe declared type of the incoming working record of LVE is the declared type of the incoming\nworking record of FS amended with the record type of the declared type of the incoming working\ntable of FS.\n8)\nThe declared type of the incoming working table of LVE is the material unit binding table type.\n9)\nThe declared type of the outgoing working record of FS is the declared type of the incoming working\nrecord of FS.\n10)\nLet the character string PNAME and the closed record type NEW_FIELDS_RT be defined as follows.\na)\nLet EFT be the field type whose name is ANAME and whose value type is the list element type\nof the declared type of LVE.\nb)\nCase:\ni)\nIf FOO is not the zero-length character string, then:\n1)\nPNAME is the canonical name form of the <identifier> immediately contained in\nFOO.\n2)\nPNAME shall not be equal to the field name of EFT.\n3)\nLet the value type PVT be defined as follows.\n172\nIWD 39075:2023(E)\n14.8 <for statement>"
  },
  {
    "page": 187,
    "text": "Case:\nA)\nIfFOOimmediatelycontainsWITHORDINALITY,thenPVTistheimplemen-\ntation-defined (ID057) exact numeric type with scale 0 (zero) of list element\nordinals.\nB)\nIfFOOimmediatelycontainsWITHOFFSET,thenPVTistheimplementation-\ndefined(ID058)exactnumerictypewithscale0(zero)oflistelementoffsets.\n4)\nLet PFT be the field type whose name is PNAME and whose value type is PVT.\n5)\nThe field types of NEW_FIELDS_RT comprise EFT and PFT.\nii)\nOtherwise, PNAME is the zero-length character string and the field types of\nNEW_FIELDS_RT comprise EFT.\n11)\nThe declared type of the incoming working record of LVE and NEW_FIELDS_RT shall be field name-\ndisjoint.\n12)\nThe declared type of the outgoing working table of FS is the binding table type whose record type\nis the record type of the declared type of the incoming working table of FS amended with\nNEW_FIELDS_RT.\n13)\nFS has no declared type.\nGeneral Rules\n1)\nLet NEW_TABLE be a new binding table whose type is the declared type of the outgoing working\ntable of FS.\n2)\nFor each record R of the current working table in a new child execution context amended with R\nwhose working table is the empty binding table:\na)\nLet LVER be the result of LVE.\nb)\nLet LV be the list value defined as follows.\nCase:\ni)\nIf LVER is a list value, then LV is LVER.\nii)\nIf LVER is the null value, then LV is the empty list value.\niii)\nOtherwise,an exceptionconditionis raised:data exception — invalidvalue type (22G03).\nc)\nLet LVLEN be the length of LV.\n« WG3:CMN-019 P00-NLD-050 »\nd)\nFor j, 1 (one) ≤j ≤LVLEN:\ni)\nLet LRj be the record comprising a single field whose name is ANAME and whose value\nis the j-th element of LV.\nii)\nCase:\n1)\nIf the <for ordinality or offset> is specified, then:\nA)\nIfFOOimmediatelycontainsWITHORDINALITY,thenletLROjbetherecord\nobtained by adding a field to LRj whose name is PNAME and whose value\nis j.\n173\nIWD 39075:2023(E)\n14.8 <for statement>"
  },
  {
    "page": 188,
    "text": "B)\nIf FOO immediately contains WITH OFFSET, then let LROj be the record\nobtained by adding a field to LRj whose name is PNAME and whose value\nis j−1.\n2)\nOtherwise, let LROj be LRj.\niii)\nAppend LROj to the current working table.\ne)\nAppend the Cartesian product of R and the current working table to NEW_TABLE.\n« WG3:CMN-019 P00-USA-351 »\n3)\nThe current working table is set to NEW_TABLE.\n4)\nThe current execution outcome is set to a successful outcome with an omitted result.\nConformance Rules\n1)\nWithout Feature GQ10, “FOR statement”, conforming GQL language shall not contain a <for state-\nment>.\n2)\nWithout Feature GQ11, “FOR statement: WITH ORDINALITY or WITH OFFSET”, conforming GQL\nlanguage shall not contain a <for statement> that simply contains <for ordinality or offset>.\n174\nIWD 39075:2023(E)\n14.8 <for statement>"
  },
  {
    "page": 189,
    "text": "14.9\n<order by and page statement>\nFunction\nSpecify, for the current working table, either: the ordering of the records, the number of records to be\ndiscarded from the beginning of the table, or the maximum number of records to be retained; or any\ncombination of these.\nFormat\n<order by and page statement> ::=\n<order by clause> [ <offset clause> ] [ <limit clause> ]\n| <offset clause> [ <limit clause> ]\n| <limit clause>\n** Editor’s Note (number 20) **\nAdditional support for PARTITION BY, WITH TIES, WITH OFFSET, and WITH ORDINALITY should be considered.\nSee Language Opportunity GQL-163 .\nSyntax Rules\n1)\nLet OPS be the <order by and page statement>.\n2)\nLet DTIWR be the declared type of the incoming working record of OPS.\n3)\nLet DTIWT be the declared type of the incoming working table of OPS.\n4)\nThe declared type of the incoming working record of any <offset clause> or <limit clause> immedi-\nately contained in OPS is DTIWR.\n5)\nThe declared type of the incoming working table of any <offset clause> or <limit clause> immediately\ncontained in OPS is DTIWT.\n« WG3:CMN-019 P00-USA-075 Two SRs removed »\n6)\nOPS has no declared type.\nGeneral Rules\n1)\nLet TABLE be the current working table.\n2)\nLet ORDERED be the binding table defined as follows.\nCase:\na)\nIf OPS immediately contains the <order by clause> OBC, then let ORDERED be the result of\nOBC.\nb)\nOtherwise, let ORDERED be TABLE.\n3)\nLet OFFSETED be the binding table defined as follows.\nCase:\na)\nIf OPS immediately contains the <offset clause> OC, then let OFFSETED be the result of OC.\nb)\nOtherwise, let OFFSETED be ORDERED.\n175\nIWD 39075:2023(E)\n14.9 <order by and page statement>"
  },
  {
    "page": 190,
    "text": "4)\nLet LIMITED be the binding table defined as follows.\nCase:\na)\nIf OPS immediately contains the <limit clause> LC, then let LIMITED be the result of LC.\nb)\nOtherwise, let LIMITED be OFFSETED.\n« WG3:CMN-019 P00-USA-351 »\n5)\nThe current working table is set to LIMITED.\n6)\nThe current execution outcome is set to a successful outcome with an omitted result.\nConformance Rules\n« WG3:CMN-019 P00-USA-077 »\n1)\nWithoutFeatureGQ12,“ORDERBYandpagestatement:OFFSETclause”,inconformingGQLlanguage,\nan <order by and page statement> shall not contain an <offset clause>.\n2)\nWithout Feature GQ13, “ORDER BY and page statement: LIMIT clause”, in conforming GQL language,\nan <order by and page statement> shall not contain a <limit clause>.\n176\nIWD 39075:2023(E)\n14.9 <order by and page statement>"
  },
  {
    "page": 191,
    "text": "14.10 <primitive result statement>\nFunction\nDefine what to include in a query result.\nFormat\n<primitive result statement> ::=\n<return statement> [ <order by and page statement> ]\n| FINISH\nSyntax Rules\n1)\nLet PRS be the <primitive result statement>.\n2)\nLet DTIWR be the declared type of the incoming working record of PRS.\n3)\nLet DTIWT be the declared type of the incoming working table of PRS.\n4)\nIf the <return statement> RS is specified, then:\na)\nThe declared type of the incoming working record of RS is DTIWR.\nb)\nThe declared type of the incoming working table of RS is DTIWT.\nc)\nCase:\ni)\nIf the <order by and page statement> OPS is specified, then:\n1)\nThe declared type of the incoming working record of OPS is DTIWR.\n2)\nCase:\nA)\nIf OPS immediately contains an <order by clause> OBC, then:\nI)\nNo <sort key> shall contain a <nested query specification>.\nII)\nLet RETURN_IDENTIFIERS be the set of all <identifier>s immediately\ncontained in an explicit or implicit <return item alias> contained in\nRS.\nIII)\nLet ORDER_REFS be the set of <binding variable reference>s defined\nas follows:\n1)\nIf RS does not contain a <group by clause>, a <set quantifier>\nDISTINCT, or any <return item> containing an <aggregate\nfunction>, then ORDER_REFS is the union of RETURN_IDENTI-\nFIERS and the set of <identifier>s representing all column\nnames of DTIWT and field names of DTIWR.\n2)\nIf RS contains a <group by clause> GBC, then ORDER_REFS is\nthe union of RETURN_IDENTIFIERS and the set of all <binding\nvariable reference>s contained in GBC.\n3)\nIf RS does not contain a <group by clause>, but contains a <set\nquantifier> DISTINCT or a <return item> containing an\n<aggregatefunction>,thenORDER_REFSisRETURN_IDENTIFI-\nERS.\n177\nIWD 39075:2023(E)\n14.10 <primitive result statement>"
  },
  {
    "page": 192,
    "text": "IV)\nFor every <binding variable reference> BVR contained in a <sort\nkey> SK contained in OBC, if BVR is contained in SK without an\ninterveninginstanceof<aggregate function>, thenORDER_REFSshall\ncontain an identifier that is equivalent to BVR.\nV)\nIf RS does not simply contain a <group by clause> or does not simply\ncontain a <return item> containing an <aggregate function> without\nan intervening instance of <procedure body>, then no <sort key>\ncontained in OBC shall contain an <aggregate function>.\nVI)\nLet RIL be the <return item list> immediately contained in RS, let\nCRIL be a copy of RIL, and let OB_COLS be the empty set.\nVII)\nFor every <sort key> SK contained in OBC that contains an <aggregate\nfunction>:\n1)\nLet AGG be the <value expression> immediately contained in\nSK.\n2)\nLet CN be an implementation-dependent (UV013) <identifier>\nthat is not equivalent to any other <identifier> contained in a\n<return item alias> simply contained in RIL.\n3)\nAppend to CRIL:\n, AGG AS CN\n4)\nSK is replaced in OBC by:\nCN\n5)\nLetOB_COLbea newcolumnwhosenameisthecanonicalname\nform of CN and whose type is the declared type of AGG.\n6)\nOB_COL is added to OB_COLS.\nVIII)\nForevery<bindingvariablereference>REFinORDER_REFSforwhich\nit holds that RETURN_IDENTIFIERS contains no element that is\nequivalent to REF:\n1)\nAppend to CRIL:\n, REF AS REF\n2)\nLetOB_COLbea newcolumnwhosenameisthecanonicalname\nform of REF and whose type is the declared type of REF.\n3)\nOB_COL is added to OB_COLS.\nIX)\nRIL is replaced by CRIL.\nX)\nLet BTT be the binding table type obtained as a copy of the declared\ntype of the outgoing working table of OPS without any columns\nidentified by OB_COLS.\nXI)\nThe declared type of PRS and the declared type of the outgoing\nworking table of PRS is BTT.\nB)\nOtherwise,\nI)\nThe declared type of the incoming working table of OPS is the\ndeclared type of RS.\n178\nIWD 39075:2023(E)\n14.10 <primitive result statement>"
  },
  {
    "page": 193,
    "text": "II)\nThe declared type of PRS is the declared type of the outgoing working\ntable of OPS.\nIII)\nThedeclared type of the outgoing working table of PRS is the declared\ntype of the outgoing working table of OPS.\nii)\nOtherwise, the declared type of PRS is the declared type of RS.\n5)\nIf FINISH is specified, then PRS has no declared type.\nGeneral Rules\n1)\nIf the <return statement> RS is specified, then:\na)\nThe General Rules of RS are applied.\nNOTE 139 — If successful, this sets the current execution result to a binding table.\nb)\nIf RS specifies the <order by and page statement> OPS, then:\n« WG3:CMN-019 P00-USA-351 »\ni)\nThe current working table is set to the current execution result.\nii)\nThe General Rules of OPS are applied.\niii)\nLet RESULT_TABLE be defined as follows.\nCase:\n1)\nIf OPS immediately contains an <order by clause>, then RESULT_TABLE is the\nbinding table obtained as a copy of the current working table without any of the\ncolumns identified by OB_COLS.\n2)\nOtherwise, RESULT_TABLE is the current working table.\n« WG3:CMN-019 P00-USA-351 »\niv)\nThe current execution outcome is set to a successful outcome with RESULT_TABLE as\nits result.\n« WG3:CMN-019 P00-USA-351 »\n2)\nIf FINISH is specified, then the current execution outcome is set to a successful outcome with an\nomitted result.\nConformance Rules\n« WG3:CMN-019 P00-USA-077 »\n1)\nWithout Feature GQ14, “Complex expressions in sort keys”, in conforming GQL language, the <value\nexpression> immediately contained in a <sort key> shall be a <binding variable reference>.\n2)\nWithout Feature GQ16, “Pre-projection aliases in sort keys”, in conforming GQL language, the <value\nexpression> immediately contained in a <sort key> shall not simply contain any <binding variable\nreference> that is not a <return item alias> in the preceding <return statement>.\n3)\nWithout Feature GF20, “Aggregate functions in sort keys”, in conforming GQL language, the <value\nexpression>immediately containedin a <sort key> shall not simply contain an <aggregate function>.\n179\nIWD 39075:2023(E)\n14.10 <primitive result statement>"
  },
  {
    "page": 194,
    "text": "14.11 <return statement>\nFunction\nCompute the binding table result of a linear statement.\nFormat\n<return statement> ::=\nRETURN <return statement body>\n<return statement body> ::=\n[ <set quantifier> ] { <asterisk> | <return item list> } [ <group by clause> ]\n| NO BINDINGS\n<return item list> ::=\n<return item> [ { <comma> <return item> }... ]\n<return item> ::=\n<aggregating value expression> [ <return item alias> ]\n<return item alias> ::=\nAS <identifier>\n** Editor’s Note (number 21) **\nConsider allowing a single optional <where clause>. See Language Opportunity GQL-169 .\nSyntax Rules\n** Editor’s Note (number 22) **\nAggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .\n1)\nLet RS be the <return statement>.\n2)\nLet RSB be the <return statement body> immediately contained in RS.\n3)\nIf a <set quantifier> is not immediately contained in RSB, then ALL is the implicit <set quantifier>\nof RSB.\n4)\nIf a <set quantifier> DISTINCT is specified, then each <return item> RI is an operand of a grouping\noperation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations”,\napply.\n5)\nLet SQ be the explicit or implicit <set quantifier> of RSB.\n6)\nIf RSB immediately contains an <asterisk>, then:\na)\nThe declared type of the incoming working table of RS shall not be the unit binding table type.\nb)\nRSB shall not immediately contain a <group by clause>.\n« WG3:CMN-019 P00-NLD-050 »\nc)\nLet BVSEQ be the sequence of all column names of the declared type of the incoming working\ntable of RS in ascending order. Let NBVSEQ be the number of such binding variables. For i, 1\n(one) ≤i ≤NBVSEQ, let BVi be the i-th such binding variable in BVSEQ.\n180\nIWD 39075:2023(E)\n14.11 <return statement>"
  },
  {
    "page": 195,
    "text": "d)\nFor i, 1 (one) ≤i ≤NBVSEQ, let the new <return item list> NEWRIL be a comma-separated list\nof <return item>s:\nBVi AS BVi\ne)\nRS is effectively replaced by the <return statement>:\nRETURN SQ NEWRIL\n7)\nLet RIL be defined as follows.\nCase:\na)\nIf RSB is NO BINDINGS, then SQ is ALL and RIL is the empty sequence.\nNOTE 140 — That is, RETURN NO BINDINGS is equivalent to RETURN ALL with an empty <return\nitem list> and no <group by clause>. The Format does not permit an empty <return item list>,\nhence the need to define these values artificially.\nb)\nOtherwise, RIL is the <return item list> immediately contained in RSB.\n8)\nFor each <return item> RI in RIL:\nCase:\na)\nIf the <aggregating value expression> immediately contained in RI is a <binding variable ref-\nerence> RIBV and RI does not immediately contain a <return item alias>, then RI is effectively\nreplaced by:\nRIBV AS RIBV\nb)\nOtherwise, RI shall immediately contain a <return item alias>.\n9)\nFor a given <return item> RI, let the expression of RI be the <aggregating value expression> imme-\ndiately contained in RI and let the alias name of RI be the canonical name form of the <identifier>\nthat is immediately contained in the explicit or implicit <return item alias> of RI.\n10)\nCase:\na)\nIf RSB immediately contains a <group by clause> GBC:\ni)\nLet GRISET be the set of grouping <return item>s contained in RIL whose alias name\nis simply containedin GBC and let NGRI be the number of such<return item>s in GRISET.\nii)\nLet ARISET be the set of aggregating <return item>s contained in RIL whose alias name\nis not simply contained in GBC and let NARI be the number of such <return item>s in\nARISET.\niii)\nAll <return item>s shall be contained in GRISET or ARISET.\niv)\nLet INSET be the set of all <grouping element>s simply contained in GBC that are not\nequal to an alias name in GRISET. Let NINSET be the number of items in INSET.\nv)\nLet GROUP_COLS be the set of columns constructed as follows:\n« WG3:CMN-019 P00-NLD-016 Correct error in UTC-081 »\n1)\nFor every grouping <return item> GRI in GRISET:\nA)\nLet COL be a new column whose name is the <return item alias> of GRI and\nwhose type is the declared type of the <aggregating value expression>\nimmediately contained in GRI.\n181\nIWD 39075:2023(E)\n14.11 <return statement>"
  },
  {
    "page": 196,
    "text": "B)\nCOL is included in GROUP_COLS.\n« WG3:CMN-019 P00-NLD-017 Correct error in UTC-081 »\n2)\nFor every <grouping element> IN in INSET:\nA)\nLet COL be a new column whose name is the <identifier> contained in IN\nand whose type is the declared type of the <binding variable reference>\ncontained in IN.\nB)\nCOL is included in GROUP_COLS.\n« WG3:CMN-019 P00-USA-078 »\nvi)\nLet GR_TABLE_TYPE be the declared type of a binding table containing all columns of\nGROUP_COLS.\nvii)\nLet ARI_TABLE_TYPE be the declared type of the incoming working table of RS without\nthe fields identified by GROUP_COLS.\nviii)\nThe declared type of the incoming working table of all <return item>s in ARISET is\nARI_TABLE_TYPE.\nix)\nThe declared type of the incoming working record of all <return item>s in ARISET is\nthe declared type of the incoming working record of RS amended with the record type\nof GR_TABLE_TYPE.\nb)\nOtherwise:\ni)\nThe declared type of the incoming working table of every <return item> is the declared\ntype of the incoming working table of RS.\nii)\nThedeclared type of the incomingworking record of every<return item> is the declared\ntype of the incoming working record of RS.\n11)\nLet RETURN_TABLE_TYPE be the declared type of a binding table defined as follows.\nCase:\na)\nIf RSB immediately contains an <asterisk>, then RETURN_TABLE_TYPE is the declared type\nof the incoming working table of RS.\nb)\nOtherwise:\ni)\nLet RETURN_COLS be the sequence of columns constructed by, for every element RI of\nRIL, creating a column whose name is the alias name of RI and whose declared type is\nthe declared type of the expression of RI.\nii)\nRETURN_TABLE_TYPE is the declared type of a material binding table whose set of\ncolumns is RETURN_COLS.\n12)\nThe declared type of the outgoing working table of RS is the material unit binding table type.\n13)\nThe declared type of the outgoing working record of RS is the declared type of the incoming working\nrecord of RS.\n14)\nThe declared type of RS is RETURN_TABLE_TYPE.\nGeneral Rules\n« Editorial: Correct wording »\n« WG3:CMN-019 P00-NLD-050 »\n182\nIWD 39075:2023(E)\n14.11 <return statement>"
  },
  {
    "page": 197,
    "text": "« WG3:CMN-019 P00-USA-207 »\n1)\nLet TABLE be the current working table. Let N be the number of records of TABLE. For i, 1 (one) ≤\ni ≤N, let Ri, be the i-th record of TABLE in the order determined by iterating over TABLE.\n2)\nLet RETURN_TABLE be a new empty binding table of type RETURN_TABLE_TYPE.\n3)\nCase:\na)\nIf RS immediately contains a <group by clause> GBC:\n« WG3:CMN-019 P00-NLD-050 »\n« WG3:CMN-019 P00-USA-207 »\ni)\nFor i, 1 (one) ≤i ≤N, let the grouping record GRi of a record Ri of TABLE be a new record\nconstructed as follows:\n« WG3:CMN-019 P00-NLD-050 »\n1)\nFor 1 (one) ≤k ≤NGRI, GRi includes field Fk such that the field name of Fk is the\nalias name of GRISETk and the field value of Fk is the result of the expression of\nGRISETk in a new child execution context amended with Ri.\n2)\nFor 1 (one) ≤j ≤NINSET, GRi includes field Gj such that the field name of Gj is the\n<identifier> contained in INSETj and the field value of Gj is the value in Ri of the\n<binding variable reference> contained in INSET.\n« WG3:CMN-019 P00-USA-207 »\nii)\nLet GR_TABLE be a new binding table of type GR_TABLE_TYPE of all grouping records\nGRi, 1 (one) ≤i ≤N, of all records Ri of TABLE.\niii)\nLet GROUP_BY be the result of GBC in a new child execution context with GR_TABLE as\nits working table.\nNOTE 141 — The result of GBC is obtained from the implicit invocation of the General Rules\nof Subclause 16.17, “<group by clause>”.\niv)\nFor each record K in GROUP_BY:\n« WG3:CMN-019 P00-USA-207 »\n1)\nLet PART be a new binding table of type ARI_TABLE_TYPE comprising only the\nrecords Rj, 1 (one) ≤j ≤N, from TABLE, for which the grouping record GRj for Rj\nis not distinct from K, without the columns identified by GROUP_COLS.\n2)\nLet IWR be a new record obtained as a copy of the current working record\namended with GRj .\n3)\nLet NR be a new record obtained as a copy of K without the fields identified by\nINSET.\n4)\nFor every <return item> ARIj in ARISET, 1 (one) ≤j ≤NARI, append a field to NR\nwhose name is the alias name of ARIj and whose value is the result of evaluating\nthe <aggregating value expression> of ARIj in a new child execution context with\nIWR as its working record and with PART as its working table.\nNOTE 142 — This is used to determine the result of <aggregate function>s.\n5)\nAppend NR to RETURN_TABLE.\n183\nIWD 39075:2023(E)\n14.11 <return statement>"
  },
  {
    "page": 198,
    "text": "b)\nOtherwise, for each record R of TABLE in a new child execution context amended with R:\ni)\nLet S be a record defined as follows.\nCase:\n1)\nIf RIL is an empty sequence, then S is the unit record.\n2)\nOtherwise, S is the record comprising a field F for every <return item> RI in RIL\nsuch that the name of F is the alias name of RI and the value of F is the result of\nthe expression of RI.\n« WG3:CMN-019 P00-USA-351 »\nii)\nS is added to RETURN_TABLE.\n« WG3:CMN-019 P00-USA-351 »\n4)\nIf SQ is DISTINCT, then the current working table is set to duplicate-free copy of RETURN_TABLE\nin which every record is distinct from every other record of RETURN_TABLE; otherwise, the current\nworking table is set to RETURN_TABLE.\n« WG3:CMN-019 P00-NLD-018 Correct error in UTC-081 »\n5)\nLet FINAL_TABLE be a new binding table of type RETURN_TABLE_TYPE obtained from the current\nworking table by determining the preferred column name sequence to be the sequence of alias\nnames of all <return item>s from RIL in the order of their occurrence in RIL.\n« WG3:CMN-019 P00-USA-351 »\n6)\nThe current working table is set to a new unit binding table.\n7)\nThe current execution outcome is set to a successful outcome with FINAL_TABLE as its result.\nConformance Rules\n1)\nConforming GQL language shall not contain a <return statement body> that contains NO BINDINGS.\nNOTE 143 — A <return statement body> that contains NO BINDINGS is a specification device for use by\na syntactic transformation in Subclause 14.4, “<match statement>” to specify the semantics of <optional\nmatch statement> if the latter does not supply any new output bindings and is not syntax available to\nthe user.\n« WG3:CMN-019 P00-USA-077 »\n2)\nWithout Feature GA07, “Ordering by discarded binding variables”, in conforming GQL langauge,\nthe <group by clause> immediately contained in a <return statement> shall not directly contain a\n<sort key> that directly contains a <binding variable reference> that is not equivalent to the\n<identifier> immediately contained in a <return item alias> that is directly contained in the <return\nstatement> unless the referenced binding variable of the <binding variable reference> is defined\nby an intervening BNF non-terminal simply contained in the <sort key>.\n184\nIWD 39075:2023(E)\n14.11 <return statement>"
  },
  {
    "page": 199,
    "text": "14.12 <select statement>\nFunction\nProvide an SQL-style query over graph data, which produces a binding table result.\nFormat\n<select statement> ::=\nSELECT [ <set quantifier> ] { <asterisk> | <select item list> }\n    [ <select statement body>\n    [ <where clause> ]\n    [ <group by clause> ]\n    [ <having clause> ]\n    [ <order by clause> ]\n    [ <offset clause> ] [ <limit clause> ] ]\n<select item list> ::=\n<select item> [ { <comma> <select item> }... ]\n<select item> ::=\n<aggregating value expression> [ <select item alias> ]\n<select item alias> ::=\nAS <identifier>\n<having clause> ::=\nHAVING <search condition>\n<select statement body> ::=\nFROM { <select graph match list> | <select query specification> }\n<select graph match list> ::=\n<select graph match> [ { <comma> <select graph match> }... ]\n<select graph match> ::=\n<graph expression> <match statement>\n<select query specification> ::=\n<nested query specification>\n| <graph expression> <nested query specification>\n** Editor’s Note (number 23) **\nAggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .\nSyntax Rules\n1)\nThe Syntax Rules of this Subclause are applied before all other Syntax Rules.\n2)\nLet SELECTSTM be the <select statement>.\n3)\nLet NAMES_IN_USE be the set of the canonical name forms of all <identifier>s contained in the <GQL-\nprogram> that contains SELECTSTM.\n4)\nIn this Subclause, each use of the phrase freshly generated identifier stands for an implicitly generated\nnew <regular identifier> RI that is determined as follows:\n185\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 200,
    "text": "The <regular identifier>RI is an implementation-dependent (UV015) <regular identifier>\nwhose canonical name form is not included in NAMES_IN_USE.\na)\nb)\nThe canonical name form of RI is added to NAMES_IN_USE.\n5)\nIf SELECTSTM does not immediately contain a <set quantifier>, then ALL is implicit.\n6)\nLet SETQ be the explicit or implicit <set quantifier> that is immediately contained in SELECTSTM.\n7)\nIf SETQ is DISTINCT, then each <select item> immediately contained in the <select item list>\nimmediately contained in SELECTSTM is an operand of a grouping operation. The Syntax Rules and\nConformance Rules of Subclause 22.14, “Grouping operations”, apply.\n8)\nLetSSB be definedas follows. If <selectstatementbody>isspecified,thenSSB isthe<selectstatement\nbody>; otherwise, SSB is the zero-length character string.\n9)\nIf SELECTSTM immediately contains an <asterisk>, then:\na)\nSSB shall not be the zero-length character string.\nb)\nSELECTSTM shall not immediately contain a <group by clause>.\nc)\nLet FROM_ITEMS be the set of names defined as follows.\nCase:\ni)\nIf the <select statement body> of SELECTSTM immediately contains a <select graph\nmatch list> SGML, then FROM_ITEMSis the set of names of binding variablesreferenced\nby all <binding variable reference>s that are declared in <graph pattern>s directly\ncontained in SGML without an intervening instance of (another) <graph pattern>.\nii)\nOtherwise, the <select statement body> of SELECTSTM immediately contains a <select\nquery specification> SQS and FROM_ITEMS is the set of column names of the declared\ntype of the outgoing working table of the <nested query specification> immediately\ncontained in SQS.\nd)\nLet FNSEQ be the sequence of all names of FROM_ITEMS in ascending order and let NFNSEQ\nbe the number of such names.\ne)\nFor 1 (one) ≤i ≤NFNSEQ: Let FROM_ITEMi be the i-th name in FNSEQ and let BVRi be an\n<identifier> whose canonical name form is FROM_ITEMi.\nf)\nLet the <select item list> NEWSIL be the comma-separated list of <select item>s defined as\nfollows:\nBVR1 AS BVR1, ..., BVRNFNSEQ AS BVRNFNSEQ\ng)\nThe <asterisk>immediately contained in SELECTSTM is effectively replaced by the <select\nitem list>:\nNEWSIL\n10)\nFor each explicit <select item> SI immediately contained in the <select item list> immediately con-\ntained in SELECTSTM,\nCase:\na)\nIf the <aggregating value expression> immediately contained in SI is a <binding variable ref-\nerence> SIBVR and SI does not immediately contain a <select item alias>, then SI is effectively\nreplaced by:\nSIBVR AS SIBVR\n186\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 201,
    "text": "b)\nOtherwise, SI shall immediately contain a <select item alias>.\n11)\nLet FILTERSTM be defined as follows.\nCase:\na)\nIf a <where clause> WHERECL is specified, then FILTERSTM is:\nFILTER WHERECL\nb)\nOtherwise,\nCase:\ni)\nIf SSB contains the <select graph match list> SGML and if the last <select graph match>\nin SGML immediately contains a <match statement> that contains a <graph pattern>\nGP that contains a <graph pattern where clause> GPWC that is not followed by a <yield\nclause>, then FILTERSTM is:\nFILTER GPWC\nand GPWC is removed from GP.\nii)\nOtherwise, FILTERSTM is the zero-length character string.\n12)\nLet XOISIL be the list of explicit or implicit <select item>s immediately contained in SELECTSTM in\nthe order of their appearance, let XOISISET be the set of <select item>s in XOISIL, let XOISIASEQ be\nthe sequence of <identifier>s immediately contained in <select item alias>es in XOISIL, and let\nNUM_SIS be the number of elements of XOISIL.\n13)\nLet AGGREGATING_ITEMS be the set of all <select item>s in XOISISET that directly contain an\n<aggregate function> and let NUM_AGGREGATING be the number of elements of AGGREGAT-\nING_ITEMS.\n14)\nLetthe<groupbyclause>GROUP_BYandthesetof<returnitem>sGKRISETbedeterminedasfollows.\nCase:\na)\nIf SELECTSTM immediately contains a <group by clause> GBC that does not simply contain an\n<empty grouping set>, then:\ni)\nLet GEL be the <grouping element list> immediately contained in GBC.\nii)\nLet NUM_GE be the number of elements of GEL.\niii)\nFor 1 (one) ≤j ≤NUM_GE:\n« WG3:CMN-019 P00-USA-080 »\n1)\nLet GEj be the j-th <grouping element> contained in GEL.\n2)\nLet GEIDj be a freshly generated identifier.\n3)\nThe following <return item> is added to GKRISET:\nGEj AS GEIDj\n« WG3:CMN-019 P00-USA-081 »\niv)\nGROUP_BY is:\nGROUP BY GE1, ..., GENUM_GE\n187\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 202,
    "text": "b)\nOtherwise, GROUP_BY is the zero-length character string and GKRISET is the empty set.\n15)\nLet NONAGGREGATING_ITEMS be the set of <select item>s determined as follows:\na)\nInitially, NONAGGREGATING_ITEMS is the empty set.\nb)\nFor every <select item> SI in XOISISET not included in AGGREGATING_ITEMS,\nCase:\ni)\nIf GKRISET is not empty, then:\n1)\nLet COSI be a copy of SI with every simply contained <binding variable reference>\nthat is a <value expression> of a <return item> RI in GKRISET replaced with the\n<identifier> immediately contained in the <return item alias> immediately con-\ntained in RI.\n2)\nCOSI is added to NONAGGREGATING_ITEMS\nii)\nOtherwise, SI is added to NONAGGREGATING_ITEMS.\n16)\nLet the set of <return item>s SARISET be determined as follows.\nCase:\na)\nIf SELECTSTM immediately contains an <order by clause> OBC, then:\ni)\nInitially, SARISET is the empty set.\nii)\nFor every <sort key> SK simply contained in OBC that directly contains an <aggregate\nfunction>:\n1)\nLet OBVE be the <value expression> immediately contained in SK.\n2)\nLet OBVEID be a freshly generated identifier.\n3)\nThe following <return item> is added to SARISET:\nOBVE AS OBVEID\nb)\nOtherwise, SARISET is the empty set.\n17)\nLet the sets of <return item>s ARISET and PARISET be determined as follows.\nCase:\na)\nIf AGGREGATING_ITEMS is not the empty set, then:\ni)\nInitially, both ARISET and PARISET are the empty set.\nii)\nFor 1 (one) ≤k ≤NUM_AGGREGATING:\n1)\nLet ITEMk be the k-th element of AGGREGATING_ITEMS.\n2)\nITEMk shall immediately contain a <select item alias>. Let ITEM_ALIASk be the\n<identifier> immediately contained in that <select item alias>.\n3)\nLet ITEM_EXPRk be the <value expression> immediately contained in ITEMk.\n4)\nLet ITEM_IDk be a freshly generated identifier.\n5)\nThe following <return item> is added to ARISET:\nITEM_EXPRk AS ITEM_IDk\n188\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 203,
    "text": "6)\nThe following <return item> is added to PARISET:\nITEM_IDk AS ITEM_ALIASk\nb)\nOtherwise, both ARISET and PARISET are the empty set.\n18)\nLet the set of <return item>s HARISET and the <filter statement> HAVING_FILTER be defined as\nfollows.\nCase:\na)\nIf SELECTSTM immediately contains a <having clause> HC, then:\ni)\nLet HCCOND be the <search condition> immediately contained in HC.\nii)\nLet HCBVE be the <boolean value expression> immediately contained in HCCOND.\niii)\nLet HCID be a freshly generated identifier.\niv)\nHARISET is the set comprising the <return item>:\nHCBVE AS HCID\nv)\nHAVING_FILTER is:\nFILTER WHERE HCID\nb)\nOtherwise, HARISET is the empty set and HAVING_FILTER is the zero-length character string.\n19)\nLet LET_ITEMS be determined as follows.\nCase:\na)\nIf XOISISET does not directly contain an <aggregate function> and SELECTSTM immediately\ncontains an <order by clause> LOBC that directly contains a <sort key> that is not a <binding\nvariable reference> and does not contain an <aggregate function>:\ni)\nInitially, LET_ITEMS is the empty set.\nii)\nFor every <sort key> LSK directly contained in LOBC that is not a <binding variable\nreference> and that does not contain an <aggregate function>:\n1)\nLet LET_IDENT be a freshly generated identifier.\n2)\nLet LET_EXPR be the <value expression> immediately contained in LSK.\n3)\nThe following <let variable definition> is added to LET_ITEMS:\nLET_IDENT = LET_EXPR\nb)\nOtherwise, LET_ITEMS is the empty set.\n20)\nLet LETSTM be defined as follows.\nCase:\na)\nIf LET_ITEMS is not empty, then:\ni)\nLet NUM_LET_ITEMS be the number of elements in LET_ITEMS.\n« WG3:CMN-019 P00-NLD-050 »\nii)\nFor l, 1 (one) ≤l ≤NUM_LET_ITEMS, let LET_ITEMl be the l-th element of LET_ITEMS.\n189\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 204,
    "text": "iii)\nLETSTM is the <let statement>:\nLET LET_ITEM1, ..., LET_ITEMNUM_LET_ITEMS\nb)\nOtherwise, LETSTM is the zero-length character string.\n21)\nIfSELECTSTMimmediatelycontainsa<selectitemlist>thatdirectlycontainsan<aggregatefunction>\nor if SELECTSTM immediately contains a <group by clause> that does not simply contain an <empty\ngrouping set>, then for every <sort key> SESK directly contained in SELECTSTM,\nCase:\na)\nIf SESK is a <binding variable reference> SEBVR, then SEBVR shall be equivalent to an <iden-\ntifier> that is immediately contained in a <select item alias> directly contained in SELECTSTM\nor a <regular identifier> that is a <grouping element> directly contained in SELECTSTM.\nb)\nOtherwise, for every <binding variable reference> OSEBVR that is directly contained in SESK,\nOSEBVR shall be equivalent to a <grouping element> of a <group by clause> immediately\ncontained in SELECTSTM.\n22)\nLet ORDER_BY be defined as follows.\nCase:\na)\nIf SELECTSTM immediately contains an <order by clause> OIOBC, then:\ni)\nLet OISEQ be the sequence determined as follows.\n1)\nInitially, OISEQ is the empty sequence.\n2)\nFor every <sort key> OISK simply contained in OIOBC,\nCase:\nA)\nIf SARISET is not the empty set and OISK directly contains an <aggregate\nfunction>, then the <identifier> immediately contained in the <return item\nalias> immediately contained in a <return item> in ARISET whose <value\nexpression> is OISK is added to OISEQ.\nB)\nIf GKRISET is not the empty set and OISK is not a <binding variable refer-\nence>, then:\nI)\nLet COOISK be a copy of OISK in which all simply contained <binding\nvariable reference>s that are the <value expression> of a <return\nitem>OIRIinGKRISETarereplacedwiththe<identifier>immediately\ncontained in the <return item alias> immediately contained in OIRI.\nII)\nCOOISK is added to OISEQ.\nC)\nIf LET_ITEMS is not the empty set and OISK is a <value expression> imme-\ndiately contained in a <let variable definition> OILVD, then the <value\nvariable> immediately contained in OILVD is added to OISEQ.\nD)\nOtherwise, OISK is added to OISEQ.\nii)\nLet NUM_OIS be the number of elements of OISEQ.\n« WG3:CMN-019 P00-NLD-050 »\niii)\nFor m, 1 ≤m ≤NUM_OIS, let OIm be the m-th element of OISEQ.\niv)\nORDER_BY is the comma-separated concatenation of the elements of OISEQ:\n190\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 205,
    "text": "OI1, ..., OINUM_OIS\nb)\nOtherwise, ORDER_BY is the zero-length character string.\n23)\nLet RETURN_FIRST be defined as follows.\nCase:\na)\nIf AGGREGATING_ITEMS is not empty, then:\ni)\nLet FIRST_ITEMS be the union of GKRISET, SARISET, ARISET, and HARISET.\nii)\nLet NUM_FIRST be the number of elements of FIRST_ITEMS.\n« WG3:CMN-019 P00-NLD-050 »\niii)\nLet FSTRIL be a permutation of FIRST_ITEMS. For p, 1 ≤p ≤NUM_FIRST, let FIRST_ITEMp\nbe the p-th element of FSTRIL.\niv)\nRETURN_FIRST is the comma-separated concatenation of the elements of FIRST_ITEMS:\nFIRST_ITEM1, ..., FIRST_ITEMNUM_FIRST. \nb)\nOtherwise, RETURN_FIRST is the zero-length character string.\n24)\nLet RETURN_LAST be defined as follows.\na)\nLet LAST_ITEMS be the union of NONAGGREGATING_ITEMS and PARISET.\nb)\nFor q, 1 ≤q ≤NUM_SIS, let LAST_ITEMq be defined as follows:\ni)\nLet ALIAS be the q-th element of XOISIASEQ.\nii)\nLAST_ITEMq is the element of LAST_ITEMS whose <return item alias> immediately\ncontains an <identifier> that is equivalent to ALIAS.\nc)\nRETURN_LAST is the comma-separated concatenation of the elements of LAST_ITEMS:\nLAST_ITEM1, ..., LAST_ITEMNUM_SIS\n25)\nLet OFFCL be defined as follows. If <offset clause> is specified, then OFFCL is the <offset clause>;\notherwise, OFFCL is the zero-length character string.\n26)\nLet LIMCL be defined as follows. If <limit clause> is specified, then LIMCL is the <limit clause>;\notherwise, LIMCL is the zero-length character string.\n27)\nLet BODY be defined as follows.\nCase:\na)\nIf SSB immediately contains the <select graph match list> SGML, then:\ni)\nLet NUM_SGMS be the number of <select graph match>es immediately contained in\nSGML.\nii)\nFor r, 1 (one) ≤r ≤NUM_SGMS:\n1)\nLet SGMr be the r-th <select graph match> in SGML.\n2)\nLet GREXPr be the <graph expression> immediately contained in SGMr.\n3)\nLet MATCHSTMr be the <match statement> immediately contained in SGMr.\n191\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 206,
    "text": "iii)\nBODY is:\nUSE GREXP1 MATCHSTM1\n...\nUSE GREXPNUM_SGMS MATCHSTMNUM_SGMS\nb)\nIf SSB immediately contains the <select query specification> SQS, then:\ni)\nLet NQS be the <nested query specification> immediately contained in SQS.\nii)\nCase:\n1)\nIf SQS immediately contains a <graph expression>, then NQS shall simply contain\nan <ambient linear query statement>.\n2)\nOtherwise, SQS does not immediately contain a <graph expression> and NQS shall\nsimply contain a <focused linear query statement>.\niii)\nLet USECL be defined as follows.\nCase:\n1)\nIf SQS immediately contains a <graph expression> GREXP, then USECL is:\nUSE GREXP\n2)\nOtherwise USECL is the zero-length character string.\niv)\nBODY is:\nUSECL\nCALL NQS\nc)\nOtherwise, BODY is the zero-length character string.\n28)\nAfter the application of all preceding Syntax Rules,\nCase:\na)\nIf BODY is the zero-length character string, then SELECTSTM is equivalent to:\nRETURN SETQ XOISIL\nand no further Syntax Rules of this Subclause are applied.\nb)\nOtherwise:\ni)\nLet REPLACEMENT be determined as follows:\n1)\nInitially, REPLACEMENT is:\nBODY\nFILTERSTM\n2)\nIf RETURN_FIRST is not the zero-length character string, then the following is\nappended to REPLACEMENT:\nRETURN SETQ RETURN_FIRST\nGROUP_BY\nNEXT\n3)\nThe following is appended to REPLACEMENT:\n192\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 207,
    "text": "HAVING_FILTER\nLETSTM\nRETURN SETQ RETURN_LAST\nORDER_BY OFFCL LIMCL\nii)\nSELECTSTM is effectively replaced by REPLACEMENT.\nGeneral Rules\nNone.\nConformance Rules\n« WG3:CMN-019 P00-USA-077 »\n1)\nWithout Feature GA07, “Ordering by discarded binding variables”, in conforming GQL langauge,\nthe <group by clause> immediately contained in a <select statement> shall not directly contain a\n<sort key> that directly contains a <binding variable reference> that is not equivalent to the\n<identifier> immediately contained in a <select item alias> that is directly contained in the <select\nstatement> unless the referenced binding variable of the <binding variable reference> is defined\nby an intervening BNF non-terminal simply contained in the <sort key>.\n« WG3:CMN-019 P00-USA-083 »\n2)\nWithout Feature GQ14, “Complex expressions in sort keys”, in conforming GQL langauge, the <value\nexpression> immediately contained in a <sort key> shall be a <binding variable reference>.\n3)\nWithout Feature GQ15, “GROUP BY clause”, conforming GQL language shall not contain a <group\nby clause>.\n« WG3:CMN-019 P00-USA-077 »\n4)\nWithout Feature GQ16, “Pre-projection aliases in sort keys”, in conforming GQL langauge, the <value\nexpression> immediately contained in a <sort key> shall not simply contain a <binding variable\nreference> that is not a <return item alias> in the preceding <return statement>.\n193\nIWD 39075:2023(E)\n14.12 <select statement>"
  },
  {
    "page": 208,
    "text": "15 Common statements and related elements\n15.1\n<call procedure statement> and <procedure call>\nFunction\nExecute a procedure.\nFormat\n<call procedure statement> ::=\n[ OPTIONAL ] CALL <procedure call>\n<procedure call> ::=\n<inline procedure call>\n| <named procedure call>\n** Editor’s Note (number 24) **\nConsider allowing <where clause>. See Language Opportunity GQL-169 .\n** Editor’s Note (number 25) **\nConsider adding standalone calls. A standalone call is a syntax shorthand for a <call procedure statement> that\nimplies\nYIELD * RETURN *\nand that can only occuras valid singular(orperhaps last) top-level statement executed by a procedure. Standalone\ncalls could be added by following existing syntactic precedence from Cypher or by introducing completely new\nsyntax. See Language Opportunity GQL-168 .\nSyntax Rules\n1)\nLet CPS be the <call procedure statement>.\n2)\nLet PC be the <procedure call> immediately contained in CPS.\n3)\nLet the record type IREDT be the declared type of the incoming working record of CPS.\n4)\nLet ITART be the record type of the declared type of the incoming working table of CPS.\n5)\nLet IREDTPC be IREDT amended by ITART.\n6)\nThe declared type of the incoming working record of PC is IREDTPC.\n7)\nThe declared type of the incoming working table of PC is the material unit binding table type.\n8)\nLet OTARTPC be defined as follows.\nCase:\na)\nIf PC is the <named procedure call> NPC and NPC has a declared type, then OTARTPC is the\nrecord type of the declared type of NPC.\n194\nIWD 39075:2023(E)"
  },
  {
    "page": 209,
    "text": "b)\nIf PC is the <inline procedure call> IPC and IPC has a declared type, then OTARTPC is the record\ntype of the declared type of IPC.\nc)\nOtherwise, OTARTPC is the material unit record type.\n9)\nITART and OTARTPC shall be field name-disjoint.\n10)\nLet OTART be ITART amended with OTARTPC.\n« WG3:CMN-019 P00-NLD-019 »\n11)\nThe declared type of the outgoing working record of CPS is IREDT.\n12)\nThe declared type of the outgoing working table of CPS is the binding table type whose record type\nis OTART.\n13)\nCPS has no declared type.\nGeneral Rules\n1)\nLet TABLE be the current working table.\n2)\nLet NEW_TABLE be a new empty binding table.\n3)\nFor each record R of TABLE in a new child execution context amended with R:\na)\nThe General Rules of PC are applied.\nb)\nLet RESULT be a new binding table defined as follows.\nCase:\ni)\nIf the current execution result is a binding table, then RESULT is the current execution\nresult.\nii)\nOtherwise, the current execution result is omitted and RESULT is a unit binding table.\nc)\nIf CPS immediately contains OPTIONAL, then\nCase:\n« WG3:CMN-019 P00-USA-366 »\ni)\nIf RESULT is an empty binding table, then:\n1)\nLet NULLS be a new record of type RTPC such that every field value is null.\n2)\nLet NR be R amended with NULLS.\n3)\nNR is appended to NEW_TABLE.\nii)\nOtherwise, the Cartesian product of R and RESULT is appended to NEW_TABLE.\n« WG3:CMN-019 P00-USA-351 »\n4)\nThe current working table is set to NEW_TABLE.\n5)\nThe current execution outcome is set to a successful outcome with an omitted result.\nConformance Rules\nNone.\n195\nIWD 39075:2023(E)\n15.1 <call procedure statement> and <procedure call>"
  },
  {
    "page": 210,
    "text": "15.2\n<inline procedure call>\nFunction\nExecute a procedure that is specified inline.\nFormat\n<inline procedure call> ::=\n[ <variable scope clause> ] <nested procedure specification>\n<variable scope clause> ::=\n<left paren> [ <binding variable reference list> ] <right paren>\n<binding variable reference list> ::=\n<binding variable reference> [ { <comma> <binding variable reference> }... ]\nSyntax Rules\n1)\nLet IPC be the <inline procedure call>.\n2)\nLet PROC be the <nested procedure specification> that is immediately contained in IPC.\n3)\nIf <variable scope clause> is not specified, then:\na)\nLet FNL be a comma-separated list of all the field names of the declared type of the incoming\nworking record of IPC.\nb)\nIPC is effectively replaced by:\n(FNL) PROC\n4)\nLet VSC be the <variable scope clause> immediately contained in IPC.\n5)\nLet BVRLN be defined as follows:\na)\nIf VSC immediately contains a <binding variable reference list> BVRL, then:\ni)\nBVRLN is the sequence of names of the binding variables referenced by the <binding\nvariable reference>s immediately contained in BVRL.\nii)\nBVRLN shall not contain two equal names at different positions.\n« WG3:CMN-019 P00-NLD-060 »\nb)\nOtherwise, BVRLN is the empty sequence.\n6)\nThe declared type of the incoming working record of PROC is the declared type of the incoming\nworking record of IPC without the field types not identified by BVRLN.\n7)\nThe declared type of the incoming working table of PROC is the declared type of the incoming\nworking table of IPC.\n8)\nThe declared type of the outgoing working record of IPC is the declared type of the outgoing\nworking record of PROC.\n9)\nThe declared type of the outgoing working table of IPC is the declared type of the outgoing working\ntable of PROC.\n10)\nThe declared type of IPC is the declared type of PROC.\n196\nIWD 39075:2023(E)\n15.2 <inline procedure call>"
  },
  {
    "page": 211,
    "text": "General Rules\n1)\nLet R be the current working record without the fields not identified by BVRLN.\n« WG3:CMN-019 P00-USA-351 »\n2)\nThe current working record is set to R.\n3)\nThe General Rules of PROC are applied.\n4)\nThe outcome of IPC is the outcome of PROC.\nConformance Rules\n1)\nWithout Feature GP01, “Inline procedure”, conforming GQL language shall not contain an <inline\nprocedure call>.\n2)\nWithout Feature GP02, “Inline procedure with implicit nested variable scope”, in conforming GQL\nlanguage, an <inline procedure call> shall contain a <variable scope clause>.\n3)\nWithout Feature GP03, “Inline procedure with explicit nested variable scope”, in conforming GQL\nlanguage, an <inline procedure call> shall not contain a <variable scope clause>.\n197\nIWD 39075:2023(E)\n15.2 <inline procedure call>"
  },
  {
    "page": 212,
    "text": "15.3\n<named procedure call>\nFunction\nExecute a named procedure.\n** Editor’s Note (number 26) **\nBindings for host languages should eventually be defined. See Language Opportunity GQL-003 .\nFormat\n<named procedure call> ::=\n<procedure reference> <left paren> [ <procedure argument list> ] <right paren>\n    [ <yield clause> ]\n<procedure argument list> ::=\n<procedure argument> [ { <comma> <procedure argument> }... ]\n<procedure argument> ::=\n<value expression>\nSyntax Rules\n1)\nLet NPC be the <named procedure call> and let PROC be the procedure identified by the <procedure\nreference> that is immediately contained in NPC.\n2)\nLet PROCDESC be the named procedure descriptor of PROC.\n3)\nLet PARAMS be the list of procedure parameters of PROCDESC, let PARAMSMIN be the number of\nprocedure parameters required by PROCDESC and let PARAMSMAX be the maximum number of\nprocedure parameters allowed by PROCDESC.\n4)\nLet ARGEXPS be the sequence of all <value expression>s that are simply contained in NPC in the\norder of their occurrence in NPC from left to right and let NUMARGS be the number of such elements\nin ARGEXPS.\n5)\nNUMARGS shall be greater than or equal to PARAMSMIN.\n6)\nNUMARGS shall be less than or equal to PARAMSMAX.\n« WG3:CMN-019 P00-USA-087 »\n7)\nFor i, 1 (one) ≤i ≤NUMARGS:\na)\nLet ARGEXPi be the i-th element of ARGEXPS.\nb)\nLet PTi be the declared type of the i-th element of PARAMS.\nc)\nThe Syntax Rules of Subclause 22.1, “Store assignment”, are applied with a transient site of\ntype PTi as TARGET and ARGEXPi as VALUE.\n8)\nIf NPC immediately contains a <yield clause>, then the procedure result type of PROCDESC shall be\na binding table type.\n9)\nThe declared type of NPC is the procedure result type of PROCDESC.\n198\nIWD 39075:2023(E)\n15.3 <named procedure call>"
  },
  {
    "page": 213,
    "text": "General Rules\n« WG3:CMN-019 P00-NLD-050 »\n1)\nFor i, 1 (one) ≤i ≤PARAMSMAX, let ARGVALi be defined as follows.\nCase:\na)\nIf i ≤NUMARGS, then ARGVALi is the result of ARGEXPi.\nb)\nOtherwise, ARGVALi is the default value of the i-th element of PARAMS.\n« WG3:CMN-019 P00-NLD-050 »\n2)\nFor i, 1 (one) ≤i ≤PARAMSMAX, let R be a new record comprising fields Fi defined as follows:\na)\nLet Ti be the declared type of the i-th element of PARAMS.\nb)\nLet TS be a transient site of type Ti. The General Rules of Subclause 22.1, “Store assignment”,\nare applied with TS as TARGET and ARGVALi as VALUE. Let TSVi be the value of TS.\nc)\nThe field name of Fi is the procedure parameter name of the i-th element of PARAMS and the\nfield value of Fi is TSVi.\n3)\nThe following steps are performed in a new child execution context with R as its working record:\na)\nExecute PROC.\nb)\nLet RESULT be the result returned from the successful execution of PROC.\nc)\nThe current execution outcome is set as follows.\nCase:\ni)\nIf a <yield clause> YC is specified, then:\n1)\nThe General Rules of YC are applied; let YIELD be the result returned from the\napplication of these General Rules.\n« WG3:CMN-019 P00-USA-351 »\n2)\nThe current execution outcome is set to a successful outcome with YIELD as its\nresult.\n« WG3:CMN-019 P00-USA-089 »\nii)\nOtherwise, set the current execution outcome to a successful outcome with RESULT as\nits result.\nConformance Rules\n1)\nWithout Feature GP04, “Named procedure calls”, conforming GQL Language shall not contain a\n<named procedure call>.\n2)\nWithout Feature GP09, “Graphs as procedure arguments”, in conforming GQL language, the declared\ntypeofa <valueexpression>immediatelycontainedina <procedureargument>shallnotbea graph\nreference value type.\n3)\nWithout Feature GP08, “Binding tables as procedure arguments”, in conforming GQL language, the\ndeclared type of a <value expression> immediately contained in a <procedure argument> shall not\nbe a binding table reference value type.\n199\nIWD 39075:2023(E)\n15.3 <named procedure call>"
  },
  {
    "page": 214,
    "text": "16 Common elements\n16.1\n<use graph clause>\nFunction\nDeclare a working graph and its scope.\nFormat\n<use graph clause> ::=\nUSE <graph expression>\nSyntax Rules\n1)\nLet UGC be the <use graph clause>.\n2)\nLet GE be the <graph expression> simply contained in UGC.\n3)\nLet PART be the instance of the BNF non-terminal that immediately contains UGC.\n4)\nThe scope clause of UGC is\nCase:\na)\nIf PART is simply contained in a <focused linear query statement> FLQS, then FLQS.\nb)\nIf PART is simply contained in a <focused linear data-modifying statement> FLDMS, then\nFLDMS.\n5)\nThe scope of G comprises\nCase:\na)\nIf PART is a <focused linear query statement part>, then the <simple linear query statement>\nimmediately contained in PART.\nb)\nIf PART is a <focused linear query and primitive result statement part>, then the <simple linear\nquery statement> and the <primitive result statement> immediately contained in PART.\nc)\nIf PART is a <focused primitive result statement>, then the <primitive result statement>\nimmediately contained in PART.\nd)\nIf PART is a <focused nested query specification>, then the <nested query specification>\nimmediately contained in PART.\ne)\nIf PART is a <focused linear data-modifying statement body>, then the <simple linear query\nstatement>, the <simple data-modifying statement>, the <simple linear data-accessing state-\nment>, and the <primitive result statement> immediately contained in PART.\nf)\nIf PART is a <focused nested data-modifying procedure specification>, then the <nested data-\nmodifying procedure specification> immediately contained in PART.\n6)\nUGC declares GE as a working graph.\n200\nIWD 39075:2023(E)"
  },
  {
    "page": 215,
    "text": "General Rules\nNone.\nConformance Rules\n1)\nWithoutFeature GQ01,“USE graph clause”, conformingGQLlanguage shallnot containa <usegraph\nclause>.\n201\nIWD 39075:2023(E)\n16.1 <use graph clause>"
  },
  {
    "page": 216,
    "text": "16.2\n<at schema clause>\nFunction\nDeclare a working schema and its scope.\nFormat\n<at schema clause> ::=\nAT <schema reference>\nSyntax Rules\n1)\nLet ASC be the <at schema clause>.\n2)\nLet S be the GQL-schema identified by the <schema reference> that is immediately contained in\nASC.\n3)\nLet PB be the <procedure body> immediately containing ASC.\n4)\nThe scope clause of ASC is PB.\n5)\nThe scope of S comprises PB.\n6)\nASC declares S as a working schema.\nGeneral Rules\nNone.\nConformance Rules\nNone.\n202\nIWD 39075:2023(E)\n16.2 <at schema clause>"
  },
  {
    "page": 217,
    "text": "16.3\n<binding variable reference>\nFunction\nSpecify binding variable references.\nFormat\n<binding variable reference> ::=\n<binding variable>\nSyntax Rules\n1)\nLet BVR be the <binding variable reference>.\n2)\nBVR specifies a binding variable reference.\n3)\nLet BV be the <binding variable> immediately contained in BVR.\n4)\nThe referenced binding variable of BVR is the binding variable identified by BVR.\nNOTE 144 — See Subclause 21.2, “Names and variables”.\n5)\nThe name of BVR is the name of the referenced binding variable of BVR.\n6)\nLet BVN be the name of BVR.\n7)\nLet IREDT be the declared type of the incoming working record of BVR.\n8)\nIREDT shall have a field type whose field name is BVN. Let BVFT be that field type.\nNOTE 145 — The field value type of the incoming working record corresponding to a referenced binding\nvariable ABV of a <binding variable reference> that is declared by a <graph pattern> AGP is defined by\nSR 25) of Subclause 16.7, “<graph pattern binding table>” to be the same as the projected field type of\nthe <binding variable reference> to ABV in the <graph pattern yield clause> of AGP. See SR 13), for the\ndefinition of projected field type.\n9)\nThe declared type of BVR is the value type of BVFT.\n10)\nThe binding graph pattern of BVR is defined, if existing, as the innermost <graph pattern> GP for\nwhich it holds that:\na)\nGP declares an <element variable> or a <path variable> equivalent to BV.\nb)\nAt least one of the following holds:\ni)\nBVR is simply contained in the <graph pattern where clause> of GP.\nii)\nBVR is contained in a <parenthesized path pattern where clause> simply contained in\nGP.\n11)\nThe degree of reference of BVR is defined as follows.\nCase:\na)\nIf the binding graph pattern GP of BVR is defined and declares an <element variable> EV\nequivalent to BV, then\nCase:\n203\nIWD 39075:2023(E)\n16.3 <binding variable reference>"
  },
  {
    "page": 218,
    "text": "i)\nIf BVR is simply contained in the <graph pattern where clause> of GP, then the degree\nof reference of BVR is the degree of exposure of EV by GP.\nNOTE 146 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and\nSubclause 16.10, “<path pattern expression>”.\nii)\nIf BVR is contained in a <parenthesized path pattern where clause> PPPWC simply\ncontained in GP, then let PPPE be the <parenthesized path pattern expression> that\nsimply contains PPPWC.\nNOTE 147 — This rule is applied after the syntactic transform that converts any <element\npattern where clause> to a <parenthesized path pattern where clause>.\nCase:\n1)\nIf EV is declared by PPPE, then the degree of reference of BVR is the degree of\nexposure of EV by PPPE.\nNOTE 148 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>”\nand Subclause 16.10, “<path pattern expression>”.\n2)\nOtherwise, let PP be the innermost <graph pattern> or <parenthesized path pat-\ntern expression> that contains PPPWC and that declares EV. The degree of refer-\nence of BVR is the degree of exposure of EV by PP. The degree of reference of BVR\nshall be singleton.\nNOTE 149 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>”\nand Subclause 16.10, “<path pattern expression>”.\nb)\nIf the binding graph pattern GP of BVR is defined and declares a <path variable> PV equivalent\nto BV, then the degree of reference of BVR is unconditional singleton.\nc)\nOtherwise, the degree of reference of BVR is defined as follows.\nCase:\ni)\nIf the declared type of BVR is a group list value type or a dynamic union type whose\ncomponent types are group list value types, then BVR has group degree of reference.\nii)\nOtherwise, the declared type of BVR is not a group list value type and\nCase:\n1)\nIf the declared type of BVR is material, then the degree of reference of BVR is\nunconditional singleton.\n2)\nOtherwise, the declared type of BVR is nullable and the degree of reference of\nBVR is conditional singleton.\n12)\nLet DEG be the degree of reference of BVR. If DEG is not singleton, then DEG shall be effectively\nbounded group and the declared type of BVR shall be a group list value type.\n13)\nIf the binding graph pattern GP of BVR is defined, then the projected field type PFT of BVR is the\nfield type whose name is BVN and whose value type is determined as follows:\nCase:\na)\nIf GP declares an <element variable> equivalent to BVN, then\nCase:\ni)\nIf DEG is unconditional singleton, then the value type of PFT is a value type that is\ndeterminedusing an implementation-defined(IW011)mechanismsuchthat it contains\n204\nIWD 39075:2023(E)\n16.3 <binding variable reference>"
  },
  {
    "page": 219,
    "text": "every reference value of a graph element to which BV can be bound by the evaluation\nof GP.\nii)\nIf DEG is conditional singleton, then the value type of PFT is a value type that is\ndeterminedusing an implementation-defined(IW011)mechanismsuchthat it contains\nevery reference value of a graph element to which BV can be bound by the evaluation\nof GP and the null value.\niii)\nOtherwise, DEG is group and the value type of PFT is determined using an implemen-\ntation-defined (IW011) mechanism such that:\n1)\nThe value type of PFT is either a group list value type or a dynamic union type\nwhose component types are group list value types.\n2)\nThe value type of PFT contains every list of reference values to a graph element\nto which BV can be bound by the evaluation of GP.\nb)\nOtherwise, GP declares a <path variable> equivalent to BVN and the value type of PFT is the\npath value type.\nGeneral Rules\n1)\nLet F be the field of the current working record whose field name is BVN.\n2)\nLet FV be the field value of F.\n3)\nIf the degree of reference of BVR is group and FV is not either a list value or the null value, then an\nexception condition is raised: data exception — invalid group variable value (22G13).\n4)\nThe result of BVR is FV.\nNOTE 150 — Every <binding variable reference> is evaluated by looking it up in the current working\nrecord. The referenced binding variable of a <binding variable reference> declared by a <graph pattern>\nis bound in the Subclause 22.6, “Application of bindings to evaluate an expression”.\nConformance Rules\n1)\nWithout Feature GP07, “Procedure-local graph variable definitions”, in conforming GQL language,\nthe declared type of a <binding variable reference> shall not be a graph reference value type.\n2)\nWithout Feature GP06, “Procedure-local binding table variable definitions”, in conforming GQL\nlanguage, the declared type of a <binding variable reference> shall not be a binding table reference\nvalue type.\n205\nIWD 39075:2023(E)\n16.3 <binding variable reference>"
  },
  {
    "page": 220,
    "text": "16.4\n<element variable reference>\nFunction\nSpecify element variable references.\nFormat\n<element variable reference> ::=\n<binding variable reference>\nSyntax Rules\n1)\nLet EVR be the <element variable reference>.\n2)\nLet EVRDT be the declared type of EVR.\n3)\nCase:\na)\nIf the degree of reference of EVR is singleton, then EVRDT shall be a node reference value type\nor an edge reference value type.\nb)\nOtherwise, the degree of reference of EVR is group and EVRDT shall be a group list value type\nwhose list element type only includes node reference values, edge reference values, or the\nnull value.\nGeneral Rules\nNone.\nNOTE 151 — Every <element variable reference> is evaluated in the General Rules of Subclause 16.3, “<binding\nvariable reference>” by looking it up in the current working record or the current working schema. However\nthe actual element variable reference value is originally constructed and bound in the General Rules of\nSubclause 22.6, “Application of bindings to evaluate an expression”.\nConformance Rules\nNone.\n206\nIWD 39075:2023(E)\n16.4 <element variable reference>"
  },
  {
    "page": 221,
    "text": "16.5\n<path variable reference>\nFunction\nSpecify path variable references.\nFormat\n<path variable reference> ::=\n<binding variable reference>\nSyntax Rules\n1)\nLet PVR be the <path variable reference>.\n2)\nThe degree of reference of PVR shall be unconditional singleton.\n3)\nThe declared type of PVR shall be a path value type.\nGeneral Rules\nNone.\nNOTE 152 — Every <path variable reference> is evaluated in the General Rules of Subclause 16.3, “<binding\nvariable reference>” by looking it up in the current working table. However the actual path value is originally\nconstructedandboundintheGeneralRulesofSubclause22.6,“Applicationofbindingstoevaluateanexpression”.\nConformance Rules\nNone.\n207\nIWD 39075:2023(E)\n16.5 <path variable reference>"
  },
  {
    "page": 222,
    "text": "16.6\n<parameter>\nFunction\nSpecify parameters.\nFormat\n<parameter> ::=\n<parameter name>\nSyntax Rules\n« Editorial: Define symbol P »\n1)\nLetPbe<parameter>.LetPNbethenamespecifiedbythe<parametername>immediatelycontained\nin P.\n2)\nCase:\na)\nIf there is a request parameter RP with parameter name PN in the current request context,\nthen P identifies RP and the declared type of P is the value type of the parameter value of RP.\nb)\nIf there is a session parameter SP with parameter name PN in the current session context,\nthen P identifies SP and the declared type of P is the value type of the parameter value of SP.\nc)\nOtherwise, an exception condition is raised: syntax error or access rule violation — invalid\nreference (42002).\n3)\nThe result of P is the parameter value of the parameter identified by P.\nNOTE 153 — The result of P is determinedfrom the GQL-requestbefore regular executionand is available\nduring the evaluation of Syntax Rules.\nGeneral Rules\nNone.\nConformance Rules\n1)\nWithout Feature GE04, “Graph parameters”, in conforming GQL language, the declared type of a\n<parameter> shall not be a graph reference value type.\n2)\nWithout Feature GE05, “Binding table parameters”, in conforming GQL language, the declared type\nof a <parameter> shall not be a binding table reference value type.\n208\nIWD 39075:2023(E)\n16.6 <parameter>"
  },
  {
    "page": 223,
    "text": "16.7\n<graph pattern binding table>\nFunction\nEvaluate a <graph pattern> to a binding table.\nFormat\n<graph pattern binding table> ::=\n<graph pattern> [ <graph pattern yield clause> ]\n<graph pattern yield clause> ::=\nYIELD <graph pattern yield item list>\n<graph pattern yield item list> ::=\n<graph pattern yield item> [ { <comma> <graph pattern yield item> }... ]\n| NO BINDINGS\n<graph pattern yield item> ::=\n<element variable reference>\n| <path variable reference>\nSyntax Rules\n1)\nLet GPBT be the <graph pattern binding table> and let GP be the <graph pattern> simply contained\nin GPBT.\n2)\nEvery variable in the scope of GP is also in the scope of the <graph pattern yield clause> simply\ncontained in GPBT.\n3)\nLet EVSET be the set of names of element variable declared by GP, let PVSET be the set of names of\npath variables declared by GP, and let GPVARS be a permutation of EVSET ∪PVSET in the order of\ntheir first occurrence as an <element variable declaration> or a <path variable declaration>,\nrespectively, that is simply contained in GP. Let SPVSET be the set of names of subpath variables\ndeclared by GP.\n** Editor’s Note (number 27) **\nHandling of subpath variables to be decided. See Language Opportunity GQL-194 .\n4)\nEach graph pattern variable name in GPVARS shall identify exactly one graph pattern variable in\nGP at the same depth of graph pattern matching.\n5)\nLet GLOBALS be GPVARS restricted to the names of graph pattern variables in the scope of GP.\n6)\nLet IREDT be the declared type of the incoming working record of GPBT.\n7)\nIREDT shall not contain a field whose name is in SPVSET.\n8)\nLet ITART be the record type of the declared type of the incoming working table of GPBT.\n9)\nITART shall not contain a field whose name is in SPVSET.\n10)\nLet RECORD_OVERLAP be GLOBALS restricted to the names of fields of IREDT, let TABLE_OVERLAP\nbe GLOBALS restricted to the names of fields of ITART, and let OVERLAP be the concatenation of\nRECORD_OVERLAP with TABLE_OVERLAP.\n11)\nThe sequence of variable names XGPYCVARS is defined as follows.\n209\nIWD 39075:2023(E)\n16.7 <graph pattern binding table>"
  },
  {
    "page": 224,
    "text": "Case:\na)\nIf an explicit <graph pattern yield clause> XGPYC is specified, then XGPYCVARS is the sequence\nof names of variables identifiedby instances of <binding variable reference>s simply contained\nin XGPYC.\n« WG3:CMN-019 P00-NLD-060 »\nb)\nOtherwise, XGPYCVARS is the empty sequence.\n12)\nCase:\na)\nIf the length of XGPYCVARS is at least 1 (one), then:\ni)\nXGPYCVARS shall not contain two equal names at different positions.\nii)\nEvery name in XGPYCVARS shall be contained in GLOBALS.\niii)\nLet OGPYCVARS be OVERLAP without the names contained in XGPYCVARS.\niv)\nLet GPYIL be the comma-separated list of the elements of the concatenation of\nOGPYCVARS with XGPYCVARS.\nv)\nXGPYC is equivalent to:\nYIELD GPYIL\n« WG3:CMN-019 P00-NLD-060 »\nb)\nOtherwise, XGPYCVARS is the empty sequence.\nCase:\ni)\nIf GLOBALS is empty, then the implicit <graph pattern yield clause> of GPBT is:\nYIELD NO BINDINGS\nii)\nOtherwise,GLOBALSisnotempty.LetGPYILbethecomma-separatedlistoftheelements\nof GLOBALS. The implicit <graph pattern yield clause> of GPBT is:\nYIELD GPYIL\n13)\nLet GPYC be the explicit or implicit <graph pattern yield clause> after the application of SR 12).\n« WG3:CMN-019 P00-USA-091 »\n14)\nLet GPYCREFS be defined as follows:\nCase:\n« WG3:CMN-019 P00-NLD-060 »\na)\nIf GPYC is YIELD NO BINDINGS, then GPYCREFS is the empty sequence.\nb)\nOtherwise, GPYCREFS is the sequence of <binding variable reference>s simply contained in\nGPYC.\nNOTE 154 — This is restricted to variable names from GLOBALS, i.e., in particular contains no names of\nsubpath variables declared by GP.\n15)\nThe binding graph pattern of each <binding variable reference> in GPYCREFS shall be GP.\nNOTE 155 — See SR 10) of Subclause 16.3, “<binding variable reference>”, for the definition of binding\ngraph pattern.\n210\nIWD 39075:2023(E)\n16.7 <graph pattern binding table>"
  },
  {
    "page": 225,
    "text": "16)\nFor every <binding variable reference> BVR2 with name NAME in GPYCREFS for which it holds that\nNAME is the name of a field in IREDT or ITART:\na)\nLet STM be the innermost <linear query statement> or <linear data-modifying statement>\nthat simply contains GPBT.\nb)\nLet TEMPVAR be an implementation-dependent(UV012)variable name not equal to the name\nof any field of IREDT or ITART.\nc)\nLet LS be the <let statement> simply contained in a simulated transformation of the current\n<GQL-program> obtained as the result of substituting STM with:\nCALL {\nLET TEMPVAR = NAME\nFINISH\n} \nSTM\nd)\nLet BVR1 be the instance of <binding variable reference> simply contained in LS.\ne)\nLet DEG1 and DEG2 be the degrees of reference of BVR1 and BVR2, respectively.\nf)\nIt shall hold that either both DEG1 and DEG2 are singleton or both DEG1 and DEG2 are group.\n17)\nLet GPYCVARS be the sequence of the names of the binding variables identified by the elements of\nGPYCREFS in the same order as in GPYCREFS.\n18)\nLet GPYCFTSET be the set of the projected field types of all elements of GPYCREFS.\nNOTE 156 — See SR 13) of Subclause 16.3, “<binding variable reference>”, for the definition of projected\nfield type.\n19)\nLet GPYCRT be the closed record type whose field type set is GPYCFTSET.\n20)\nThe declared type of the incoming working record of GPBT and GPYCRT shall be field type-compar-\nable.\n21)\nThe record type of the declared type of the incoming working table of GPBT and GPYCRT shall be\nfield type-comparable.\n22)\nFor each <element property specification> EPS simply contained in GP:\na)\nLet EPP be the <element pattern predicate> that simply contains EPS.\nb)\nLet EPF be the <element pattern filler> that simply contains EPP.\nc)\nLet EVARDECL and EVAR be defined as follows.\nCase:\ni)\nIf EPF simply contains an <element variable declaration> EVARDECL, then EVAR is the\n<identifier> contained in the <element variable declaration> simply contained in EPF.\nii)\nOtherwise,EVAR is an implementation-dependent(UV008)<element variable> distinct\nfrom every element variable, subpath variable, and path variable contained in GP and\nEVARDECL is TEMP EVAR.\nNOTE 157 — In this case, EVAR specifies a temporary element variable which is never\ncontained in GPYC.\n« WG3:CMN-019 P00-USA-095 »\nd)\nLet EPILE be defined as follows: If EPF simply contains the <is label expression> EPILE_CAND,\nthen EPILE is EPILE_CAND; otherwise, EPILE is the zero-length character string.\n211\nIWD 39075:2023(E)\n16.7 <graph pattern binding table>"
  },
  {
    "page": 226,
    "text": "e)\nLet PECL be the <property key value pair list> simply contained in EPS.\nf)\nLet NOPEC be the number of <property key value pair>s simply contained in PECL.\ng)\nLet PEC1, ..., PECNOPEC be the <property key value pair>s simply contained in PECL.\n« WG3:CMN-019 P00-NLD-050 »\nh)\nFor i, 1 (one) ≤i ≤NOPEC:\ni)\nLet PROPi be the <property name> simply contained in PECi.\nii)\nLet VALi be the <value expression> simply contained in PECi.\niii)\nLet RPECi be a <comparison predicate> formed as:\nEVAR.PROPi = VALi\ni)\nLet EPSC be a <boolean value expression> formed through the concatenation of <boolean\nfactor>s: RPEC1 AND ... AND ... RPECNOPEC.\nj)\nEPF is effectively replaced by:\nEVARDECL EPILE WHERE EPSC\n23)\nLet GPT be the <graph pattern> simply contained in GPBT after the preceding transformations and\nlet PPLT be the <path pattern list> simply contained in GPT.\n24)\nLet PG be the current working graph available at GPBT.\nNOTE 158 — If no current working graph is available at GPBT, then this rule cannot be satisfied. See\nSubclause 4.7.3, “Working objects”.\n25)\nFor every <value expression> or <search condition> EXP simply contained in GP, if EXP is evaluated\nin a new child executioncontext CONTEXT during the applicationof the Subclause 22.6, “Application\nof bindings to evaluate an expression”, then:\na)\nThe declared type of the incoming working record of EXP is the record type whose field types\nare given by the union between:\ni)\nIREDT without the fields identified by RECORD_OVERLAP.\nii)\nITART without the fields identified by TABLE_OVERLAP.\niii)\nThe projected field types of all graph pattern variable references simply contained in\nEXP whose variables are declared by GP and that are exposed in EXP.\nNOTE 159 — See SR 13) of Subclause 16.3, “<binding variable reference>”, for the definition\nof projected field type.\nb)\nThe declared type of the incoming working table of EXP is the unit binding table type.\n26)\nLet GPBTRT be the closed record type whose field types are given by the union between:\na)\nIREDT without the fields identified by RECORD_OVERLAP.\nb)\nITART without the fields identified by TABLE_OVERLAP.\nc)\nGPYCFTSET.\n27)\nThe declared type of GPBT is the binding table type whose record type is GPBTRT.\n212\nIWD 39075:2023(E)\n16.7 <graph pattern binding table>"
  },
  {
    "page": 227,
    "text": "General Rules\n1)\nThe General Rules of Subclause 22.2, “Machinery for graph pattern matching”, are applied with PG\nas PROPERTY GRAPH and PPLT as PATH PATTERN LIST; let MACH be the MACHINERY returned from\nthe application of those General Rules.\n2)\nLet MATCH_TABLE be a new empty binding table whose columns are the columns of the declared\ntype of GPBT.\n3)\nThe preferred column name sequence PCNS of MATCH_TABLE is the concatenation of the following\nsequences of names in the order given.\nCase:\na)\nIf the current working table has a preferred column name sequence PCS, then PCNS is the\nconcatenation of:\ni)\nThe field names of IREDT not included in XGPYCVARS, in ascending order.\nii)\nPCS without the names included in XGPYCVARS.\niii)\nXGPYCVARS.\nb)\nOtherwise, PCNS is the concatenation of:\ni)\nThe field names of IREDT and ITART not included in XGPYCVARS, in ascending order.\nii)\nXGPYCVARS.\n4)\nLet CWR be the current working record.\n5)\nFor each record OUTER in the current working table:\na)\nLet INNER_TABLE be a new empty binding table whose columns are the field types in\nGPYCFTSET.\nb)\nLet COMBINED be CWR amended with OUTER.\nc)\nLet SANITIZED be COMBINED without the fields identified by OVERLAP.\nd)\nIn a new child execution context whose working record is SANITIZED, the General Rules of\nSubclause 16.8, “<graph pattern>”, are applied with PG as PROPERTY GRAPH, GPT as GRAPH\nPATTERN, PPLT as PATH PATTERN LIST, and MACH as MACHINERY; let MATCHES be the SET\nOF REDUCED MATCHES returned from the application of those General Rules.\ne)\nFor each reduced match RM in MATCHES:\ni)\nThe General Rules of Subclause 22.8, “Application of bindings to generate a record”,\nare applied with GPT as GRAPH PATTERN, GPYC as YIELD CLAUSE, RM as MULTI-PATH\nBINDING, and MACH as MACHINERY; let INNER be the RECORD returned from the\napplication of those General Rules.\nii)\nINNER is appended to INNER_TABLE.\nf)\nThe binding table constructed as the natural join between COMBINED and INNER_TABLE is\nappended to MATCH_TABLE.\n6)\nThe result of GPBT is MATCH_TABLE.\n213\nIWD 39075:2023(E)\n16.7 <graph pattern binding table>"
  },
  {
    "page": 228,
    "text": "Conformance Rules\n1)\nConforming GQL language shall not contain a <graph pattern yield item list> that contains NO\nBINDINGS.\nNOTE 160 — A <graph pattern yield item list> that contains NO BINDINGS is a specification device and\nis not syntax available to the user.\n2)\nWithout Feature GQ19, “Graph pattern YIELD clause”, conforming GQL language shall not contain\na <graph pattern binding table> that immediately contains a <graph pattern yield clause>.\n214\nIWD 39075:2023(E)\n16.7 <graph pattern binding table>"
  },
  {
    "page": 229,
    "text": "16.8\n<graph pattern>\nFunction\nSpecify a pattern to be matched in a graph.\nSubclause Signature\n“<graph pattern>” [General Rules] (\n  Parameter: “PROPERTY GRAPH”, \n  Parameter: “GRAPH PATTERN”, \n  Parameter: “PATH PATTERN LIST”, \n  Parameter: “MACHINERY”\n) Returns: “SET OF REDUCED MATCHES”\nPROPERTY GRAPH — a property graph\nGRAPH PATTERN — a <graph pattern>.\nPATH PATTERN LIST — a <path pattern list>.\nMACHINERY — the machinery for graph pattern matching.\nSET OF REDUCED MATCHES — the resulting set of reduced matches.\n—This signature is invoked from Subclause 16.7, “<graph pattern binding table>”, GR 5)d)\nFormat\n<graph pattern> ::=\n[ <match mode> ] <path pattern list>\n    [ <keep clause> ]\n    [ <graph pattern where clause> ]\n<match mode> ::=\n<repeatable elements match mode>\n| <different edges match mode>\n<repeatable elements match mode> ::=\nREPEATABLE <element bindings or elements>\n<different edges match mode> ::=\nDIFFERENT <edge bindings or edges>\n<element bindings or elements> ::=\nELEMENT [ BINDINGS ]\n| ELEMENTS\n<edge bindings or edges> ::=\n<edge synonym> [ BINDINGS ]\n| <edges synonym>\n<path pattern list> ::=\n<path pattern> [ { <comma> <path pattern> }... ]\n<path pattern> ::=\n[ <path variable declaration> ] [ <path pattern prefix> ] <path pattern expression>\n<path variable declaration> ::=\n215\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 230,
    "text": "<path variable> <equals operator>\n<keep clause> ::=\nKEEP <path pattern prefix>\n<graph pattern where clause> ::=\nWHERE <search condition>\nSyntax Rules\n1)\nLet GP be the <graph pattern>.\n2)\nIf BNF1 and BNF2 are instances of two BNF non-terminals, both contained in GP without an inter-\nvening <graph pattern>, then BNF1 and BNF2 are said to be at the same depth of graph pattern\nmatching.\nNOTE 161 — BNF1 can contain BNF2 while being at the same depth of graph pattern matching.\n3)\nIn a <path pattern list>, if two <path pattern>s expose an element variable EV, then both shall expose\nEV as an unconditional singleton variable.\nNOTE 162 — This case expresses an implicit join on EV. Implicit joins between conditional singleton\nvariables or group variables are forbidden.\n4)\nTwo <path pattern>s shall not expose the same subpath variable.\nNOTE 163 — Implicit equijoins on subpath variables are not supported.\n5)\nThe name of a node variable shall not be equivalent to the name of an edge variable declared at the\nsame depth of graph pattern matching.\n6)\nIf <keep clause> KP is specified, then:\na)\nLet PSP be the <path pattern prefix> simply contained in KP.\nb)\nFor each <path pattern> PP simply contained in GP:\ni)\nPP shall not contain a <path search prefix>.\nii)\nCase:\n1)\nIfPPspecifiesa<pathvariabledeclaration>,thenletPVDECLbethat<pathvariable\ndeclaration>.\n2)\nOtherwise, let PVDECL be the zero-length character string.\niii)\nCase:\n1)\nIf PP specifies a <path mode prefix>, then let PMP be that <path mode prefix>.\n2)\nOtherwise, let PMP be the zero-length character string.\niv)\nLet PPE be the <path pattern expression> simply contained in PP.\nv)\nPP is replaced by\nPVDECL PSP ( PMP PPE )\nc)\nThe <keep clause> is removed from the <graph pattern>.\n** Editor’s Note (number 28) **\n216\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 231,
    "text": "It has been suggested that it might be possible to treat the <path pattern prefix> specified in <keep\nclause> as merely providing a default <path pattern prefix> rather than a mandatory one for each\n<path pattern>. Whereas nested <path pattern prefix> is prohibited, this may be a feasible avenue of\ngrowth. On the other hand, perhaps a less definitive verb than KEEP may be appropriate when spe-\ncifying a default <path pattern prefix>. See Language Opportunity GQL-057 .\n7)\nAfter the preceding transformations, for every <path pattern> PP, if PP contains a <path pattern\nprefix> PPP that specifies a <path mode> PM, then:\na)\nCase:\ni)\nIf PP specifies a <path variable declaration>, then let PVDECL be that <path variable\ndeclaration>.\nii)\nOtherwise, let PVDECL be the zero-length character string.\nb)\nLet PPE be the <path pattern expression> simply contained in PP.\nc)\nPP is replaced by\nPVDECL PPP ( PM PPE )\nNOTE 164 — One effect of the preceding transforms is that every <path mode> expressed outside\na <parenthesized path pattern expression> is also expressed within a <parenthesized path pattern\nexpression>. For example,\nALL SHORTEST TRAIL GROUP <path pattern expression>\nis rewritten as\nALL SHORTEST TRAIL GROUP ( TRAIL <path pattern expression> )\nThe TRAIL specified outside the parentheses is now redundant. The benefit is that the definition\nof a consistent path binding in Subclause 22.2, “Machinery for graph pattern matching”, only has\nto consider <path mode>s declared in <parenthesized path pattern expression>s.\n8)\nLet GPT be the <graph pattern> after the preceding syntactic transformations.\n9)\nLet PPL be the <path pattern list> simply contained in GPT.\n10)\nIf GPT does not specify a <match mode>, then an implementation-defined (ID086) <match mode>\nis implicit.\n11)\nLet MM be the <match mode> implicitly or explicitly specified by GPT.\n12)\nIf MM is <different edges match mode> and PPL simply contains a <path pattern> that is selective,\nthen PPL shall not simply contain any other <path pattern>.\nNOTE 165 — If MM is <different edges match mode> and there is a selective <path pattern> SPP, then\nPPL must only contain SPP. If there is no selective <path pattern> in GPT, then there are no restrictions\non how many non-selective <path pattern>s are contained in PPL. If MM is <repeatable elements match\nmode>, then there is no restriction on how many (selective and non-selective) <path pattern>s are con-\ntained in PPL.\n13)\nLet E be an element variable declared by GPT.\nCase:\na)\nIf E is exposed by GPT as an unconditional singleton, then E is a global unconditional singleton\nof GPT.\nb)\nOtherwise, let PPPE be the outermost <parenthesized path pattern expression> that exposes\nE as an unconditional singleton; the unconditional singleton scope index of E in GPT is the\nbracket index of PPPE.\n217\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 232,
    "text": "NOTE 166 — Bracket index is defined in Subclause 22.2, “Machinery for graph pattern matching”.\nThe unconditional singleton scope index is well-defined because implicit equijoins between condi-\ntional singleton variables or group variables are forbidden. Hence there cannot be two <parenthes-\nized path pattern expression>s that expose E as a conditional singleton or group variable unless\none is contained in the other. For example,\n( ( ( -[E]-> ) -[E]-> )* -[F]-> )*\nThe unconditional singleton scope of E is the middle <parenthesized path pattern expression> in\nthe nest of three.\n14)\nAfter the preceding transformations, for every <quantified path primary> QPP contained in GPT,\nat least one of the following shall be true:\na)\nThe <graph pattern quantifier> of QPP is bounded.\nb)\nQPP is contained in a restrictive <parenthesized path pattern expression>.\nc)\nQPP is contained in a selective <path pattern>.\nd)\nMM is <different edges match mode>.\n« Editorial: Standardize the spelling of keyword »\nNOTE 167 — Unless an explicit <path mode> other than WALK is specified, an explicit or implicit\nspecificationof a <different edges match mode> effectively imparts the <path mode> TRAIL without\nthe presence of the keyword TRAIL.\n« WG3:CMN-019 P00-USA-007 »\n15)\nEach <path variable> PV contained in GPT is the name of a path variable. The degree of exposure of\nthe path variable that PV identifies is unconditional singleton.\nGeneral Rules\n1)\nLet PG be the PROPERTY GRAPH, let GPT be the GRAPH PATTERN, let PPL be the PATH PATTERN\nLIST, and let MACH be the MACHINERY in an application of the General Rules of this Subclause. The\nresult of the application of this Subclause is returned as SET OF REDUCED MATCHES.\nNOTE 168 — In this document, PG is always the current working graph.\n2)\nThe following components of MACH are identified:\na)\nABC, the alphabet, formed as the disjoint union of the following:\ni)\nSVV, the set of names of node variables.\nii)\nSEV, the set of names of edge variables.\niii)\nSPS, the set of subpath symbols.\niv)\nSAS, the set of anonymous symbols.\nv)\nSBS, the set of bracket symbols.\nb)\nREDUCE, the function mapping path bindings to path bindings, and multi-path bindings to\nmulti-path bindings.\n3)\nLet NP be the number of <path pattern>s simply contained in PPL. Let PP1, ..., PPNP be the <path\npattern>s simply contained in PPL after the transformations in the Syntax Rules.\n4)\nA multi-path binding MPBINDING is different-edges-matched if, for every edge binding EB1 = (EV1,\nE) contained in MPBINDING, there is no edge binding EB2 = (EV2, E) contained in MPBINDING at a\ndifferent position than EB1 that binds the edge E.\n218\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 233,
    "text": "5)\nFor every i, 1 (one) ≤i ≤NP:\na)\nLet PPE be the <parenthesized path pattern expression> simply contained in PPi.\nb)\nThe General Rules of Subclause 22.3, “Evaluation of a <path pattern expression>”, are applied\nwith PG as PROPERTY GRAPH, PPL as PATH PATTERN LIST, MACH as MACHINERY, and PPE as\nSPECIFIC BNF INSTANCE; let SMPPEi be the SET OF MATCHES returned from the application\nof those General Rules.\nNOTE 169 — If an elementary variable has been multiply declared within a restrictive <parenthes-\nized path pattern expression> PP, then no matches are returned for PP. For example:\nMATCH ACYCLIC (X) -> (X)\ndoes not find any results, even if there are nodes with self-edges.\nc)\nCase:\ni)\nIf PPi is a selective <path pattern>, then:\n1)\nCase:\nA)\nIf MM is <different edges match mode>, then let SMUPi be the set of different-\nedges-matched multi-path bindings in SMPPEi.\nNOTE 170 — If an edge variable has been multiply declared within a <path\npattern> PP, then no matches are returned for PP. For example, the following\nproduces no results:\nMATCH DIFFERENT EDGES\nANY SHORTEST () -[E]-> () -[E]-> ()\nB)\nOtherwise, let SMUPi be SMPPEi.\n2)\nThe General Rules of Subclause 22.4, “Evaluation of a selective <path pattern>”,\nare applied with PG as PROPERTY GRAPH, PPL as PATH PATTERN LIST, MACH as\nMACHINERY, PPi as SELECTIVE PATH PATTERN, and SMUPi as INPUT SET OF\nLOCAL MATCHES; let SMi be the OUTPUT SET OF LOCAL MATCHES returned from\nthe application of those General Rules.\nii)\nOtherwise, let SMi be SMPPEi.\n6)\nLet CROSS be the cross product SM1 ⨯... ⨯SMNP.\n7)\nLetINNERbethesetofmulti-pathbindingsMPBinCROSSsuchthat,foreveryunconditionalsingleton\n<element variable> USV exposed by PPL, USV is bound to a unique graph element by the elementary\nbindings of USV contained in MPB.\nNOTE 171 — Anonymous symbols are not <element variable>s; there is no requirement that two\nanonymous symbols bind to the same graph element.\n8)\nCase:\na)\nIfMMis<differentedgesmatchmode>,thenletBINDINGSbethesetofdifferent-edges-matched\nmulti-path bindings in INNER.\nNOTE 172 — If an edge variable has been multiply declared within a <graph pattern> GP, then no\nmatches are returned for GP. For example, the following produces no results:\nMATCH DIFFERENT EDGES () -[E]-> (), () -[E]-> ()\nand neither does the following:\n219\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 234,
    "text": "MATCH DIFFERENT EDGES () -[E]-> () -[E]-> ()\nb)\nOtherwise, let BINDINGS be INNER.\n9)\nA match of GPT is a multi-path binding M = ( PB1, ..., PBNP ) of NP path bindings in BINDINGS, such\nthat all of the following are true:\na)\nFor every j, 1 (one) ≤j ≤NP, and for every <parenthesized path pattern expression> PPPE\ncontained in PPj, let i be the bracket index of PPPE, and let `[i` and `]i` be the bracket symbols\nassociated with PPPE. A binding of PPPE is a substring of PBj that begins with the bracket\nbinding (`[i`, `[i`) and ends with the next bracket binding (`]i`, `]i`).\nNOTE 173 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”.\nFor every binding BPPPE of PPPE contained in PBj, all of the following are true:\ni)\nFor every <elementvariable>EV that is exposedas an unconditionalsingleton by PPPE,\nEV is bound to a unique graph element by the element variable bindings contained in\nBPPPE.\nNOTE 174 — Anonymous symbols are not <element variable>s; there is no requirement\nthat two anonymous symbols bind to the same graph element.\n« Editorial: Use new applySC asTest option »\nii)\nIf PPPE contains a <parenthesized path pattern where clause> PPPWC, then True is the\nVALUE returned as V1 when the General Rules of Subclause 22.6, “Application of\nbindings to evaluate an expression”, are applied with GPT as GRAPH PATTERN, the\n<search condition> simply contained in PPPWC as EXPRESSION, MACH as MACHINERY,\nM as MULTI-PATH BINDING, and a reference to BPPPE as REFERENCE TO LOCAL CON-\nTEXT.\n« Editorial: Use new applySC asTest option »\nb)\nIf GPT contains a <graph pattern where clause> GPWC, then True is the VALUE returned as V2\nwhen the General Rules of Subclause 22.6, “Application of bindings to evaluate an expression”,\nare applied with GPT as GRAPH PATTERN, GPWC as EXPRESSION, MACH as MACHINERY, M as\nMULTI-PATH BINDING, and a reference to M as REFERENCE TO LOCAL CONTEXT.\n10)\nA reduced match RM = ( RPB1, ..., RPBNP ) is obtained from a match M = ( PB1, ..., PBNP ) as RM =\nREDUCE(M).\nNOTE 175 — Set-theoretic deduplication will occur here. That is, two or more matches can reduce to the\nsame reduced match; this scenario is regarded as contributing only a single reduced match to the result\nset.\n11)\nLet SRM be the set of reduced matches.\n12)\nEvaluation of the General Rules is terminated and control is returned to the invoking Subclause,\nwhich receives SRM as SET OF REDUCED MATCHES.\nConformance Rules\n1)\nWithout Feature G002, “Different-edges match mode”, conforming GQL language shall not contain\na <different edges match mode>.\n2)\nWithout Feature G003, “Explicit REPEATABLE ELEMENTS keyword”, conforming GQL language\nshallnotcontaina<matchmode>thatspecifiesREPEATABLEELEMENTSorREPEATABLEELEMENT\nBINDINGS.\n220\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 235,
    "text": "3)\nWithout Feature G004, “Path variables”, conforming GQL language shall not contain a <path pattern>\nthat simply contains a <path variable declaration>.\n4)\nWithout Feature G005, “Path search prefix in a path pattern”, conforming GQL language shall not\ncontain a <path pattern> that simply contains a <path pattern prefix> that is a <path search prefix>.\n5)\nWithout Feature G006, “Graph pattern KEEP clause: path mode prefix”, conforming GQL language\nshall not contain a <keep clause> that simply contains a <path mode prefix>.\n6)\nWithout Feature G007, “Graph pattern KEEP clause: path search prefix”, conforming GQL language\nshall not contain a <keep clause> that simply contains a <path search prefix>.\n221\nIWD 39075:2023(E)\n16.8 <graph pattern>"
  },
  {
    "page": 236,
    "text": "16.9\n<path pattern prefix>\nFunction\nSpecify a path-finding operation and a path mode.\nFormat\n<path pattern prefix> ::=\n<path mode prefix>\n| <path search prefix>\n<path mode prefix> ::=\n<path mode> [ <path or paths> ]\n<path mode> ::=\nWALK\n| TRAIL\n| SIMPLE\n| ACYCLIC\n<path search prefix> ::=\n<all path search>\n| <any path search>\n| <shortest path search>\n** Editor’s Note (number 29) **\nThe ability to specify “cheapest” queries (analogous to SHORTEST, but minimizing the sum of costs along a path)\nis desirable. See Language Opportunity GQL-052 .\n<all path search> ::=\nALL [ <path mode> ] [ <path or paths> ]\n<path or paths> ::=\nPATH | PATHS\n<any path search> ::=\nANY [ <number of paths> ] [ <path mode> ] [ <path or paths> ]\n<number of paths> ::=\n<unsigned integer specification>\n** Editor’s Note (number 30) **\nThis differs from the SQL/PGQ definition of <number of paths>.\n<shortest path search> ::=\n<all shortest path search>\n| <any shortest path search>\n| <counted shortest path search>\n| <counted shortest group search>\n<all shortest path search> ::=\nALL SHORTEST [ <path mode> ] [ <path or paths> ]\n<any shortest path search> ::=\nANY SHORTEST [ <path mode> ] [ <path or paths> ]\n<counted shortest path search> ::=\n222\nIWD 39075:2023(E)\n16.9 <path pattern prefix>"
  },
  {
    "page": 237,
    "text": "SHORTEST <number of paths> [ <path mode> ] [ <path or paths> ]\n<counted shortest group search> ::=\nSHORTEST [ <number of groups> ] [ <path mode> ] [ <path or paths> ] { GROUP | GROUPS }\n<number of groups> ::=\n<unsigned integer specification>\n** Editor’s Note (number 31) **\nThis differs from the SQL/PGQ definition of <number of groups>.\n** Editor’s Note (number 32) **\nIn addition to SHORTEST GROUP, it has been proposed to support SHORTEST [ k ] WITH TIES, with the semantics\nto return the first k matches (where k defaults to 1) when sorting matches in ascending order on number of edges,\nand also return every match that has the same number of edges as the last of the k matches. This is the semantics\nof WITH TIES in Subclause 7.17, “<query expression>” in SQL/Foundation. See Language Opportunity GQL-053 .\nSyntax Rules\n1)\nIf a <parenthesized path pattern expression> does not specify a <path mode prefix>, then WALK\nPATHS is implicit.\n2)\nIf a <path pattern prefix> PPP does not specify <all path search>, then:\na)\nCase:\ni)\nIf PPP does not simply contain a <path mode>, then let PM be WALK.\nii)\nOtherwise, let PM be the <path mode> simply contained in PPP.\nb)\nCase:\ni)\nIf PPP does not simply contain a <number of paths> or <number of groups>, then let\nN be an <unsigned integer> whose value is 1 (one).\nii)\nOtherwise, let N be the <number of paths> or <number of groups> simply contained\nin PPP. The declared type of N shall be exact numeric with scale 0 (zero). If N is a <lit-\neral>, then the value of N shall be positive.\nc)\nCase:\ni)\nIf PPP is an <any path search>, then PPP is equivalent to:\nANY N PM PATHS\nii)\nIf PPP is a <shortest path search>, then\nCase:\n1)\nIf PPP is <all shortest path search>, then PPP is equivalent to:\nSHORTEST 1 PM GROUP\n2)\nIf PPP is <any shortest path search>, then PPP is equivalent to:\nSHORTEST 1 PM PATH\n3)\nIf PPP is <counted shortest path search>, then PPP is equivalent to:\n223\nIWD 39075:2023(E)\n16.9 <path pattern prefix>"
  },
  {
    "page": 238,
    "text": "SHORTEST N PM PATHS\n4)\nIf PPP is <counted shortest group search>, then PPP is equivalent to:\nSHORTEST N PM GROUPS\n3)\nA<pathpatternprefix>thatspecifiesa<pathmode>otherthanWALKisrestrictive.A<parenthesized\npath pattern expression> that immediately contains a restrictive <path mode prefix> is restrictive.\n4)\nA <path search prefix> other than <all path search> is selective. A <path pattern> that simply contains\na selective <path search prefix> is selective.\n5)\nLet PPPE be a selective <path pattern>.\na)\nAn element variable exposed by PPPE is an interior variable of PPPE.\nb)\nA node variable LVV is the left boundary variable of PPPE if all of the following conditions are\ntrue:\ni)\nPPPE exposes LVV as an unconditional singleton variable.\nii)\nLVV is declared in the first explicit or implicit <node pattern> LVP contained in PPPE.\niii)\nLVP is not contained in a <path pattern union> or <path multiset alternation> that is\ncontained in PPPE.\nc)\nA node variable RVV is the right boundary variable of PPPE if all of the following conditions\nare true:\ni)\nPPPE exposes RVV as an unconditional singleton variable.\nii)\nRVV is declared in the last explicit or implicit <node pattern> RVP contained in PPPE.\niii)\nRVP is not contained in a <path pattern union> or <path multiset alternation> that is\ncontained in PPPE.\n** Editor’s Note (number 33) **\nWith more work, it is possible to recognize when a node variable is declared uniformly in the\nfirst or the last position in every operand of a <path pattern union>. However, WG3:W04-\n009R1 declined to make the effort because it is easy for the user to factor out such a node\npattern. For example, instead of\n(X) -> (Y) | (X) -> (Z)\nthe user can write\n(X) ( -> (Y) | -> (Z))\nThus a more general definition of right or left boundary variable is possible. See Language\nOpportunity GQL-056 .\nd)\nAn element variable that is exposed by PPPE that is neither a left boundary variable of PPPE\nnor a right boundary variable of PPPE is a strict interior variable of PPPE.\n6)\nAn element variable that is not declared in a selective <path pattern> is an exterior variable.\n« Editorial »\n7)\nA strict interior variable of one selective <path pattern> shall not be equivalent to an exterior\nvariable, or to an interior variable of another selective <path pattern>.\n« WG3:CMN-019 P00-ISO-031 »\n224\nIWD 39075:2023(E)\n16.9 <path pattern prefix>"
  },
  {
    "page": 239,
    "text": "NOTE 176 — This does not prohibit implicit joins of boundary variables of selective <path pattern>s\nwith exterior variables or boundary variables of other selective <path pattern>s.\n8)\nA selective <path pattern> SPP shall not contain a reference to a graph pattern variable that is not\ndeclared by SPP.\nNOTE 177 — This rule, and the prohibition of implicit joins to exterior variables and interior variables\nof other selective <path pattern>s, insure that each selective <path pattern> can be evaluated in isolation\nfrom any other <path pattern>.\nGeneral Rules\nNone.\nNOTE 178 — Restrictive <path mode>s are enforced as part of the check for consistent path bindings in the\ngeneration of the set of local matches in Subclause 16.10, “<path pattern expression>”. Selective <path pattern>s\nare evaluated by Subclause 22.4, “Evaluation of a selective <path pattern>”.\nConformance Rules\n1)\nWithout Feature G010, “Explicit WALK keyword”, conforming GQL language shall not contain a\n<path mode> that specifies WALK.\n2)\nWithout Feature G011, “Advanced path modes: TRAIL”, conforming GQL language shall not contain\na <path mode> that specifies TRAIL.\n3)\nWithout Feature G012, “Advanced path modes: SIMPLE”, conforming GQL language shall not contain\na <path mode> that specifies SIMPLE.\n4)\nWithoutFeature G013,“Advancedpath modes:ACYCLIC”, conformingGQLlanguage shallnot contain\na <path mode> that specifies ACYCLIC.\n5)\nWithout Feature G014, “Explicit PATH/PATHS keywords”, conforming GQL language shall not\ncontain a <path or paths>.\n6)\nWithout Feature G015, “All path search: explicit ALL keyword”, conforming GQL language shall not\ncontain an <all path search>.\n7)\nWithout Feature G016, “Any path search”, conforming GQL language shall not contain an <any path\nsearch>.\n8)\nWithout Feature G017, “All shortest path search”, conforming GQL language shall not contain an\n<all shortest path search>.\n9)\nWithout Feature G018, “Any shortest path search”, conforming GQL language shall not contain an\n<any shortest path search>.\n10)\nWithout Feature G019, “Counted shortest path search”, conforming GQL language shall not contain\na <counted shortest path search>.\n11)\nWithout Feature G020, “Counted shortest group search”, conforming GQL language shall not contain\na <counted shortest group search>.\n225\nIWD 39075:2023(E)\n16.9 <path pattern prefix>"
  },
  {
    "page": 240,
    "text": "16.10 <path pattern expression>\nFunction\nSpecify a pattern to match a single path in a property graph.\nFormat\n<path pattern expression> ::=\n<path term>\n| <path multiset alternation>\n| <path pattern union>\n<path multiset alternation> ::=\n<path term> <multiset alternation operator> <path term>\n    [ { <multiset alternation operator> <path term> }... ]\n<path pattern union> ::=\n<path term> <vertical bar> <path term> [ { <vertical bar> <path term> }... ]\n<path term> ::=\n<path factor>\n| <path concatenation>\n<path concatenation> ::=\n<path term> <path factor>\n<path factor> ::=\n<path primary>\n| <quantified path primary>\n| <questioned path primary>\n<quantified path primary> ::=\n<path primary> <graph pattern quantifier>\n<questioned path primary> ::=\n<path primary> <question mark>\nNOTE 179 — Unlike most regular expression languages, <question mark> is not equivalent to the quantifier\n{0,1}: the quantifier {0,1} exposes variables as group, whereas <question mark> does not change the singleton\nvariables that it exposes to group. However, <question mark> does expose any singleton variables as conditional\nsingletons.\n<path primary> ::=\n<element pattern>\n| <parenthesized path pattern expression>\n| <simplified path pattern expression>\n<element pattern> ::=\n<node pattern>\n| <edge pattern>\n<node pattern> ::=\n<left paren> <element pattern filler> <right paren>\n<element pattern filler> ::=\n[ <element variable declaration> ]\n[ <is label expression> ]\n[ <element pattern predicate> ]\n<element variable declaration> ::=\n226\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 241,
    "text": "[ TEMP ] <element variable>\n<is label expression> ::=\n<is or colon> <label expression>\n<is or colon> ::=\nIS\n| <colon>\n<element pattern predicate> ::=\n<element pattern where clause>\n| <element property specification>\n<element pattern where clause> ::=\nWHERE <search condition>\n<element property specification> ::=\n<left brace> <property key value pair list> <right brace>\n<property key value pair list> ::=\n<property key value pair> [ { <comma> <property key value pair> }... ]\n<property key value pair> ::=\n<property name> <colon> <value expression>\n<edge pattern> ::=\n<full edge pattern>\n| <abbreviated edge pattern>\n<full edge pattern> ::=\n<full edge pointing left>\n| <full edge undirected>\n| <full edge pointing right>\n| <full edge left or undirected>\n| <full edge undirected or right>\n| <full edge left or right>\n| <full edge any direction>\n<full edge pointing left> ::=\n<left arrow bracket> <element pattern filler> <right bracket minus>\n<full edge undirected> ::=\n<tilde left bracket> <element pattern filler> <right bracket tilde>\n<full edge pointing right> ::=\n<minus left bracket> <element pattern filler> <bracket right arrow>\n<full edge left or undirected> ::=\n<left arrow tilde bracket> <element pattern filler> <right bracket tilde>\n<full edge undirected or right> ::=\n<tilde left bracket> <element pattern filler> <bracket tilde right arrow>\n<full edge left or right> ::=\n<left arrow bracket> <element pattern filler> <bracket right arrow>\n<full edge any direction> ::=\n<minus left bracket> <element pattern filler> <right bracket minus>\n** Editor’s Note (number 34) **\nIn the BNF for <full edge any direction>, the delimiter tokens <~[ ]~> have been suggested as a synonym for -[ ]-\nas part of Feature GH03, “Undirected edge patterns”. The synonym for the <abbreviated edge pattern> - (<minus\nsign>) would then be <~>, the synonym for <simplified defaulting any direction> would use the delimiter tokens\n227\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 242,
    "text": "<~/ /~> and the synonym for <simplified override any direction> would use the tokens <~ and > surrounding a\nlabel as originally proposed in WG3:MMX-060. These synonyms might be considered to make the table of edge\npatterns more harmonious and internally consistent. See Language Opportunity GQL-212 .\n<abbreviated edge pattern> ::=\n<left arrow>\n| <tilde>\n| <right arrow>\n| <left arrow tilde>\n| <tilde right arrow>\n| <left minus right>\n| <minus sign>\n<parenthesized path pattern expression> ::=\n<left paren>\n    [ <subpath variable declaration> ]\n    [ <path mode prefix> ]\n<path pattern expression>\n    [ <parenthesized path pattern where clause> ]\n<right paren>\n<subpath variable declaration> ::=\n<subpath variable> <equals operator>\n<parenthesized path pattern where clause> ::=\nWHERE <search condition>\nSyntax Rules\n1)\nLet RIGHTMINUS be the following collection of <token>s: <right bracket minus>, <left arrow>, <slash\nminus>, and <minus sign>.\nNOTE 180 — These are the tokens ]-, <-, /-, and -, which expose a minus sign on the right.\n2)\nLet LEFTMINUS be the following collection of <token>s: <minus left bracket>, <right arrow>, <minus\nslash>, and <minus sign>.\nNOTE 181 — These are the tokens -[, ->, -/, and -, which expose a minus sign on the left. <minus sign>\nitself is in both RIGHTMINUS and LEFTMINUS.\n3)\nA <path pattern expression> shall not juxtapose a <token> from RIGHTMINUS followed by a <token>\nfrom LEFTMINUS without a <separator> between them.\nNOTE 182 — Otherwise, the concatenation of the two tokens would include the sequence of two <minus\nsign>s, which is a <simple comment introducer>.\n4)\nA <path pattern expression> that contains at the same depth of graph pattern matching a variable\nquantifier, a <questioned path primary>, a <path multiset alternation>, or a <path pattern union>\nis a possibly variable length path pattern.\n5)\nA <path pattern expression> that is not a possibly variable length path pattern is a fixed length path\npattern.\n6)\nThe minimum path length of certain BNF non-terminals defined in this Subclause is defined\nrecursively as follows:\na)\nThe minimum path length of a <node pattern> is 0 (zero).\nb)\nThe minimum path length of an <edge pattern> is 1 (one).\n228\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 243,
    "text": "c)\nThe minimum path length of a <path concatenation> is the sum of the minimum path lengths\nof its operands.\nd)\nThe minimum path length of a <path pattern union> or <path multiset alternation> is the\nminimum of the minimum path length of its operands.\ne)\nThe minimum path length of a <quantified path primary> is the product of the minimum path\nlength of the simply contained <path primary> and the value of the <lower bound>.\nf)\nThe minimum path length of a <questioned path primary> is 0 (zero).\ng)\nThe minimum path length of a <parenthesized path pattern expression> is the minimum path\nlength of the simply contained <path pattern expression>.\nh)\nIf BNT1 and BNT2 are two BNF non-terminals such that BNT1 ::= BNT2 and the minimum path\nlength of BNT2 is defined, then the minimum path length of BNT1 is also defined and is the\nsame as the minimum path length of BNT2.\n7)\nThe <path primary> immediately contained in a <quantified path primary> or <questioned path\nprimary> shall have minimum path length that is greater than 0 (zero).\n8)\nThe <path primary> simply contained in a <quantified path primary> shall not contain a <quantified\npath primary> at the same depth of graph pattern matching.\n** Editor’s Note (number 35) **\nIt may be possible to permit nested quantifiers. WG3:W01-014 contained a discussion of a way to support\naggregates at different depths of aggregation if there are nested quantifiers. See Language Opportunity\nGQL-036 .\n9)\nLet PMA be a <path multiset alternation>.\na)\nA <path term> simply contained in PMA is a multiset alternation operand of PMA.\nb)\nLet NOPMA be the number of multiset alternation operands of PMA. Let OPMA1, ..., OPMANOPMA\nbe an enumeration of the operands of PMA.\nc)\nAny <subpath variable>s declared by <subpath variable declaration>s simply contained in\nthe multiset alternation operands of PMA shall be mutually distinct.\nd)\nLet SOPMA1, ..., SOPMANOPMA be implementation-dependent (UV008) <identifier>s that are\nmutually distinct and distinct from every <element variable>, <subpath variable> and <path\nvariable> contained in GP.\n« WG3:CMN-019 P00-NLD-050 »\ne)\nFor i, 1 (one) ≤i ≤NOPMA,\nCase:\ni)\nIf OPMAi is a <parenthesized path pattern expression> that simply contains a <subpath\nvariable declaration>, then let OPMAXi be OPMAi.\nii)\nOtherwise, let OPMAXi be the <parenthesized path pattern expression>\n(SOPMAi = OPMAi)\nf)\nPMA is equivalent to:\nOPMAX1 | ... | OPMAXNOPMA\n229\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 244,
    "text": "10)\nA <path term> PPUOP simply contained in a <path pattern union> PSD is a path pattern union\noperand of PSD.\n** Editor’s Note (number 36) **\nPath pattern union is not defined using left recursion. WG3:SXM-052 believed that it should be possible to\nsupport left recursion but declined to do so for expediency. It is a Language Opportunity to support left\nrecursion. See Language Opportunity GQL-025 .\nPPUOP shall not contain a reference to an element variable that is not declared in PPUOP or outside\nof PSD.\n11)\nAn <element pattern> EP that contains an <element pattern where clause> EPWC is transformed\nas follows:\na)\nLet EPF be the <element pattern filler> simply contained in EP.\nb)\nLet PREFIX be the <delimiter token> contained in EP before EPF and let SUFFIX be the\n<delimiter token> contained in EP after EPF.\n« WG3:CMN-019 P00-USA-097 »\nc)\nLet EV be the <element variable> simply contained in EPF.\nd)\nLet ILE be defined as follows: If EPF simply contains the <is label expression> ILE_CAND, then\nILE is ILE_CAND; otherwise, ILE is the zero-length character string.\ne)\nEP is replaced by\n( PREFIX EV ILE SUFFIX EPWC )\n12)\nAn <element pattern> that does not contain an <element variable declaration>, an <is label\nexpression>, or an <element pattern predicate> is said to be empty.\n13)\nEach <path pattern expression> is transformed in the following steps:\na)\nIf the <path primary> immediately contained in a <quantified path primary> or <questioned\npath primary> is an <edge pattern> EP, then EP is replaced by\n( EP )\nNOTE 183 — For example,\n->*\nbecomes:\n(->) {0,}\nwhich in later transformations becomes:\n(() -> ()) {0,}\nb)\nIf two successive <element pattern>s contained in a <path concatenation> at the same depth\nof graph pattern matching are <edge pattern>s, then an implicit empty <node pattern> is\ninserted between them.\nc)\nIf an edge pattern EP contained in a <path term> PST at the same depth of graph pattern\nmatching is not preceded by a <node pattern> contained in PST at the same depth of graph\npattern matching, then an implicit empty <node pattern> VP is inserted in PST immediately\nprior to EP.\nd)\nIf an edge pattern EP contained in a <path term> PST at the same depth of graph pattern\nmatching is not followed by a <node pattern> contained in PST at the same depth of graph\n230\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 245,
    "text": "pattern matching, than an implicit empty <node pattern> VP is inserted in PST immediately\nafter EP.\nNOTE 184 — As a result of the preceding transformations, a fixed length path pattern has an odd\nnumberof<elementpattern>s,beginningandendingwith<nodepattern>s,andalternatingbetween\n<node pattern>s and <edge pattern>s.\ne)\nEvery<abbreviatededgepattern>AEP isreplacedwithan empty<fulledgepattern>asfollows.\nCase:\ni)\nIf AEP is <left arrow>, then AEP is replaced by the <full edge pointing left>:\n<-[ ]-\nii)\nIf AEP is <tilde>, then AEP is replaced by the <full edge undirected>:\n~[ ]~\niii)\nIf AEP is <right arrow>, then AEP is replaced by the <full edge pointing right>:\n-[ ]->\niv)\nIf AEP is <left arrow tilde>, then AEP is replaced by the <full edge left or undirected>:\n<~[ ]~\nv)\nIf AEP is <tilde right arrow>, then AEP is replaced by the <full edge undirected or right>:\n~[ ]~>\nvi)\nIf AEP is <left minus right>, then AEP is replaced by the <full edge left or right>:\n<-[ ]->\nvii)\nIf AEP is <minus sign>, then AEP is replaced by the <full edge any direction>:\n-[ ]-\n14)\nTheminimumnodecountofcertainBNFnon-terminalsdefinedinthisSubclauseisdefinedrecursively\nas follows:\na)\nThe minimum node count of a <node pattern> is 1 (one).\nb)\nThe minimum node count of an <edge pattern> is 0 (zero).\nc)\nThe minimum node count of a <path concatenation> PC is:\nCase:\ni)\nIf two successive <elementpattern>s containedin PC at the same depth of graph pattern\nmatching are <node pattern>s, then 1 (one) less than the sum of the minimum node\ncounts of its operands.\nii)\nOtherwise, the sum of the minimum node counts of its operands.\nd)\nThe minimum node count of a <path pattern union> or <path multiset alternation> is the\nminimum of the minimum node count of its operands.\ne)\nThe minimum node count of a <quantified path primary> is the product of the minimum node\ncount of the simply contained <path primary> and the value of the <lower bound> of the\nsimply contained <graph pattern quantifier>.\n231\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 246,
    "text": "f)\nThe minimum node count of a <questioned path primary> is 0 (zero).\ng)\nThe minimum node count of a <parenthesized path pattern expression> is the minimum node\ncount of the simply contained <path pattern expression>.\nh)\nIf BNF1 and BNF2 are two BNF non-terminals such that BNF1 ::= BNF2 and the minimum node\ncount of BNF2 is defined, then the minimum node count of BNF1 is also defined and is the\nsame as the minimum node count of BNF2.\n15)\nThe <path pattern expression> simply contained in a <path pattern> shall have a minimum node\ncount that is greater than 0 (zero).\nNOTE 185 — The minimum node count is computed after the syntactic transform that adds implicit node\npatterns. Thus a single <edge pattern> is a permitted <path pattern> because it implies two <node pat-\ntern>s.\nNOTE 186 — A later Syntax Rule makes the same requirement of a <parenthesized path pattern expres-\nsion> that simply contains a <subpath variable declaration>.\n16)\nAn <element variable> EV contained in an <element variable declaration> GPVD is said to be declared\nby GPVD, and by the <element pattern> EP that simply contains GPVD. The <element variable> is\nthe name of an element variable, which is also declared by GPVD and EP. If GPVD simply contains\nTEMP, then EV is a temporary element variable.\nNOTE 187 — Element bindings to temporary element variables are removed prior to set-theoretic\ndeduplication of matches. See GR 10) of Subclause 16.8, “<graph pattern>” and GR 14) of Subclause 22.2,\n“Machinery for graph pattern matching”.\n« WG3:CMN-019 P00-USA-007 »\n17)\nAn element variable that is declared by a <node pattern> is a node variable. An element variable\nthat is declared by an <edge pattern> is an edge variable.\n18)\nThe scope of an <element variable> EV that is declared by an <element pattern> EP is defined as\nfollows. If EV is a temporary element variable, then the scope of EV is the innermost <path term>\ncontaining EP; otherwise, the scope of EV is the innermost <graph pattern binding table> containing\nEP.\n« WG3:CMN-019 P00-USA-098 »\n19)\nIf PPPE simply contains a <subpath variable declaration>, then the minimum node count of PPPE\nshall be greater than 0 (zero).\n« WG3:CMN-019 P00-USA-099 »\n20)\nIf an <element pattern> EP that contains an <element pattern where clause> EPWC, then EP shall\nsimply contain an <element variable declaration> GPVD.\n21)\nIf EV is an element variable or subpath variable, and BNT is an instance of a BNF non-terminal, then\nthe terminology “BNT exposes EV” is defined as follows. The full terminology is one of the following:\n“BNT exposes EV as an unconditional singleton variable”, “BNT exposes EV as a conditional singleton\nvariable”, “BNT exposes EV as an effectively bounded group variable” or “BNT exposes EV as an\neffectively unbounded group variable”. The terms “unconditional singleton variable”, “conditional\nsingleton variable”, “effectively bounded group variable”, and “effectively unbounded group variable”\nare called the degree of exposure.\na)\nAn <element pattern> EP that declares an element variable EV exposes EV as an unconditional\nsingleton.\nb)\nA <parenthesized path pattern expression> PPPE that simply contains a <subpath variable\ndeclaration> that declares EV exposes EV as an unconditional singleton variable. PPPE shall\nnot contain another <parenthesized path pattern expression> that declares EV.\n232\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 247,
    "text": "c)\nIf a <path concatenation> PPC declares EV then let PT be the <path term> and let PF be the\n<path factor> simply contained in PPC.\nCase:\ni)\nIf EV is exposed as an unconditional singleton by both PT and PF, then EV is exposed\nas an unconditional singleton by PPC. EV shall not be a subpath variable.\nNOTE 188 — This case expresses an implicit join on EV within PPC. Implicit joins between\nconditional singleton variables, group variables, or subpath variables are forbidden.\nii)\nOtherwise, EV shall only be exposed by one of PT or PF. In this case EV is exposed by\nPPC in the same degree that it is exposed by PT or PF.\nd)\nIf a <path pattern union> or <path multiset alternation> PA declares EV, then\nCase:\ni)\nIf every operand of PA exposes EV as an unconditional singleton variable, then PA\nexposes EV as an unconditional singleton variable.\nii)\nIf at least one operand of PA exposes EV as an effectively unbounded group variable,\nthen PA exposes EV as an effectively unbounded group variable.\niii)\nIf at least one operand of PA exposes EV as an effectively bounded group variable, then\nPA exposes EV as an effectively bounded group variable.\niv)\nOtherwise, PA exposes EV as a conditional singleton variable.\ne)\nIf a <quantified path primary> QPP declares EV, then let PP be the <path primary> simply\ncontained in QPP.\nCase:\ni)\nIf QPP contains a <graph pattern quantifier> that is a <fixed quantifier> or a <general\nquantifier> that contains an <upper bound> and PP does not expose EV as an effectively\nunbounded group variable, then QPP exposes EV as an effectively bounded group\nvariable.\nii)\nIf QPP is contained at the same depth of graph pattern matching in a restrictive <par-\nenthesized path pattern expression>, then QPP exposes EV as an effectively bounded\ngroup variable.\nNOTE 189 — The preceding definitionis applied after the syntactic transformation to insure\nthat every <path mode prefix> is at the head of a <parenthesized path pattern expression>.\niii)\nOtherwise, QPP exposes EV as an effectively unbounded group variable.\nf)\nIf a <questioned path primary> QUPP declares EV, then let PP be the <path primary> simply\ncontained in QUPP.\nCase:\ni)\nIf PP exposes EV as a group variable, then QUPP exposes EV as a group variable with\nthe same degree of exposure.\nii)\nOtherwise, QUPP exposes EV as a conditional singleton variable.\ng)\nA <parenthesizedpath patternexpression>exposesthesamevariablesas thesimply contained\n<path pattern expression>, in the same degree of exposure.\nNOTE 190 — A restrictive <path mode> declared by a <parenthesized path pattern expression>\nmakes variables effectively bounded, but it does so even for proper subexpressions within the\nscopeofthe<pathmode>and hasalready beenhandledby therulesfor<quantifiedpath primary>.\n233\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 248,
    "text": "h)\nIf a <path pattern> PP declares EV, then let PPE be the simply contained <path pattern\nexpression>.\nCase:\ni)\nIf PPE exposes EV as an unconditionalsingleton, a conditionalsingleton, or an effectively\nbounded group variable, then PP exposes EV with the same degree of exposure.\nii)\nOtherwise, PP exposes EV as an effectively bounded group variable.\nNOTE 191 — That is, even if PPE exposes EV as an effectively unbounded group variable,\nPP still exposes EV as effectively bounded, because in this case PP is required to be a\nselective <path pattern>.\ni)\nIf BNT1 and BNT2 are two BNF non-terminals such that BNT1 ::= BNT2 and BNT2 exposes EV,\nthen BNT1 exposes EV to the same degree of exposure as BNT2.\n** Editor’s Note (number 37) **\nWG3:W04-009R1 defined “effectively bounded group variable” but did not use the definition. The\ndefinition will be used when we define predicates on aggregates, at which time we will want a Syntax\nRules stating that if a group variable GV is referenced in a WHERE clause, then it shall be effectively\nbounded and the reference shall be contained in an aggregated argument of an <aggregate function>.\n22)\nIf BNT is a BNF non-terminal that exposes a graph pattern variable GPV with a degree of exposure\nDEGREE, then BNT is also said to expose the name of GPV with degree of exposure DEGREE.\n23)\nA <parenthesized path pattern where clause> PPPWC simply contained in a <parenthesized path\npattern expression> PPPE shall not reference a path variable.\n** Editor’s Note (number 38) **\nWG3:W04-009R1 recognized that a graph query may have a sequence of MATCH clauses, with the bindings\nof one MATCH clause MC1 visible in all subsequent MATCH clauses in the same invocation of <graph table>,\nand that it should be permissible to reference such variables in any <parenthesized path pattern where\nclause> simply contained in a subsequent MATCH clause MC2. The relevance of this LO to GQL needs to be\ninvestigated. See Language Opportunity GQL-051 .\nGeneral Rules\nNone.\nNOTE 192 — The evaluation of a <path pattern expression> is performed by the General Rules of Subclause 22.3,\n“Evaluation of a <path pattern expression>”.\nConformance Rules\n1)\nConforming GQL language shall not contain an <element variable declaration> that immediately\ncontains TEMP.\nNOTE 193 — An <element variable declaration> containing TEMP is a specification device and is not\nsyntax available to the user.\n2)\nWithout Feature G030, “Path multiset alternation”, conforming GQL language shall not contain a\n<path multiset alternation>.\n3)\nWithout Feature G031, “Path multiset alternation: variable length path operands”, in conforming\nGQL language, an operand of a <path multiset alternation> shall be a fixed length path pattern.\n234\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 249,
    "text": "4)\nWithout Feature G032, “Path pattern union”, conforming GQL language shall not contain a <path\npattern union>.\n5)\nWithout Feature G033, “Path pattern union: variable length path operands”, in conforming GQL\nlanguage, an operand of a <path pattern union> shall be a fixed length path pattern.\n6)\nWithoutFeature G035,“Quantifiedpaths”, conformingGQLlanguage shallnot containa <quantified\npath primary> that does not immediately contain a <path primary> that is an <edge pattern>.\n7)\nWithout Feature G036, “Quantified edges”, conforming GQL language shall not contain a <quantified\npath primary> that immediately contains a <path primary> that is an <edge pattern>.\n8)\nWithoutFeatureG037,“Questionedpaths”,conformingGQLlanguageshallnotcontaina<questioned\npath primary>.\n9)\nWithout Feature G038, “Parenthesized path pattern expression”, conforming GQL language shall\nnot contain a <parenthesized path pattern expression>.\n10)\nWithout Feature G041, “Non-local element pattern predicates”, in conforming GQL language, the\n<element pattern where clause> of an <element pattern> EP shall only reference the <element\nvariable> declared in EP.\n11)\nWithout Feature G043, “Complete full edge patterns”, conforming GQL language shall not contain\na <full edge pattern> that is not a <full edge any direction>, a <full edge pointing left>, or a <full\nedge pointing right>.\n12)\nWithoutFeatureG044,“Basicabbreviatededgepatterns”,conformingGQLlanguageshallnotcontain\nan <abbreviated edge pattern> that is a <minus sign>, a <left arrow>, or a <right arrow>.\n13)\nWithout Feature G045, “Complete abbreviated edge patterns”, conforming GQL language shall not\ncontain an <abbreviated edge pattern> that is not a <minus sign>, a <left arrow>, or a <right arrow>.\n14)\nWithout Feature G046, “Relaxed topological consistency: adjacent vertex patterns”, in conforming\nGQL language, between any two <node pattern>s contained in a <path pattern expression> there\nshall be at least one <edge pattern>, <left paren>, or <right paren>.\n15)\nWithout Feature G047, “Relaxed topological consistency: concise edge patterns”, in conforming\nGQL language, an <edge pattern> shall be immediately preceded and followed by a <node pattern>.\n16)\nWithout Feature G048, “Parenthesized path pattern: subpath variable declaration”, conforming\nGQL language shall not contain a <parenthesized path pattern expression> that simply contains a\n<subpath variable declaration>.\n17)\nWithout Feature G049, “Parenthesized path pattern: path mode prefix”, conforming GQL language\nshall not contain a <parenthesized path pattern expression> that immediately contains a <path\nmode prefix>.\n18)\nWithout Feature G050, “Parenthesized path pattern: WHERE clause”, conforming GQL language\nshall not contain a <parenthesized path pattern where clause>.\n19)\nWithout Feature G051, “Parenthesized path pattern: non-local predicates”, in conforming GQL\nlanguage, a <parenthesized path pattern where clause> simply contained in a <parenthesized path\npattern expression> PPPE shall not reference an <element variable> that is not declared in PPPE.\n235\nIWD 39075:2023(E)\n16.10 <path pattern expression>"
  },
  {
    "page": 250,
    "text": "16.11 <insert graph pattern>\nFunction\nDefine an <insert graph pattern>.\nFormat\n<insert graph pattern> ::=\n<insert path pattern list>\n« Correct applicaton of OHD-012 »\n<insert path pattern list> ::=\n<insert path pattern> [ { <comma> <insert path pattern> }... ]\n<insert path pattern> ::=\n<insert node pattern> [ { <insert edge pattern> <insert node pattern> }... ]\n<insert node pattern> ::=\n<left paren> [ <insert element pattern filler> ] <right paren>\n<insert edge pattern> ::=\n<insert edge pointing left>\n| <insert edge pointing right>\n| <insert edge undirected>\n<insert edge pointing left> ::=\n<left arrow bracket> [ <insert element pattern filler> ] <right bracket minus>\n<insert edge pointing right> ::=\n<minus left bracket> [ <insert element pattern filler> ] <bracket right arrow>\n<insert edge undirected> ::=\n<tilde left bracket> [ <insert element pattern filler> ] <right bracket tilde>\n<insert element pattern filler> ::=\n<element variable declaration> [ <label and property set specification> ]\n| [ <element variable declaration> ] <label and property set specification>\n<label and property set specification> ::=\n<label set specification> [ <element property specification> ]\n| [ <label set specification> ] <element property specification>\n<label set specification> ::=\n<label name> [ { <ampersand> <label name> }... ]\nSyntax Rules\n1)\nLet IGP be the <insert graph pattern>.\n2)\nLet IDNSET be the empty set.\n3)\nFor every <insert element pattern filler> IEPF simply contained in IGP that does not immediately\ncontain an <element variable declaration>:\na)\nLet IDN be an implementation-dependent (UV011) name that is not equal to the name of the\n<element variable declaration> of any other <element pattern> in IGP, any column name in\nthe declared type of the incoming working table of IGP, any field name in the declared type of\nthe incoming working record of IGP, or any name of a catalog object in the GQL-catalog.\n236\nIWD 39075:2023(E)\n16.11 <insert graph pattern>"
  },
  {
    "page": 251,
    "text": "b)\nInclude IDN in IDNSET.\nc)\nIEPF is effectively replaced by:\nIDN IEPF\n4)\nThe implementation-assigned variable names of IGP are IDNSET.\n5)\nLet IS be the <insert statement> that immediately contains IGP.\n6)\nAn <element variable> EV contained in an <element variable declaration> EVD is said to be declared\nby EVD, and by the <insert node pattern> or <insert edge pattern> EP that simply contains EVD.\nThe <element variable> specifies the name of an element variable, which is also declared by EVD\nand EP.\n7)\nFor every <value expression> VE immediately contained in a <property key value pair> PKVP\nimmediately contained in an <element property specification> simply contained in IGP:\na)\nThe declared type of the incoming working record of VE is the declared type of the incoming\nworking record of IS amended with the record type of the declared type of the incoming\nworking table of IS.\nb)\nThe declared type of the incoming working table of VE is the material unit binding table type.\nc)\nThe declared type of VE shall be a supported property value type.\n8)\nAn insert element pattern is either an <insert node pattern> or an <insert edge pattern> that is\nsimply contained in IGP.\n9)\nA bound insert element pattern is an insert element pattern IEP that declares an <element variable>\nEV whose name is either the name of a column C of the declared type of the incoming working table\nof IS or is the name of a field F of the declared type of the incoming working record of IS. The declared\ntype of IEP is the column type of C or the field value type of F.\n10)\nNo <property key value pair list> simply contained in a bound insert element pattern shall simply\ncontain two equivalent <property name>s that are each immediately contained in a different\n<property key value pair>.\n11)\nFor every <element variable> EV simply contained in IGP:\na)\nFor every bound insert element pattern EP that declares EV:\n« WG3:CMN-019 P00-USA-102 »\ni)\nEP shall be an <insert node pattern>.\nii)\nThe declared type of EP shall be a node reference value type.\niii)\nEP shall not simply contain a <label and property set specification>.\nb)\nThe defining insert element pattern of EV is the first insert element pattern that declares EV.\nEvery insert element pattern that declares EV and is not the defining insert element pattern\nof EV shall not simply contain a <label and property set specification>.\n12)\nIf an <insert edge pattern> EP1 declares an <element variable> EV1, then there shall not be an\n<insert node pattern> or <insert edge pattern> EP2 that declares an <element variable> EV2 equi-\nvalent to EV1.\nNOTE 194 — This rule has two consequences.\n—\nIf an <insert node pattern> declares an <element variable> EV, then there is not an <insert edge\npattern> that declares an <element variable> with the same name as EV.\n237\nIWD 39075:2023(E)\n16.11 <insert graph pattern>"
  },
  {
    "page": 252,
    "text": "—\nEvery <insertedge pattern> is the defininginsertelement pattern of the element variable it declares.\nGeneral Rules\nNone.\nConformance Rules\nNone.\n238\nIWD 39075:2023(E)\n16.11 <insert graph pattern>"
  },
  {
    "page": 253,
    "text": "16.12 <label expression>\nFunction\nSpecify an expression that matches one or more labels of a graph.\nFormat\n<label expression> ::=\n<label term>\n| <label disjunction>\n<label disjunction> ::=\n<label expression> <vertical bar> <label term>\n<label term> ::=\n<label factor>\n| <label conjunction>\n<label conjunction> ::=\n<label term> <ampersand> <label factor>\n<label factor> ::=\n<label primary>\n| <label negation>\n<label negation> ::=\n<exclamation mark> <label primary>\n<label primary> ::=\n<label name>\n| <wildcard label>\n| <parenthesized label expression>\n<wildcard label> ::=\n<percent>\n<parenthesized label expression> ::=\n<left paren> <label expression> <right paren>\nSyntax Rules\n1)\nLet LE be the <label expression> and let GP be the <graph pattern> that simply contains LE.\n2)\nLet PG be the current working graph available at LE.\nNOTE 195 — If no current working graph is available at LE, then this rule cannot be satisfied. See\nSubclause 4.7.3, “Working objects”.\n3)\nEvery <label name> contained in LE shall identify a label of PG.\n4)\nCase:\na)\nIf LE is simply contained in a <node pattern>, then LE is a node <label expression>. Every <label\nname> contained in LE shall identify a node label of PG.\nb)\nOtherwise, LE is an edge <label expression>. Every <label name> contained in LE shall identify\nan edge label of PG.\n239\nIWD 39075:2023(E)\n16.12 <label expression>"
  },
  {
    "page": 254,
    "text": "General Rules\nNone.\nConformance Rules\n1)\nWithout Feature G074, “Label expression: wildcard label”, conforming GQL language shall not\ncontain a <wildcard label>.\n240\nIWD 39075:2023(E)\n16.12 <label expression>"
  },
  {
    "page": 255,
    "text": "16.13 <graph pattern quantifier>\nFunction\nSpecify a graph pattern quantifier.\nFormat\n<graph pattern quantifier> ::=\n<asterisk>\n| <plus sign>\n| <fixed quantifier>\n| <general quantifier>\n<fixed quantifier> ::=\n<left brace> <unsigned integer> <right brace>\n<general quantifier> ::=\n<left brace> [ <lower bound> ] <comma> [ <upper bound> ] <right brace>\n<lower bound> ::=\n<unsigned integer>\n<upper bound> ::=\n<unsigned integer>\nSyntax Rules\n1)\nThe maximum value of <upper bound> is implementation-defined (IL018). <upper bound>, if spe-\ncified, shall not be greater than this value.\n2)\nEvery <graph pattern quantifier> is normalized, as follows:\na)\n<asterisk> is equivalent to:\n{0,}\nb)\n<plus sign> is equivalent to:\n{1,}\nc)\nIf <fixed quantifier> FQ is specified, then let UI be the <unsigned integer> contained in FQ. FQ\nis equivalent to:\n{UI,UI}\nd)\nIf<general quantifier>GQisspecified,andif<lowerbound>isnotspecified,thenthe<unsigned\ninteger> 0 (zero) is supplied as the <lower bound>.\n3)\nIf <general quantifier> GQ is specified or implied by the preceding normalizations, then\nCase:\na)\nIf <upper bound> is specified, then:\ni)\nThe value of <upper bound> VUP shall be greater than 0 (zero).\nii)\nThe value of <lower bound> LUP shall be less than or equal to VUP.\n241\nIWD 39075:2023(E)\n16.13 <graph pattern quantifier>"
  },
  {
    "page": 256,
    "text": "iii)\nIf LUP equals VUP, then GQ is a fixed quantifier.\niv)\nGQ is a bounded quantifier.\nb)\nOtherwise, GQ is an unbounded quantifier.\n4)\nA <graph pattern quantifier> that is not a fixed quantifier is a variable quantifier.\nGeneral Rules\nNone.\nConformance Rules\n1)\nWithout Feature G060, “Bounded graph pattern quantifiers”, conforming GQL language shall not\ncontain a <fixed quantifier> or a <general quantifier> that immediately contains an <upper bound>.\n2)\nWithout Feature G061, “Unbounded graph pattern quantifiers”, conforming GQL language shall not\ncontain a <graph pattern quantifier> that immediately contains an <asterisk>, a <plus sign>, or a\n<general quantifier> that does not immediately contain an <upper bound>.\n242\nIWD 39075:2023(E)\n16.13 <graph pattern quantifier>"
  },
  {
    "page": 257,
    "text": "16.14 <simplified path pattern expression>\nFunction\nExpress a path pattern as a regular expression of edge labels.\nFormat\n<simplified path pattern expression> ::=\n<simplified defaulting left>\n| <simplified defaulting undirected>\n| <simplified defaulting right>\n| <simplified defaulting left or undirected>\n| <simplified defaulting undirected or right>\n| <simplified defaulting left or right>\n| <simplified defaulting any direction>\n<simplified defaulting left> ::=\n<left minus slash> <simplified contents> <slash minus>\n<simplified defaulting undirected> ::=\n<tilde slash> <simplified contents> <slash tilde>\n<simplified defaulting right> ::=\n<minus slash> <simplified contents> <slash minus right>\n<simplified defaulting left or undirected> ::=\n<left tilde slash> <simplified contents> <slash tilde>\n<simplified defaulting undirected or right> ::=\n<tilde slash> <simplified contents> <slash tilde right>\n<simplified defaulting left or right> ::=\n<left minus slash> <simplified contents> <slash minus right>\n<simplified defaulting any direction> ::=\n<minus slash> <simplified contents> <slash minus>\n<simplified contents> ::=\n<simplified term>\n| <simplified path union>\n| <simplified multiset alternation>\n<simplified path union> ::=\n<simplified term> <vertical bar> <simplified term>\n    [ { <vertical bar> <simplified term> }... ]\n<simplified multiset alternation> ::=\n<simplified term> <multiset alternation operator> <simplified term>\n    [ { <multiset alternation operator> <simplified term> }... ]\n<simplified term> ::=\n<simplified factor low>\n| <simplified concatenation>\n<simplified concatenation> ::=\n<simplified term> <simplified factor low>\n<simplified factor low> ::=\n<simplified factor high>\n| <simplified conjunction>\n243\nIWD 39075:2023(E)\n16.14 <simplified path pattern expression>"
  },
  {
    "page": 258,
    "text": "<simplified conjunction> ::=\n<simplified factor low> <ampersand> <simplified factor high>\n<simplified factor high> ::=\n<simplified tertiary>\n| <simplified quantified>\n| <simplified questioned>\n<simplified quantified> ::=\n<simplified tertiary> <graph pattern quantifier>\n<simplified questioned> ::=\n<simplified tertiary> <question mark>\n<simplified tertiary> ::=\n<simplified direction override>\n| <simplified secondary>\n<simplified direction override> ::=\n<simplified override left>\n| <simplified override undirected>\n| <simplified override right>\n| <simplified override left or undirected>\n| <simplified override undirected or right>\n| <simplified override left or right>\n| <simplified override any direction>\n<simplified override left> ::=\n<left angle bracket> <simplified secondary>\n<simplified override undirected> ::=\n<tilde> <simplified secondary>\n<simplified override right> ::=\n<simplified secondary> <right angle bracket>\n<simplified override left or undirected> ::=\n<left arrow tilde> <simplified secondary>\n<simplified override undirected or right> ::=\n<tilde> <simplified secondary> <right angle bracket>\n<simplified override left or right> ::=\n<left angle bracket> <simplified secondary> <right angle bracket>\n<simplified override any direction> ::=\n<minus sign> <simplified secondary>\n<simplified secondary> ::=\n<simplified primary>\n| <simplified negation>\n<simplified negation> ::=\n<exclamation mark> <simplified primary>\n<simplified primary> ::=\n<label name>\n| <left paren> <simplified contents> <right paren>\n** Editor’s Note (number 39) **\nIt has been proposed that a macro name may be a <simplified primary> in a <simplified path pattern expression>.\nSee Language Opportunity GQL-034 .\n244\nIWD 39075:2023(E)\n16.14 <simplified path pattern expression>"
  },
  {
    "page": 259,
    "text": "Syntax Rules\n1)\nA <simplified negation> shall not contain a <simplified concatenation>, <simplified quantified>,\n<simplified questioned>, or <simplified multiset alternation>.\n2)\nA <simplified direction override> shall not contain another <simplified direction override>.\n3)\nA <simplified direction override> shall not contain <simplified concatenation>, <simplified quanti-\nfied>, <simplified questioned>, or <simplified multiset alternation>.\n4)\nA <simplified conjunction> shall not contain a <simplified concatenation>, <simplified quantified>,\n<simplified questioned>, or <simplified multiset alternation>.\n5)\nA <simplified path pattern expression> SPPE is replaced by:\n( SPPE )\nNOTE 196 — This is done once for each <simplified path pattern expression> prior to the following\nrecursive transformation and not with each iteration of the transformation.\n6)\nThe following rules are recursively applied until no <simplified path pattern expression>s remain.\nNOTE 197 — The rules work from the root of the parse tree of a <simplified path pattern expression>.\nAt each step, the coarsest analysis of a <simplified path pattern expression> is replaced, eliminating at\nleast one level of the parse tree, measured from the root. Note that each replacement can create more\n<simplified path pattern expression>s than before, but these replacements have less depth. Eventually\nthe recursion replaces <simplified path pattern expression> with <edge pattern>.\na)\nLet SPPE be a <simplified path pattern expression>.\ni)\nLet SC be the <simplified contents> contained in SPPE.\nii)\nLet PREFIX be the <minus slash>, <left minus slash>, <tilde slash>, <left tilde slash>,\nor <left minus slash> contained in SPPE.\niii)\nLet SUFFIX be the <slash minus right>, <slash minus>, <slash tilde>, or <slash tilde\nright> contained in SPPE.\niv)\nLet EDGEPRE and EDGESUF be determined by Table 3, “Conversion of simplified syntax\ndelimiters to default edge delimiters”, from the row containing the values of PREFIX\nand SUFFIX.\nTable 3 — Conversion of simplified syntax delimiters to default\nedge delimiters\nEDGESUF\nEDGEPRE\nSUFFIX\nPREFIX\n]->\n-[\n/->\n-/\n]-\n<-[\n/-\n<-/\n]~\n~[\n/~\n~/\n]~>\n~[\n/~>\n~/\n]~\n<~[\n/~\n<~/\n]->\n<-[\n/->\n<-/\n]-\n-[\n/-\n-/\n245\nIWD 39075:2023(E)\n16.14 <simplified path pattern expression>"
  },
  {
    "page": 260,
    "text": "b)\nCase:\ni)\nIf SC is a <simplified path union> SPU, then let N be the number of <simplified term>s\nsimply contained in SPU, and let ST1, ..., STN be those <simplified term>s; SPPE is\nreplaced by:\nPREFIX ST1 SUFFIX | PREFIX ST2 SUFFIX | ... | PREFIX STN SUFFIX\nii)\nIf SC is a <simplified multiset alternation> SMA, then let N be the number of <simplified\nterm>s simply contained in SMA, and let ST1, ..., STN be those <simplified term>s; SPPE\nis replaced by:\nPREFIX ST1 SUFFIX |+| PREFIX ST2 SUFFIX |+| ... |+| PREFIX STN SUFFIX\niii)\nIf SC is a <simplified concatenation> SCAT, then let ST be the <simplified term> and let\nSFL be the <simplified factor low> simply contained in SCAT; SPPE is replaced by:\nPREFIX ST SUFFIX PREFIX SFL SUFFIX\niv)\nIf SC is a <simplified conjunction> SAND, then SPPE is replaced by:\nEDGEPRE IS SAND EDGESUF\nNOTE 198 — As a result, SAND is now interpreted as a <label expression> within an <edge\npattern>. By earlier Syntax Rules, there are no operators allowed in SAND that cannot be\ninterpreted as operators of a <label expression>.\nv)\nIf SC is a <simplified quantified> SQ, then let ST be the <simplified tertiary> simply\ncontained in SC and let GPQ be the <graph pattern quantifier> simply contained in SQ;\nSPPE is replaced by:\n( PREFIX ST SUFFIX ) GPQ\nvi)\nIf SC is a <simplified questioned> SQU, then let ST be the <simplified tertiary> simply\ncontained in SC; SPPE is replaced by:\n( PREFIX ST SUFFIX ) ?\nvii)\nIf SC is a <simplified direction override> SDO, then let SS be the <simplified secondary>\nsimply contained in SDO.\nCase:\nNOTE 199 — As a result of the following replacements, SDO is now interpreted as a <label\nexpression> within an <edge pattern>. By earlier Syntax Rules, there are no operators\nallowed in SDO that cannot be interpreted as operators of a <label expression>.\n1)\nIf SDO is <simplified override left>, then SPPE is replaced by:\n<-[ IS SS ]-\n2)\nIf SDO is <simplified override undirected>, then SPPE is replaced by:\n~[ IS SS ]~\n3)\nIf SDO is <simplified override left or undirected>, then SPPE is replaced by:\n<~[ IS SS ]~\n4)\nIf SDO is <simplified override undirected or right>, then SPPE is replaced by:\n246\nIWD 39075:2023(E)\n16.14 <simplified path pattern expression>"
  },
  {
    "page": 261,
    "text": "~[ IS SS ]~>\n5)\nIf SDO is <simplified override left or right>, then SPPE is replaced by:\n<-[ IS SS ]->\n6)\nIf SDO is <simplified override any direction>, then SPPE is replaced by:\n-[ IS SS ]-\nviii)\nIf SC is a <simplified negation> SN, then SPPE is replaced by:\nEDGEPRE IS SN EDGESUF\nNOTE 200 — As a result, SN is now interpreted as a <label expression> within an <edge\npattern>. By earlier Syntax Rules, there are no operators allowed in SN that cannot be\ninterpreted as operators of a <label expression>.\nix)\nIf SC is a <simplified primary> SP, then\nCase:\n1)\nIf SP is a <label name>, then SPPE is replaced by:\nEDGEPRE IS SP EDGESUF\n2)\nOtherwise, let INNER be the <simplified contents> simply contained in SC; SPPE\nis replaced by:\n( PREFIX INNER SUFFIX )\n7)\nThe Conformance Rules of Subclause 16.10, “<path pattern expression>” are applied to the result\nof the previous syntactic transformation.\nGeneral Rules\nNone.\nConformance Rules\n1)\nWithoutFeatureG039,“Simplifiedpathpatternexpression:fulldefaulting”,conformingGQLlanguage\nshall not contain a <simplified path pattern expression> that is not a <simplified defaulting left>, a\n<simplified defaulting right>, or a <simplified defaulting any direction>.\n2)\nWithout Feature G080, “Simplified path pattern expression: basic defaulting”, conforming GQL\nlanguage shall not contain a <simplified defaulting left>, a <simplified defaulting right>, or a <sim-\nplified defaulting any direction>.\n3)\nWithoutFeatureG081,“Simplifiedpathpatternexpression:fulloverrides”,conformingGQLlanguage\nshall not contain a <simplified direction override> that is not a <simplified override left>, a <simpli-\nfied override right>, or a <simplified override any direction>.\n4)\nWithout Feature G082, “Simplified path pattern expression: basic overrides”, conforming GQL lan-\nguage shall not contain a <simplified override left>, a <simplified override right>, or a <simplified\noverride any direction>.\n247\nIWD 39075:2023(E)\n16.14 <simplified path pattern expression>"
  },
  {
    "page": 262,
    "text": "16.15 <where clause>\nFunction\nCompute a new binding table by selecting records from the current working table fulfilling the specified\n<search condition>.\nFormat\n<where clause> ::=\nWHERE <search condition>\nSyntax Rules\n1)\nLet WC be the <where clause> and let SC be the <search condition> immediately contained in WC.\n2)\nThe declared type of the incoming working record of SC is the declared type of the incoming\nworking record of WC amended with the record type of the declared type of the incoming working\ntable of WC.\n3)\nThe declared type of the incoming working table of SC is the material unit binding table type.\n4)\nThe declared type of WC is the declared type of incoming working table of WC.\nGeneral Rules\n1)\nLet WHERE be a new empty binding table.\n2)\nFor each record R of the current working table:\na)\nLet INCLUDE be the result of SC in a new child execution context amended with R.\n« WG3:CMN-019 P00-USA-351 »\nb)\nIf INCLUDE is True, then R is added to WHERE.\n3)\nThe result of WC is WHERE.\nConformance Rules\nNone.\n248\nIWD 39075:2023(E)\n16.15 <where clause>"
  },
  {
    "page": 263,
    "text": "16.16 <yield clause>\nFunction\nSelect and rename columns of a binding table.\nFormat\n<yield clause> ::=\nYIELD <yield item list>\n<yield item list> ::=\n<yield item> [ { <comma> <yield item> }... ]\n<yield item> ::=\n{ <yield item name> [ <yield item alias> ] }\n<yield item name> ::=\n<field name>\n<yield item alias> ::=\nAS <binding variable>\nSyntax Rules\n1)\nLet YC be the <yield clause>.\n2)\nLet COYI be the collection of <yield item>s simply contained in YC.\n« WG3:CMN-019 P00-USA-207 »\n3)\nLet N be the number of <yield item>s in COYI.\n4)\nFor each <yield item> YIi, 1 (one) ≤i ≤N, in COYI:\na)\nLet YINi be the <yield item name> specified by YIi.\nb)\nIf YIi does not immediately contain a <yield item alias>, then:\ni)\nYINi shall be a <binding variable>.\nii)\nYIi is effectively replaced by:\nYINi AS YINi\n« WG3:CMN-019 P00-USA-207 »\n5)\nLet YCT be the <yield clause> after the preceding transformation and let COYIT be the collection of\nN <yield item>s simply contained in YCT.\n6)\nIf COYIT simply contains a <yield item alias> that simply contains a <binding variable> YIABV1,\nthen COYIT shall not simply contain another <yield item alias> that simply contains a <binding\nvariable> YIABV2 such that YIABV1 and YIABV2 are equivalent.\n7)\nThe declared type of YCT is a binding table type BTT defined as follows:\n« WG3:CMN-019 P00-USA-207 »\na)\nBTT has N columns.\n249\nIWD 39075:2023(E)\n16.16 <yield clause>"
  },
  {
    "page": 264,
    "text": "b)\nFor each <yield item> YIi, 1 (one) ≤i ≤N in COYIT:\ni)\nLet YINi be the <yield item name> specified by YIi.\nii)\nLet YIAi be the <binding variable> simply contained in the <yield item alias> specified\nby YIi.\niii)\nThe declared type of the incoming working table of YC shall have a column SC with\ncolumn name YINi.\niv)\nBTT has a column TC.\nv)\nThe column type of TC is the column type of SC.\nGeneral Rules\n1)\nLet YIELD be a new empty binding table.\n2)\nFor each record R of the current working table in a new child execution context amended with R:\na)\nLet T be a new empty record.\n« WG3:CMN-019 P00-USA-207 »\nb)\nFor each <yield item> YIi, 1 (one) ≤i ≤N, from COYIT:\ni)\nLet YINi be the <yield item name> specified by YIi.\nii)\nLet Fi be the field of the current working record whose field name is YINi.\niii)\nLet YIVi be the field value of Fi.\nNOTE 201 — As opposed to the General Rules for <binding variable>, <yield item>s only\nconsiderthe current working record and ignore the working records of any parent execution\ncontexts that precede the current execution context in the current execution stack.\niv)\nLet YIAi be the <binding variable> simply contained in the <yield item alias> specified\nby YIi.\n« WG3:CMN-019 P00-USA-351 »\nv)\nA new field with field name YIAi and with field value YIVi is added to T.\nc)\nT is added to YIELD.\n3)\nThe result of YCT is YIELD.\nConformance Rules\nNone.\n250\nIWD 39075:2023(E)\n16.16 <yield clause>"
  },
  {
    "page": 265,
    "text": "16.17 <group by clause>\nFunction\nDefine a <group by clause> for specifying the set of grouping keys to be used during grouping.\n** Editor’s Note (number 40) **\nAggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .\nFormat\n<group by clause> ::=\nGROUP BY <grouping element list>\n« WG3:CMN-019 P00-USA-104 »\n<grouping element list> ::=\n<grouping element> [ { <comma> <grouping element> }... ]\n| <empty grouping set>\n<grouping element> ::=\n<binding variable reference>\n<empty grouping set> ::=\n<left paren> <right paren>\nSyntax Rules\n1)\nLet GBC be the <group by clause> and let GEL be the <grouping element list>.\n2)\nLet COLS be the sequence of columns defined as follows.\nCase:\n« WG3:CMN-019 P00-NLD-060 »\na)\nIf GEL is the <empty grouping set>, then COLS is the empty sequence.\nb)\nOtherwise:\ni)\nLet GESEQ be the sequence of <grouping element>s immediately contained in GEL and\nlet NGESEQ be the number of such <grouping element>s in GESEQ.\nii)\nFor every i-th element GEi of GESEQ, 1 (one) ≤i ≤NGESEQ:\n1)\nLet BVRi be the <binding variable reference> immediately contained in GEi.\n2)\nThe declared type of the incoming working record of BVRi is the declared type of\nthe incoming working record of GBC amended with the record type of the declared\ntype of the incoming working table of GBC.\n3)\nThe declared type of the incoming working table of BVRi is the unit binding table\ntype.\n4)\nBVRi is an operand of a grouping operation. The Syntax Rules and Conformance\nRules of Subclause 22.14, “Grouping operations”, apply.\n251\nIWD 39075:2023(E)\n16.17 <group by clause>"
  },
  {
    "page": 266,
    "text": "5)\nLet GEBVi be the name of the binding variable referenced by BVRi.\n6)\nLet COLi be the column whose name is GEBVi and whose type is the declared type\nof BVRi.\n7)\nAppend COL to COLS.\n3)\nThe declared type of the outgoing working table of GBC is a material binding table whose set of\ncolumns is COLS.\n4)\nThe declared type of the outgoing working record of GBC is the declared type of the incoming\nworking record of GBC.\n5)\nThe declared type of GBC is the declared type of the outgoing working table of GBC.\nGeneral Rules\n1)\nCase:\na)\nIf GEL is the <empty grouping set>, then let GROUP_BY be a unit binding table.\nb)\nOtherwise:\ni)\nFor i, 1 (one) ≤i ≤NGESEQ, let GEibe the i-th element of GESEQ and let GEBVi be the\n<binding variable reference> simply contained in GEBVi.\nii)\nLet GROUP_BY be a new empty binding table with the column set COLS.\niii)\nForeachrecord R ofthecurrent working table in a new childexecutioncontext amended\nwith R:\n1)\nLet T be a new record comprising fields Fi, 1 (one) ≤i ≤NGESEQ, such that the\nfield name of Fi is the column name of COLSi and the field value of Fi is the value\nof GEBVi in R.\n2)\nIf T is distinct from every record in GROUP_BY, then T is added to GROUP_BY.\n2)\nThe result of GBC is GROUP_BY.\nConformance Rules\n1)\nWithout Feature GQ15, “GROUP BY clause”, conforming GQL language shall not contain <group by\nclause>.\n252\nIWD 39075:2023(E)\n16.17 <group by clause>"
  },
  {
    "page": 267,
    "text": "16.18 <order by clause>\nFunction\nApply a <sort specification list> to the current working table.\nFormat\n<order by clause> ::=\nORDER BY <sort specification list>\nSyntax Rules\n1)\nLet OBC be the <order by clause>.\n2)\nLet SSL be the <sort specification list> that is immediately contained in OBC.\n3)\nThe declared type of OBC is the declared type of the incoming working table of OBC.\nGeneral Rules\n1)\nThe result of OBC is the result of SSL.\nConformance Rules\nNone.\n253\nIWD 39075:2023(E)\n16.18 <order by clause>"
  },
  {
    "page": 268,
    "text": "16.19 <aggregate function>\nFunction\nSpecify a value computed from a collection of records.\n** Editor’s Note (number 41) **\nAggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .\nFormat\n<aggregate function> ::=\nCOUNT <left paren> <asterisk> <right paren>\n| <general set function>\n| <binary set function>\n** Editor’s Note (number 42) **\nConsider inclusion of aggregate function calls to procedures with formal parameters of multiple parameter car-\ndinality. See Language Opportunity GQL-186 .\n<general set function> ::=\n<general set function type>\n<left paren> [ <set quantifier> ] <value expression> <right paren>\n<binary set function> ::=\n<binary set function type>\n<left paren> <dependent value expression> <comma> <independent value expression>\n<right paren>\n<general set function type> ::=\nAVG\n| COUNT\n| MAX\n| MIN\n| SUM\n| COLLECT_LIST\n| STDDEV_SAMP\n| STDDEV_POP\n<set quantifier> ::=\nDISTINCT\n| ALL\n<binary set function type> ::=\nPERCENTILE_CONT\n| PERCENTILE_DISC\n<dependent value expression> ::=\n[ <set quantifier> ] <numeric value expression>\n<independent value expression> ::=\n<numeric value expression>\n254\nIWD 39075:2023(E)\n16.19 <aggregate function>"
  },
  {
    "page": 269,
    "text": "Syntax Rules\n1)\nLet AF be the <aggregate function>.\n2)\nIf AF immediately contains a <general set function> that does not specify the <set quantifier>, then\nALL is implicit.\n3)\nAF shall not contain a <procedure body>.\n« WG3:CMN-019 P00-USA-105 One SR removed »\n4)\nLet the <value expression> or the <dependent value expression> VE be defined as follows.\nCase:\na)\nIf AF is directly contained in a <value expression> that is not immediately contained in an\n<aggregating value expression>, then VE is the <value expression> or the <dependent value\nexpression> immediately contained in AF.\nb)\nIf AF immediately contains a <general set function> GSF, then VE is the <value expression>\nimmediately contained in GSF.\nc)\nOtherwise, AF immediately contains a <binary set function> BSF and VE is the <dependent\nvalue expression> immediately contained in BSF.\n5)\nLet DT be the declared type of VE.\n6)\nIf AF immediately contains COUNT, then:\na)\nIf AF immediately contains <asterisk>, then AF shall be directly contained in an <aggregating\nvalue expression>.\nb)\nThe declared type of the result is an implementation-defined(ID059) exact numeric type with\nscale 0 (zero).\n7)\nIf AF immediately contains a <general set function>, then:\na)\nIf AF specifies a <general set function> whose <set quantifier> is DISTINCT, then VE is an\noperand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14,\n“Grouping operations”, apply.\nb)\nIf AF specifies a <general set function type> that is MAX or MIN, then VE is an operand of an\nordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13, “Ordering\noperations”, apply.\nc)\nIf MAX or MIN is specified, then the declared type of the result is DT.\nd)\nIf SUM or AVG is specified, then:\ni)\nDT shall be a numeric type.\nii)\nIf SUM is specified and DT is exact numeric with scale S, then the declared type of the\nresult is an implementation-defined (ID095) exact numeric type with scale S.\niii)\nIf AVG is specified and DT is exact numeric, then the declared type of the result is an\nimplementation-defined (ID096) exact numeric type with precision not less than the\nprecision of DT and scale not less than the scale of DT.\niv)\nIf DT is approximate numeric, then the declared type of the result is an implementation-\ndefined (ID097) approximate numeric type with precision not less than the precision\nof DT.\n255\nIWD 39075:2023(E)\n16.19 <aggregate function>"
  },
  {
    "page": 270,
    "text": "e)\nIfSTDDEV_POP orSTDDEV_SAMPisspecified,thenDTshallbeanumerictypeandthedeclared\ntype of the result shall be an implementation-defined (ID098) approximate numeric type. If\nDT is an approximate numeric type, then the precisionof the result is not less than the precision\nof DT.\nf)\nIf COLLECT_LIST is specified, then the declared type of the result is the regular list value type\nwhose list element type is DT.\n8)\nIf AF immediately contains a <binary set function>, then:\na)\nLet DVEXP be the <numeric value expression> immediately contained in the <dependent value\nexpression> immediately contained in AF.\nb)\nLet IVE be the <independent value expression> simply contained in AF.\nc)\nIf AF specifies no <set quantifier>, then ALL is implicit.\nd)\nThe declared type of the incoming working record of the DVEXP is the declared type of the\nincomingworking record ofAF amendedwiththerecord typeofdeclaredtypeoftheincoming\nworking table of AF.\ne)\nThe declared type of the incoming working table of DVEXP is the material unit binding table\ntype.\nf)\nThe declared type of the incoming working record of IVE is the declared type of the incoming\nworking record of AF.\ng)\nThe declared type of the incoming working table of IVE is the material unit binding table type.\nh)\nLet DTIVE be the declared type of IVE.\ni)\nThe declared type of the result is an implementation-defined (ID099) approximate numeric\ntype. If DT is an approximate numeric type, then the precision of the result is not less than\nthe precision of DT. If DTIVE is an approximate numeric type, then the precision of the result\nis not less than the precision of DTIVE.\nGeneral Rules\n1)\nLet TABLE be the current working table.\n2)\nIf AF is COUNT(*), then the result of AF is the count of records in TABLE and no further General\nRules are applied.\n3)\nIf, during the computation of the result of AF, an intermediate result is not representable in the\ndeclared type of the site that contains that intermediate result, then\nCase:\na)\nIf the most specific type of the result of AF is a list value type, then an exception condition is\nraised: data exception — list data, right truncation (22G0B).\nb)\nIf the most specifictype of the result of AF is a character string type, then an exception condition\nis raised: data exception — string data, right truncation (22001).\nc)\nOtherwise, an exception condition is raised: data exception — numeric value out of range\n(22003).\n4)\nLet SQ be defined as follows.\nCase:\n256\nIWD 39075:2023(E)\n16.19 <aggregate function>"
  },
  {
    "page": 271,
    "text": "a)\nIf AF is a <general set function> GSF, then SQ is the <set quantifier> immediately contained in\nGSF.\nb)\nOtherwise, AF is a <binary set function> BSF and SQ is the <set quantifier> immediately con-\ntained in the <dependent value expression> immediately contained in BSF.\n5)\nLet the collection VALUES be determined as follows.\nCase:\na)\nIf AF is directly contained in a <value expression> that is not immediately contained in an\n<aggregating value expression>, then:\ni)\nLet GLBV be the binding variable referenced by <binding variable reference>s simply\ncontained in AF without an intervening instance of <independent value expression>\nwhose declared type is the group list value type.\nii)\nGeneral Rules of Subclause 22.7, “Evaluation of an expression on a group variable”, are\napplied with GLBV as GROUP LIST BINDING VARIABLE and VE as EXPRESSION; let\nVALUES be the LIST VALUE returned from the application of those General Rules.\nb)\nOtherwise:\ni)\nInitially, VALUES is an empty collection.\nii)\nFor each record R of TABLE in a new child execution context amended with R:\n1)\nLet EXPRE be the result of VE.\n2)\nCase:\nA)\nIf EXPRE is null, then a completion condition is raised: warning — null value\neliminated in set function (01G11).\nB)\nOtherwise,\nCase:\nI)\nIf SQ is DISTINCT and EXPRE is not in VALUES, then EXPRE is added\nto VALUES;\nII)\nOtherwise, SQ is ALL and EXPRE is added to VALUES.\n6)\nLet N be the cardinality of VALUES.\n7)\nLet RESULT be defined as follows.\nCase:\na)\nIf AF is the <general set function> GSF, then\nCase:\ni)\nIf COUNT is specified, then RESULT is N.\nii)\nIf VALUES is empty, then RESULT is defined as follows:\nCase:\n1)\nIf AF is COLLECT_LIST, then RESULT is the empty list.\n2)\nOtherwise, RESULT is the null value.\n257\nIWD 39075:2023(E)\n16.19 <aggregate function>"
  },
  {
    "page": 272,
    "text": "iii)\nIf MAX or MIN is specified, then RESULT is the result, respectively, of the maximum\nvalue or the minimum value in VALUES. RESULT is determined using the comparison\nrules specified in Subclause 19.3, “<comparison predicate>”.\niv)\nIf SUM is specified, then RESULT is the sum of the values in VALUES. If RESULT is not\nwithin the range of the declared type of RESULT, then an exception condition is raised:\ndata exception — numeric value out of range (22003).\nv)\nIfSTDDEV_POPorSTDDEV_SAMPisspecified,thenletSXbethesumofvaluesinVALUES\nand let SXS be the sum of the squares of the values in VALUES.\n1)\nIf STDDEV_POPis specified,then RESULT istheresultofSQRT((SXS-SX*SX/N)/N).\n2)\nIf STDDEV_SAMP is specified, then\nCase:\nA)\nIf N is 1 (one), then RESULT is the null value.\nB)\nOtherwise, then RESULT is the result of SQRT((SXS-SX*SX/N)/(N - 1)).\n3)\nIf COLLECT_LIST is specified, then RESULT is the list comprised of all values in\nVALUES. If RESULT is not within the range of the declared type of RESULT, then\nan exception condition is raised: data exception — list data, right truncation\n(22G0B).\nb)\nOtherwise,AFisthe<binarysetfunction>BSF. LetIVE bethe<independentvalueexpression>\nimmediately contained in BSF, let IVERE be the result of evaluating IVE in a new child execution\ncontext, and\nCase:\ni)\nIf VALUES is empty, then RESULT is the null value.\nii)\nEXP is an operand of an ordering operation. The Syntax Rules and Conformance Rules\nof Subclause 22.13, “Ordering operations”, apply.\niii)\nLet ORDERED_VALUES be the sequence of non-null elements in VALUES ordered from\nleast to greatest. ORDERED_VALUES is determined using the comparison rules specified\nin Subclause 19.3, “<comparison predicate>”. Let N_ORDERED_VALUES be the cardin-\nality of ORDERED_VALUES.\niv)\nLet INDEX be the result of 1 + (IVERE * (N_ORDERED_VALUES - 1)).\nv)\nIf PERCENTILE_CONT is specified, then\nCase:\n1)\nIf INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position\nINDEX.\n2)\nOtherwise:\nA)\nLet INDEX_FLOOR be the largest integer less than INDEX\nand let RESULT_FLOOR be the value in ORDERED_VALUES at position\nINDEX_FLOOR.\nB)\nLet INDEX_CEILING be the smallest integer greater than INDEX\nand let RESULT_CEILING be the value in ORDERED_VALUES at position\nINDEX_CEILING.\nC)\nRESULT is the result of (INDEX_CEILING - INDEX) * RESULT_FLOOR\n258\nIWD 39075:2023(E)\n16.19 <aggregate function>"
  },
  {
    "page": 273,
    "text": "+ (INDEX - INDEX_FLOOR) * RESULT_CEILING.\nvi)\nIf PERCENTILE_DISC is specified, then\nCase:\n1)\nIf INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position\nINDEX.\n2)\nOtherwise, RESULT is the value in ORDERED_VALUES at the position obtained as\na result of rounding or truncating INDEX. The choice of whether to round or\ntruncate is implementation-defined (IA027).\n8)\nThe result of evaluating AF is RESULT.\nConformance Rules\n1)\nWithout Feature GF10, “Advanced aggregate functions: general set functions”, conforming GQL\nlanguage shall not contain an <aggregate function>that immediately containsa <general set function\ntype> that is that is COLLECT_LIST, STDDEV_SAMP, or STDDEV_POP.\n2)\nWithout Feature GF11, “Advanced aggregate functions: binary set functions”, conforming GQL lan-\nguage shall not contain an <aggregate function> that immediately contains a <binary set function\ntype>.\n259\nIWD 39075:2023(E)\n16.19 <aggregate function>"
  },
  {
    "page": 274,
    "text": "16.20 <sort specification list>\nFunction\nObtaining an ordered binding table from the current working table.\nFormat\n<sort specification list> ::=\n<sort specification> [ { <comma> <sort specification> }... ]\n<sort specification> ::=\n<sort key> [ <ordering specification> ] [ <null ordering> ]\n<sort key> ::=\n<aggregating value expression>\n<ordering specification> ::=\nASC\n| ASCENDING\n| DESC\n| DESCENDING\n<null ordering> ::=\nNULLS FIRST\n| NULLS LAST\nSyntax Rules\n1)\nEach <value expression>immediately contained in the <sort key> contained in a <sort specification>\nis an operand of an ordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13,\n“Ordering operations”, apply.\n2)\nLet SSL be the <sort specification list>\n3)\nLet NSS be the number of <sort specification>s immediately contained in SSL.\n« WG3:CMN-019 P00-NLD-050 »\n4)\nFor i, 1 (one) ≤i ≤NSS, let SSi be the i-th <sort specification> immediately contained in SSL.\n5)\nFor each SSi, 1 (one) ≤i ≤NSS:\na)\nLet SKi be the <sort key> immediately contained in SSi.\nb)\nIf SSi does not immediately contain an <ordering specification>, then SSi is effectively replaced\nby:\nSKi ASC\nc)\nThe declared type of the incoming working record of SKi is the declared type of the incoming\nworking record of SSL amended with the record type of the declared type of the incoming\nworking table of SSL.\nd)\nThe declared type of the incoming working table of SKi is the material unit binding table type.\ne)\nThedeclaredtypeofSKi isthedeclaredtypeofthe<aggregating value expression>immediately\ncontained in SKi.\n260\nIWD 39075:2023(E)\n16.20 <sort specification list>"
  },
  {
    "page": 275,
    "text": "6)\nIf <null ordering> is not specified, then an implementation-defined (IS001) <null ordering> is\nimplicit. The implementation-defined default for <null ordering> shall not depend on the context\noutside of <sort specification list>.\n7)\nThe declared type of SSL is the declared type of the incoming working table of SSL.\nGeneral Rules\n1)\nLet SORTED be a new ordered binding table created from the collection of records of the current\nworking table by ordering the records, as follows:\na)\nLet N be the number of <sort specification>s.\n« WG3:CMN-019 P00-NLD-050 »\nb)\nFor i, 1 (one) ≤i ≤N, let Ki be the <sort key> contained in the i-th <sort specification>.\nc)\nEach <sort specification> specifies the sort direction for the corresponding sort key Ki. If\nneither DESC nor DESCENDING is specified in the i-th <sort specification>, then the sort dir-\nectionforKi isascendingand theapplicable<compop>isthe<lessthan operator>; otherwise,\nthe sort direction for Ki is descending and the applicable <comp op> is the <greater than\noperator>.\nd)\nLet P be any record of the collection of records to be ordered, and let Q be any other record\nof the same collection of records.\ne)\nLet PVi be the result of Ki in a new child execution context amended with P.\nf)\nLet QVi be the result of Ki in a new child execution context amended with Q.\ng)\nThe relative position of records P and Q in the result is determined by comparing PVi and QVi\nas follows:\ni)\nThe comparison is performed according to the General Rules of Subclause 19.3,\n“<comparison predicate>”, where the <comp op> is the applicable <comp op> for Ki.\nii)\nThe comparison is performed with the following special treatment of null values.\nCase:\n1)\nIf PVi and QVi are both the null value, then they are considered equal to each other.\n2)\nIf PVi is the null value and QVi is not the null value, then\nCase:\nA)\nIf NULLS FIRST is specifiedor implied, then PVi <comp op> QVi is considered\nto be True.\nB)\nIf NULLS LAST is specified or implied, then PVi <comp op> QVi is considered\nto be False.\n3)\nIf PVi is not the null value and QVi is the null value, then\nCase:\nA)\nIf NULLS FIRST is specifiedor implied, then PVi <comp op> QVi is considered\nto be False.\n261\nIWD 39075:2023(E)\n16.20 <sort specification list>"
  },
  {
    "page": 276,
    "text": "B)\nIf NULLS LAST is specified or implied, then PVi <comp op> QVi is considered\nto be True.\nh)\nPVi is said to precede QVi if the result of the <comparison predicate> “PVi <comp op> QVi” is\nTrue for the applicable <comp op>.\ni)\nIf PVi and QVi are not the null value and the result of “PVi <comp op> QVi” is Unknown, then\nthe relative ordering of PVi and QVi is implementation-dependent (US007).\n« WG3:CMN-019 P00-NLD-050 »\nj)\nThe relative position of record P is before record Q if for some n, 1 (one) ≤n ≤N, PVn precedes\nQVn and PVi is not distinct from QVi for all i < n.\nk)\nTwo records that are not distinct with respect to the <sort specification>s are said to be peers\nof each other. The relative ordering of peers is implementation-dependent (US006).\nl)\nThe result of SSL is SORTED.\nConformance Rules\n1)\nWithout Feature GA03, “Explicit ordering of nulls”, conforming GQL language shall not contain a\n<null ordering>.\n262\nIWD 39075:2023(E)\n16.20 <sort specification list>"
  },
  {
    "page": 277,
    "text": "16.21 <limit clause>\nFunction\nObtain a new binding table that retains only a limited number of records of the current working table.\nFormat\n<limit clause> ::=\nLIMIT <unsigned integer specification>\n** Editor’s Note (number 43) **\nWITH TIES, ONLY, RECORDS, and GROUPS to be added. See Language Opportunity GQL-161\nSyntax Rules\n1)\nLet LC be the <limit clause>.\n2)\nThe declared type of LC is the declared type of the incoming working table of LC.\nGeneral Rules\n1)\nLet TABLE be the current working table.\n2)\nIf TABLE is not ordered, then let ORDERED_TABLE be a new ordered binding table created from the\nresult of sorting the collection of all records of TABLE according to an implementation-dependent\n(US001) order; otherwise, let ORDERED_TABLE be TABLE.\n3)\nLet V be the result of the <unsigned integer specification>.\n4)\nLet LIMIT be a new ordered binding table obtained by selecting only the first V records of\nORDERED_TABLE and discarding all subsequent records.\nNOTE 202 — If the order of the result of LC has no effect on the outcome of a <GQL-program>, there is\nno need for LIMIT to be indicated as ordered.\n5)\nThe result of LC is LIMIT.\nConformance Rules\nNone.\n263\nIWD 39075:2023(E)\n16.21 <limit clause>"
  },
  {
    "page": 278,
    "text": "16.22 <offset clause>\nFunction\nObtaining a new binding table that retains all records of the current working table except for some dis-\ncarded initial records.\nFormat\n<offset clause> ::=\n<offset synonym> <unsigned integer specification>\n<offset synonym> ::=\nOFFSET | SKIP\n** Editor’s Note (number 44) **\nWITH TIES, ONLY, RECORDS, and GROUPS to be added. See Language Opportunity GQL-162 .\nSyntax Rules\n1)\nLet OC be the <offset clause>.\n2)\nThe declared type of OC is the declared type of the incoming working table of OC.\nGeneral Rules\n1)\nLet TABLE be the current working table.\n2)\nIf TABLE is not ordered, then let ORDERED_TABLE be a new ordered binding table created from the\nresult of sorting the collection of all records of TABLE according to an implementation-dependent\n(US001) order; otherwise, let ORDERED_TABLE be TABLE.\nNOTE 203 — If the order of the result of OC has no effect on the outcome of a <GQL-program>, there is\nno need for OFFSET to be indicated as ordered.\n3)\nLet V be the result of the <unsigned integer specification>.\n4)\nLet OFFSET be a new ordered binding table obtained from all but the first V records of\nORDERED_TABLE.\n5)\nThe result of OC is OFFSET.\nConformance Rules\nNone.\n264\nIWD 39075:2023(E)\n16.22 <offset clause>"
  }
]