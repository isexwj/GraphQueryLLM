[
  {
    "section": "14.2",
    "title": "<composite query expression>",
    "text": "ii) The declared type of the incoming working record of ICQE is the declared type of the incoming working record of CQE. iii) The declared type of the incoming working table of ICQE is the declared type of the incoming working table of CQE. iv) Let FCQE be the set of the columns of the declared type of the outgoing working table of ICQE and let FLQE be the set of the columns of the declared type of the outgoing working table of CQP. v) FCQE and FLQE shall be column name-equal and column-combinable. vi) Let COLS be the combined columns of FCQE and FLQE. vii) If the GQL-implementation does not support Feature GA04, “Universal comparison”, then there shall be no column COL in COLS such that: 1) The value type of COL is a dynamic union type DUT. 2) There exists a pair of different component types CT1 and CT2 of DUT such that CT1 and CT2 are not comparable. viii) If <set operator> is UNION DISTINCT, EXCEPT ALL, EXCEPT DISTINCT, INTERSECT ALL, or INTERSECT DISTINCT, then each column in COLS is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations”, apply. ix) The declared type of CQE is the material binding table whose set of columns is COLS. b) Otherwise, the declared type of CQE is the declared type of the outgoing working table of CQP. General Rules 1) The result of CQP is the result of LQS. 2) Case: a) If <query conjunction> is specified, then: i) Let ICQER be the binding table that is the result of ICQE. ii) Let CQPR be the binding table that is the result of CQP. iii) Let FCQER be a new binding table whose columns are COLS. iv) If <set operator> is specified, then FCQER contains the following records: « WG3:CMN-019 P00-USA-207 » 1) Let R be a record that is a duplicate of some record in ICQER or of some record in CQPR or both. Let M be the number of duplicates of R in ICQER and let N be the number of duplicates of R in CQPR, where M ≥0 (zero) and N ≥0 (zero). 2) If DISTINCT is specified or implicit, then Case: A) If UNION is specified, then FCQER contains exactly one duplicate of R. NOTE 133 — R exists as a result of GR 2)a)iv)1), guaranteeing that FCQER always contains a duplicate of R. B) If EXCEPT is specified, then 160 IWD 39075:2023(E) "
  },
  {
    "section": "14.2",
    "title": "<composite query expression>",
    "text": "Case: « WG3:CMN-019 P00-USA-207 » I) If M > 0 (zero) and N = 0 (zero), then FCQER contains exactly one duplicate of R. II) Otherwise, FCQER contains no duplicate of R. C) If INTERSECT is specified, then Case: « WG3:CMN-019 P00-USA-207 » I) If M > 0 (zero) and N > 0 (zero), then FCQER contains exactly one duplicate of R. II) Otherwise, FCQER contains no duplicates of R. 3) If ALL is specified, then Case: « WG3:CMN-019 P00-USA-207 » A) If UNION is specified,then the number of duplicates of R that FCQER contains is (M + N). B) If EXCEPT is specified, then the number of duplicates of R that FCQER con- tains is the maximum of (M −N) and 0 (zero). C) If INTERSECT is specified, then the number of duplicates of R that FCQER contains is the minimum of M and N. v) If OTHERWISE is specified, then Case: 1) If ICQER contains at least one record, then let FCQER be ICQER. 2) Otherwise, let FCQER be CQPR. vi) The result of CQE is FCQER. b) Otherwise, the result of CQE is the result of CQP. Conformance Rules 1) WithoutFeature GQ02,“Composite query:OTHERWISE”, conformingGQL language shall not contain a <composite query expression> that immediately contains a <query conjunction> OTHERWISE. 2) Without Feature GQ03, “Composite query: UNION”, conforming GQL language shall not contain a <composite query expression> that immediately contains a <query conjunction> UNION. 3) Without Feature GQ04, “Composite query: EXCEPT DISTINCT”, conforming GQL language shall not contain a <composite query expression>that immediately contains a <query conjunction>EXCEPT. 4) Without Feature GQ05, “Composite query: EXCEPT ALL”, conforming GQL language shall not contain a <composite query expression> that immediately contains a <query conjunction> EXCEPT ALL. 161 IWD 39075:2023(E) "
  },
  {
    "section": "14.2",
    "title": "<composite query expression>",
    "text": "5) Without Feature GQ06, “Composite query: INTERSECT DISTINCT”, conforming GQL language shall not contain a <composite query expression> that immediately contains a <query conjunction> INTERSECT. 6) Without Feature GQ07, “Composite query: INTERSECT ALL”, conforming GQL language shall not contain a <composite query expression> that immediately contains a <query conjunction> INTER- SECT ALL. 162 IWD 39075:2023(E) "
  },
  {
    "section": "14.2",
    "title": "<composite query expression>",
    "text": "14.3 <linear query statement> and <simple query statement> Function Specify a linear composition of <simple query statement>s that returns a result. Format <linear query statement> ::= <focused linear query statement> | <ambient linear query statement> <focused linear query statement> ::= [ <focused linear query statement part>... ] <focused linear query and primitive result statement part> | <focused primitive result statement> | <focused nested query specification> | <select statement> <focused linear query statement part> ::= <use graph clause> <simple linear query statement> <focused linear query and primitive result statement part> ::= <use graph clause> <simple linear query statement> <primitive result statement> <focused primitive result statement> ::= <use graph clause> <primitive result statement> <focused nested query specification> ::= <use graph clause> <nested query specification> <ambient linear query statement> ::= [ <simple linear query statement> ] <primitive result statement> | <nested query specification> <simple linear query statement> ::= <simple query statement>... <simple query statement> ::= <primitive query statement> | <call query statement> <primitive query statement> ::= <match statement> | <let statement> | <for statement> | <filter statement> | <order by and page statement> Syntax Rules 1) Let LQS be the <linear query statement>. « WG3:CMN-019 P00-NLD-050 » « WG3:CMN-019 P00-USA-207 » 2) Let STMSEQ be the sequence of <simple query statement>s, the <primitive result statement>, the <nested query specification>, and the <select statement> directly contained in LQS. Let N be the number of elements of STMSEQ. For i, 1 (one) ≤i ≤N, let STMi be the i-th element of STMSEQ. 163 IWD 39075:2023(E) "
  },
  {
    "section": "14.3",
    "title": "<linear query statement> and <simple query statement>",
    "text": "3) The declared type of the incoming working record of STM1 is the declared type of the incoming working record of LQS. 4) The declared type of the incoming working table of STM1 is the declared type of the incoming working table of LQS. « WG3:CMN-019 P00-USA-207 » 5) For 2 (two) ≤i ≤N: a) The declared type of the incoming working record of STMi is the declared type of the outgoing working record of STMi-1. b) The declared type of the incoming working table of STMi is the declared type of the outgoing working table of STMi-1. « WG3:CMN-019 P00-USA-207 » 6) The declared type of LQS is the declared type of STMN. General Rules None. Conformance Rules 1) Without Feature GQ01, “USE graph clause”, conforming GQL language shall not contain a <focused linear query statement>. 164 IWD 39075:2023(E) "
  },
  {
    "section": "14.3",
    "title": "<linear query statement> and <simple query statement>",
    "text": "14.4 <match statement> Function Expand the current working table with matches from a graph pattern. Format <match statement> ::= <simple match statement> | <optional match statement> <simple match statement> ::= MATCH <graph pattern binding table> <optional match statement> ::= OPTIONAL <optional operand> <optional operand> ::= <simple match statement> | <left brace> <match statement block> <right brace> | <left paren> <match statement block> <right paren> <match statement block> ::= <match statement>... Syntax Rules 1) Let MS be the <match statement>. 2) Let IREDT be the declared type of the incoming working record of MS and let IREDTFNS be the set of field names of IREDT. 3) Let ITART be the record type of the declared type of the incoming working table of MS and let ITARTFNS be the set of field names of ITART. 4) If MS immediately contains <optional match statement>, then: a) Let IFNS be the union of IREDTFNS and ITARTFNS. b) Let IBVRL be an implementation-dependent (US010) comma-separated list of all incoming <binding variable reference>s corresponding to <binding variable>s whose names are in IFNS. c) A <graph pattern binding table> T supplies output bindings to a <match statement> S if at least one of the following is true: i) S is a <simple match statement> that immediately contains T. ii) S is an <optional match statement> whose <optional operand> is a <simple match statement> that immediately contains T. iii) S is an <optional match statement> whose <optional operand> immediately contains a <match statement block> B and T supplies output bindings to a <match statement> immediately contained in B. NOTE 134 — This is a recursive definition.An <exists predicate> contained in S provides an example of a <graph pattern binding table> that does not supply output bindings to S. 165 IWD 39075:2023(E) "
  },
  {
    "section": "14.4",
    "title": "<match statement>",
    "text": "d) Let OBVRL be an implementation-dependent (US010) comma-separated list of <binding variable reference>s corresponding to <binding variable>s whose names are column names of the declared type of any <graph pattern binding table> that supplies output bindings to MS that are not included in IFNS. e) Let RETURN be defined as follows. Case: i) If OBVRL is the empty list, then RETURN is: RETURN NO BINDINGS ii) Otherwise, OBVRL is not empty and RETURN is: RETURN OBVRL f) Let OO be the <optional operand> simply contained in MS. Case: i) If OO immediately contains a <simple match statement> SMS, then MS is effectively replaced by: OPTIONAL CALL (IBVRL) {  SMS RETURN } ii) If OO immediately contains a <match statement block> MSB, then MS is effectively replaced by: OPTIONAL CALL (IBVRL) {  MSB RETURN } « WG3:CMN-019 P00-ISO-023 » NOTE 135 — This transformation is applied recursively if MSB contains one or more nested <optional match statement>s. IBVRL and OBVRL are computed separately for each trans- formation. 5) If MS is a <simple match statement>, then: a) Let GPBT be the <graph pattern binding table> that is simply contained in MS. b) Let GPBTRT be the record type of the declared type of GPBT. c) The declared type of the outgoing working record of MS is IREDT amended with the record type that is GPBTRT restricted to the fields identified by IREDTFNS. NOTE 136 — It is possible that the declared type of a graph pattern variable changes by changing the corresponding declared type of the incoming working record or the corresponding declared type of the incoming working table at certain sites. d) The declared type of the outgoing working table of MS is the binding table type whose record type is ITART amended with the record type that is GPBTRT without the fields identified by IREDTFNS. NOTE 137 — It is possible that the declared type of a graph pattern variable changes by changing the corresponding declared type of the incoming working record or the corresponding declared type of the incoming working table at certain sites. « WG3:CMN-019 P00-USA-072 » 166 IWD 39075:2023(E) "
  },
  {
    "section": "14.4",
    "title": "<match statement>",
    "text": "6) MS has no declared type. General Rules 1) Let NEW_TABLE be the binding table obtained as a copy of the result of GPBT without the columns identified by IREDTFNS. NOTE 138 — After the application of all Syntax Rules, MS is a <simple match statement> and thus GPBT is available here as defined by SR 5)a). « WG3:CMN-019 P00-USA-351 » 2) The current working table is set to NEW_TABLE. 3) The current execution outcome is set to a successful outcome with an omitted result. Conformance Rules « WG3:CMN-019 P00-USA-073 » 1) Without Feature GQ21, “OPTIONAL: Multiple MATCH statements”, conforming GQL language shall not contain an <optional match statement> that contains a <match statement block>. 167 IWD 39075:2023(E) "
  },
  {
    "section": "14.4",
    "title": "<match statement>",
    "text": "14.5 <call query statement> Function Execute a query. Format <call query statement> ::= <call procedure statement> Syntax Rules 1) Let CQS be the <call query statement>, let CPS be the <call procedure statement> immediately contained in CQS, and let PC be the <procedure call> immediately contained in CPS. 2) If PC is an <inline procedure call> that immediately contains the <nested procedure specification> PROC, then PROC shall immediately contain a <query specification>. 3) If PC is a <named procedure call> that immediately contains the <procedure reference> that iden- tifies a procedure PROC, then PROC shall have the QUERY PROCEDURE indication. General Rules None. Conformance Rules None. 168 IWD 39075:2023(E) "
  },
  {
    "section": "14.5",
    "title": "<call query statement>",
    "text": "14.6 <filter statement> Function Select a subset of the records of the current working table. Format <filter statement> ::= FILTER { <where clause> | <search condition> } Syntax Rules 1) Let FS be the <filter statement>. 2) If FS immediately contains the <search condition> SC, then it effectively is replaced by the <filter statement>: FILTER WHERE SC 3) Let WC be the <where clause> that is immediately contained in FS. 4) Let DTIWR be the declared type of the incoming working record of FS. 5) Let DTIWT be the declared type of the incoming working table of FS. 6) The declared type of the incoming working record of WC is DTIWR. 7) The declared type of the incoming working table of WC is DTIWT. 8) The declared type of the outgoing working record of FS is DTIWR. 9) The declared type of the outgoing working table of FS is DTIWT. 10) FS has no declared type. General Rules « WG3:CMN-019 P00-USA-351 » 1) The current working table is set to the result of WC. 2) The current execution outcome is set to a successful outcome with an omitted result. Conformance Rules 1) Without Feature GQ08, “FILTER statement”, conforming GQL language shall not contain a <filter statement>. 169 IWD 39075:2023(E) "
  },
  {
    "section": "14.6",
    "title": "<filter statement>",
    "text": "14.7 <let statement> Function Add columns to the current working table. Format <let statement> ::= LET <let variable definition list> <let variable definition list> ::= <let variable definition> [ { <comma> <let variable definition> }... ] <let variable definition> ::= <value variable definition> | <value variable> <equals operator> <value expression> Syntax Rules 1) Let LS be the <let statement>. 2) Let LVDL be the <let variable definition list> immediately contained in LS. 3) For every <let variable definition> LVD that is immediately contained in LVDL and immediately contains a <value variable>, LVD is effectively replaced by: VALUE LVD 4) Let IREDT be the declared type of the incoming working record of LS and let IREDTFNS be the set of field names of IREDT. 5) Let ITART be the record type of the declared type of the incoming working table of LS and let ITARTFNS be the set of field names of ITART. 6) Let IFNS be the union of IREDTFNS and ITARTFNS. 7) Let IBVRL be an implementation-dependent(US010) comma-separated list of all incoming <binding variable reference>s corresponding to <binding variable>s whose names are in IFNS. 8) Let the <binding variable definition block> BVDBLK be the space-separated concatenation of all <let variable definition>s immediately contained in LVDL. 9) Let the <return item list> RIL be the comma-separated list of all <value variable>s simply contained in LVDL. 10) LS is effectively replaced by: CALL (IBVRL) { BVDBLK RETURN RIL } General Rules None. 170 IWD 39075:2023(E) "
  },
  {
    "section": "14.7",
    "title": "<let statement>",
    "text": "Conformance Rules 1) Without Feature GQ09, “LET statement”, conforming GQL language shall not contain a <let state- ment>. 171 IWD 39075:2023(E) "
  },
  {
    "section": "14.7",
    "title": "<let statement>",
    "text": "14.8 <for statement> Function Provide unnesting of a list by expanding the current working table. Format <for statement> ::= FOR <for item> [ <for ordinality or offset> ] <for item> ::= <for item alias> <list value expression> <for item alias> ::= <identifier> IN <for ordinality or offset> ::= WITH { ORDINALITY | OFFSET } <identifier> Syntax Rules 1) Let FS be the <for statement>. 2) Let FI be the <for item> immediately contained in FS. 3) Let FIA be the <for item alias> immediately contained in FI. 4) Let ANAME be the canonical name form of the <identifier> immediately contained in FIA. 5) Let LVE be the <list value expression> immediately contained in FI. 6) If <for ordinality or offset> is specified, then let FOO be the <for ordinality or offset>; otherwise, let FOO be the zero-length character string. 7) The declared type of the incoming working record of LVE is the declared type of the incoming working record of FS amended with the record type of the declared type of the incoming working table of FS. 8) The declared type of the incoming working table of LVE is the material unit binding table type. 9) The declared type of the outgoing working record of FS is the declared type of the incoming working record of FS. 10) Let the character string PNAME and the closed record type NEW_FIELDS_RT be defined as follows. a) Let EFT be the field type whose name is ANAME and whose value type is the list element type of the declared type of LVE. b) Case: i) If FOO is not the zero-length character string, then: 1) PNAME is the canonical name form of the <identifier> immediately contained in FOO. 2) PNAME shall not be equal to the field name of EFT. 3) Let the value type PVT be defined as follows. 172 IWD 39075:2023(E) "
  },
  {
    "section": "14.8",
    "title": "<for statement>",
    "text": "Case: A) IfFOOimmediatelycontainsWITHORDINALITY,thenPVTistheimplemen- tation-defined (ID057) exact numeric type with scale 0 (zero) of list element ordinals. B) IfFOOimmediatelycontainsWITHOFFSET,thenPVTistheimplementation- defined(ID058)exactnumerictypewithscale0(zero)oflistelementoffsets. 4) Let PFT be the field type whose name is PNAME and whose value type is PVT. 5) The field types of NEW_FIELDS_RT comprise EFT and PFT. ii) Otherwise, PNAME is the zero-length character string and the field types of NEW_FIELDS_RT comprise EFT. 11) The declared type of the incoming working record of LVE and NEW_FIELDS_RT shall be field name- disjoint. 12) The declared type of the outgoing working table of FS is the binding table type whose record type is the record type of the declared type of the incoming working table of FS amended with NEW_FIELDS_RT. 13) FS has no declared type. General Rules 1) Let NEW_TABLE be a new binding table whose type is the declared type of the outgoing working table of FS. 2) For each record R of the current working table in a new child execution context amended with R whose working table is the empty binding table: a) Let LVER be the result of LVE. b) Let LV be the list value defined as follows. Case: i) If LVER is a list value, then LV is LVER. ii) If LVER is the null value, then LV is the empty list value. iii) Otherwise,an exceptionconditionis raised:data exception — invalidvalue type (22G03). c) Let LVLEN be the length of LV. « WG3:CMN-019 P00-NLD-050 » d) For j, 1 (one) ≤j ≤LVLEN: i) Let LRj be the record comprising a single field whose name is ANAME and whose value is the j-th element of LV. ii) Case: 1) If the <for ordinality or offset> is specified, then: A) IfFOOimmediatelycontainsWITHORDINALITY,thenletLROjbetherecord obtained by adding a field to LRj whose name is PNAME and whose value is j. 173 IWD 39075:2023(E) "
  },
  {
    "section": "14.8",
    "title": "<for statement>",
    "text": "B) If FOO immediately contains WITH OFFSET, then let LROj be the record obtained by adding a field to LRj whose name is PNAME and whose value is j−1. 2) Otherwise, let LROj be LRj. iii) Append LROj to the current working table. e) Append the Cartesian product of R and the current working table to NEW_TABLE. « WG3:CMN-019 P00-USA-351 » 3) The current working table is set to NEW_TABLE. 4) The current execution outcome is set to a successful outcome with an omitted result. Conformance Rules 1) Without Feature GQ10, “FOR statement”, conforming GQL language shall not contain a <for state- ment>. 2) Without Feature GQ11, “FOR statement: WITH ORDINALITY or WITH OFFSET”, conforming GQL language shall not contain a <for statement> that simply contains <for ordinality or offset>. 174 IWD 39075:2023(E) "
  },
  {
    "section": "14.8",
    "title": "<for statement>",
    "text": "14.9 <order by and page statement> Function Specify, for the current working table, either: the ordering of the records, the number of records to be discarded from the beginning of the table, or the maximum number of records to be retained; or any combination of these. Format <order by and page statement> ::= <order by clause> [ <offset clause> ] [ <limit clause> ] | <offset clause> [ <limit clause> ] | <limit clause> ** Editor’s Note (number 20) ** Additional support for PARTITION BY, WITH TIES, WITH OFFSET, and WITH ORDINALITY should be considered. See Language Opportunity GQL-163 . Syntax Rules 1) Let OPS be the <order by and page statement>. 2) Let DTIWR be the declared type of the incoming working record of OPS. 3) Let DTIWT be the declared type of the incoming working table of OPS. 4) The declared type of the incoming working record of any <offset clause> or <limit clause> immedi- ately contained in OPS is DTIWR. 5) The declared type of the incoming working table of any <offset clause> or <limit clause> immediately contained in OPS is DTIWT. « WG3:CMN-019 P00-USA-075 Two SRs removed » 6) OPS has no declared type. General Rules 1) Let TABLE be the current working table. 2) Let ORDERED be the binding table defined as follows. Case: a) If OPS immediately contains the <order by clause> OBC, then let ORDERED be the result of OBC. b) Otherwise, let ORDERED be TABLE. 3) Let OFFSETED be the binding table defined as follows. Case: a) If OPS immediately contains the <offset clause> OC, then let OFFSETED be the result of OC. b) Otherwise, let OFFSETED be ORDERED. 175 IWD 39075:2023(E) "
  },
  {
    "section": "14.9",
    "title": "<order by and page statement>",
    "text": "4) Let LIMITED be the binding table defined as follows. Case: a) If OPS immediately contains the <limit clause> LC, then let LIMITED be the result of LC. b) Otherwise, let LIMITED be OFFSETED. « WG3:CMN-019 P00-USA-351 » 5) The current working table is set to LIMITED. 6) The current execution outcome is set to a successful outcome with an omitted result. Conformance Rules « WG3:CMN-019 P00-USA-077 » 1) WithoutFeatureGQ12,“ORDERBYandpagestatement:OFFSETclause”,inconformingGQLlanguage, an <order by and page statement> shall not contain an <offset clause>. 2) Without Feature GQ13, “ORDER BY and page statement: LIMIT clause”, in conforming GQL language, an <order by and page statement> shall not contain a <limit clause>. 176 IWD 39075:2023(E) "
  },
  {
    "section": "14.9",
    "title": "<order by and page statement>",
    "text": ""
  },
  {
    "section": "14.10",
    "title": "<primitive result statement>",
    "text": "Function Define what to include in a query result. Format <primitive result statement> ::= <return statement> [ <order by and page statement> ] | FINISH Syntax Rules 1) Let PRS be the <primitive result statement>. 2) Let DTIWR be the declared type of the incoming working record of PRS. 3) Let DTIWT be the declared type of the incoming working table of PRS. 4) If the <return statement> RS is specified, then: a) The declared type of the incoming working record of RS is DTIWR. b) The declared type of the incoming working table of RS is DTIWT. c) Case: i) If the <order by and page statement> OPS is specified, then: 1) The declared type of the incoming working record of OPS is DTIWR. 2) Case: A) If OPS immediately contains an <order by clause> OBC, then: I) No <sort key> shall contain a <nested query specification>. II) Let RETURN_IDENTIFIERS be the set of all <identifier>s immediately contained in an explicit or implicit <return item alias> contained in RS. III) Let ORDER_REFS be the set of <binding variable reference>s defined as follows: 1) If RS does not contain a <group by clause>, a <set quantifier> DISTINCT, or any <return item> containing an <aggregate function>, then ORDER_REFS is the union of RETURN_IDENTI- FIERS and the set of <identifier>s representing all column names of DTIWT and field names of DTIWR. 2) If RS contains a <group by clause> GBC, then ORDER_REFS is the union of RETURN_IDENTIFIERS and the set of all <binding variable reference>s contained in GBC. 3) If RS does not contain a <group by clause>, but contains a <set quantifier> DISTINCT or a <return item> containing an <aggregatefunction>,thenORDER_REFSisRETURN_IDENTIFI- ERS. 177 IWD 39075:2023(E) "
  },
  {
    "section": "14.10",
    "title": "<primitive result statement>",
    "text": "IV) For every <binding variable reference> BVR contained in a <sort key> SK contained in OBC, if BVR is contained in SK without an interveninginstanceof<aggregate function>, thenORDER_REFSshall contain an identifier that is equivalent to BVR. V) If RS does not simply contain a <group by clause> or does not simply contain a <return item> containing an <aggregate function> without an intervening instance of <procedure body>, then no <sort key> contained in OBC shall contain an <aggregate function>. VI) Let RIL be the <return item list> immediately contained in RS, let CRIL be a copy of RIL, and let OB_COLS be the empty set. VII) For every <sort key> SK contained in OBC that contains an <aggregate function>: 1) Let AGG be the <value expression> immediately contained in SK. 2) Let CN be an implementation-dependent (UV013) <identifier> that is not equivalent to any other <identifier> contained in a <return item alias> simply contained in RIL. 3) Append to CRIL: , AGG AS CN 4) SK is replaced in OBC by: CN 5) LetOB_COLbea newcolumnwhosenameisthecanonicalname form of CN and whose type is the declared type of AGG. 6) OB_COL is added to OB_COLS. VIII) Forevery<bindingvariablereference>REFinORDER_REFSforwhich it holds that RETURN_IDENTIFIERS contains no element that is equivalent to REF: 1) Append to CRIL: , REF AS REF 2) LetOB_COLbea newcolumnwhosenameisthecanonicalname form of REF and whose type is the declared type of REF. 3) OB_COL is added to OB_COLS. IX) RIL is replaced by CRIL. X) Let BTT be the binding table type obtained as a copy of the declared type of the outgoing working table of OPS without any columns identified by OB_COLS. XI) The declared type of PRS and the declared type of the outgoing working table of PRS is BTT. B) Otherwise, I) The declared type of the incoming working table of OPS is the declared type of RS. 178 IWD 39075:2023(E) "
  },
  {
    "section": "14.10",
    "title": "<primitive result statement>",
    "text": "II) The declared type of PRS is the declared type of the outgoing working table of OPS. III) Thedeclared type of the outgoing working table of PRS is the declared type of the outgoing working table of OPS. ii) Otherwise, the declared type of PRS is the declared type of RS. 5) If FINISH is specified, then PRS has no declared type. General Rules 1) If the <return statement> RS is specified, then: a) The General Rules of RS are applied. NOTE 139 — If successful, this sets the current execution result to a binding table. b) If RS specifies the <order by and page statement> OPS, then: « WG3:CMN-019 P00-USA-351 » i) The current working table is set to the current execution result. ii) The General Rules of OPS are applied. iii) Let RESULT_TABLE be defined as follows. Case: 1) If OPS immediately contains an <order by clause>, then RESULT_TABLE is the binding table obtained as a copy of the current working table without any of the columns identified by OB_COLS. 2) Otherwise, RESULT_TABLE is the current working table. « WG3:CMN-019 P00-USA-351 » iv) The current execution outcome is set to a successful outcome with RESULT_TABLE as its result. « WG3:CMN-019 P00-USA-351 » 2) If FINISH is specified, then the current execution outcome is set to a successful outcome with an omitted result. Conformance Rules « WG3:CMN-019 P00-USA-077 » 1) Without Feature GQ14, “Complex expressions in sort keys”, in conforming GQL language, the <value expression> immediately contained in a <sort key> shall be a <binding variable reference>. 2) Without Feature GQ16, “Pre-projection aliases in sort keys”, in conforming GQL language, the <value expression> immediately contained in a <sort key> shall not simply contain any <binding variable reference> that is not a <return item alias> in the preceding <return statement>. 3) Without Feature GF20, “Aggregate functions in sort keys”, in conforming GQL language, the <value expression>immediately containedin a <sort key> shall not simply contain an <aggregate function>. 179 IWD 39075:2023(E) "
  },
  {
    "section": "14.10",
    "title": "<primitive result statement>",
    "text": ""
  },
  {
    "section": "14.11",
    "title": "<return statement>",
    "text": "Function Compute the binding table result of a linear statement. Format <return statement> ::= RETURN <return statement body> <return statement body> ::= [ <set quantifier> ] { <asterisk> | <return item list> } [ <group by clause> ] | NO BINDINGS <return item list> ::= <return item> [ { <comma> <return item> }... ] <return item> ::= <aggregating value expression> [ <return item alias> ] <return item alias> ::= AS <identifier> ** Editor’s Note (number 21) ** Consider allowing a single optional <where clause>. See Language Opportunity GQL-169 . Syntax Rules ** Editor’s Note (number 22) ** Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 . 1) Let RS be the <return statement>. 2) Let RSB be the <return statement body> immediately contained in RS. 3) If a <set quantifier> is not immediately contained in RSB, then ALL is the implicit <set quantifier> of RSB. 4) If a <set quantifier> DISTINCT is specified, then each <return item> RI is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations”, apply. 5) Let SQ be the explicit or implicit <set quantifier> of RSB. 6) If RSB immediately contains an <asterisk>, then: a) The declared type of the incoming working table of RS shall not be the unit binding table type. b) RSB shall not immediately contain a <group by clause>. « WG3:CMN-019 P00-NLD-050 » c) Let BVSEQ be the sequence of all column names of the declared type of the incoming working table of RS in ascending order. Let NBVSEQ be the number of such binding variables. For i, 1 (one) ≤i ≤NBVSEQ, let BVi be the i-th such binding variable in BVSEQ. 180 IWD 39075:2023(E) "
  },
  {
    "section": "14.11",
    "title": "<return statement>",
    "text": "d) For i, 1 (one) ≤i ≤NBVSEQ, let the new <return item list> NEWRIL be a comma-separated list of <return item>s: BVi AS BVi e) RS is effectively replaced by the <return statement>: RETURN SQ NEWRIL 7) Let RIL be defined as follows. Case: a) If RSB is NO BINDINGS, then SQ is ALL and RIL is the empty sequence. NOTE 140 — That is, RETURN NO BINDINGS is equivalent to RETURN ALL with an empty <return item list> and no <group by clause>. The Format does not permit an empty <return item list>, hence the need to define these values artificially. b) Otherwise, RIL is the <return item list> immediately contained in RSB. 8) For each <return item> RI in RIL: Case: a) If the <aggregating value expression> immediately contained in RI is a <binding variable ref- erence> RIBV and RI does not immediately contain a <return item alias>, then RI is effectively replaced by: RIBV AS RIBV b) Otherwise, RI shall immediately contain a <return item alias>. 9) For a given <return item> RI, let the expression of RI be the <aggregating value expression> imme- diately contained in RI and let the alias name of RI be the canonical name form of the <identifier> that is immediately contained in the explicit or implicit <return item alias> of RI. 10) Case: a) If RSB immediately contains a <group by clause> GBC: i) Let GRISET be the set of grouping <return item>s contained in RIL whose alias name is simply containedin GBC and let NGRI be the number of such<return item>s in GRISET. ii) Let ARISET be the set of aggregating <return item>s contained in RIL whose alias name is not simply contained in GBC and let NARI be the number of such <return item>s in ARISET. iii) All <return item>s shall be contained in GRISET or ARISET. iv) Let INSET be the set of all <grouping element>s simply contained in GBC that are not equal to an alias name in GRISET. Let NINSET be the number of items in INSET. v) Let GROUP_COLS be the set of columns constructed as follows: « WG3:CMN-019 P00-NLD-016 Correct error in UTC-081 » 1) For every grouping <return item> GRI in GRISET: A) Let COL be a new column whose name is the <return item alias> of GRI and whose type is the declared type of the <aggregating value expression> immediately contained in GRI. 181 IWD 39075:2023(E) "
  },
  {
    "section": "14.11",
    "title": "<return statement>",
    "text": "B) COL is included in GROUP_COLS. « WG3:CMN-019 P00-NLD-017 Correct error in UTC-081 » 2) For every <grouping element> IN in INSET: A) Let COL be a new column whose name is the <identifier> contained in IN and whose type is the declared type of the <binding variable reference> contained in IN. B) COL is included in GROUP_COLS. « WG3:CMN-019 P00-USA-078 » vi) Let GR_TABLE_TYPE be the declared type of a binding table containing all columns of GROUP_COLS. vii) Let ARI_TABLE_TYPE be the declared type of the incoming working table of RS without the fields identified by GROUP_COLS. viii) The declared type of the incoming working table of all <return item>s in ARISET is ARI_TABLE_TYPE. ix) The declared type of the incoming working record of all <return item>s in ARISET is the declared type of the incoming working record of RS amended with the record type of GR_TABLE_TYPE. b) Otherwise: i) The declared type of the incoming working table of every <return item> is the declared type of the incoming working table of RS. ii) Thedeclared type of the incomingworking record of every<return item> is the declared type of the incoming working record of RS. 11) Let RETURN_TABLE_TYPE be the declared type of a binding table defined as follows. Case: a) If RSB immediately contains an <asterisk>, then RETURN_TABLE_TYPE is the declared type of the incoming working table of RS. b) Otherwise: i) Let RETURN_COLS be the sequence of columns constructed by, for every element RI of RIL, creating a column whose name is the alias name of RI and whose declared type is the declared type of the expression of RI. ii) RETURN_TABLE_TYPE is the declared type of a material binding table whose set of columns is RETURN_COLS. 12) The declared type of the outgoing working table of RS is the material unit binding table type. 13) The declared type of the outgoing working record of RS is the declared type of the incoming working record of RS. 14) The declared type of RS is RETURN_TABLE_TYPE. General Rules « Editorial: Correct wording » « WG3:CMN-019 P00-NLD-050 » 182 IWD 39075:2023(E) "
  },
  {
    "section": "14.11",
    "title": "<return statement>",
    "text": "« WG3:CMN-019 P00-USA-207 » 1) Let TABLE be the current working table. Let N be the number of records of TABLE. For i, 1 (one) ≤ i ≤N, let Ri, be the i-th record of TABLE in the order determined by iterating over TABLE. 2) Let RETURN_TABLE be a new empty binding table of type RETURN_TABLE_TYPE. 3) Case: a) If RS immediately contains a <group by clause> GBC: « WG3:CMN-019 P00-NLD-050 » « WG3:CMN-019 P00-USA-207 » i) For i, 1 (one) ≤i ≤N, let the grouping record GRi of a record Ri of TABLE be a new record constructed as follows: « WG3:CMN-019 P00-NLD-050 » 1) For 1 (one) ≤k ≤NGRI, GRi includes field Fk such that the field name of Fk is the alias name of GRISETk and the field value of Fk is the result of the expression of GRISETk in a new child execution context amended with Ri. 2) For 1 (one) ≤j ≤NINSET, GRi includes field Gj such that the field name of Gj is the <identifier> contained in INSETj and the field value of Gj is the value in Ri of the <binding variable reference> contained in INSET. « WG3:CMN-019 P00-USA-207 » ii) Let GR_TABLE be a new binding table of type GR_TABLE_TYPE of all grouping records GRi, 1 (one) ≤i ≤N, of all records Ri of TABLE. iii) Let GROUP_BY be the result of GBC in a new child execution context with GR_TABLE as its working table. NOTE 141 — The result of GBC is obtained from the implicit invocation of the General Rules of Subclause 16.17, “<group by clause>”. iv) For each record K in GROUP_BY: « WG3:CMN-019 P00-USA-207 » 1) Let PART be a new binding table of type ARI_TABLE_TYPE comprising only the records Rj, 1 (one) ≤j ≤N, from TABLE, for which the grouping record GRj for Rj is not distinct from K, without the columns identified by GROUP_COLS. 2) Let IWR be a new record obtained as a copy of the current working record amended with GRj . 3) Let NR be a new record obtained as a copy of K without the fields identified by INSET. 4) For every <return item> ARIj in ARISET, 1 (one) ≤j ≤NARI, append a field to NR whose name is the alias name of ARIj and whose value is the result of evaluating the <aggregating value expression> of ARIj in a new child execution context with IWR as its working record and with PART as its working table. NOTE 142 — This is used to determine the result of <aggregate function>s. 5) Append NR to RETURN_TABLE. 183 IWD 39075:2023(E) "
  },
  {
    "section": "14.11",
    "title": "<return statement>",
    "text": "b) Otherwise, for each record R of TABLE in a new child execution context amended with R: i) Let S be a record defined as follows. Case: 1) If RIL is an empty sequence, then S is the unit record. 2) Otherwise, S is the record comprising a field F for every <return item> RI in RIL such that the name of F is the alias name of RI and the value of F is the result of the expression of RI. « WG3:CMN-019 P00-USA-351 » ii) S is added to RETURN_TABLE. « WG3:CMN-019 P00-USA-351 » 4) If SQ is DISTINCT, then the current working table is set to duplicate-free copy of RETURN_TABLE in which every record is distinct from every other record of RETURN_TABLE; otherwise, the current working table is set to RETURN_TABLE. « WG3:CMN-019 P00-NLD-018 Correct error in UTC-081 » 5) Let FINAL_TABLE be a new binding table of type RETURN_TABLE_TYPE obtained from the current working table by determining the preferred column name sequence to be the sequence of alias names of all <return item>s from RIL in the order of their occurrence in RIL. « WG3:CMN-019 P00-USA-351 » 6) The current working table is set to a new unit binding table. 7) The current execution outcome is set to a successful outcome with FINAL_TABLE as its result. Conformance Rules 1) Conforming GQL language shall not contain a <return statement body> that contains NO BINDINGS. NOTE 143 — A <return statement body> that contains NO BINDINGS is a specification device for use by a syntactic transformation in Subclause 14.4, “<match statement>” to specify the semantics of <optional match statement> if the latter does not supply any new output bindings and is not syntax available to the user. « WG3:CMN-019 P00-USA-077 » 2) Without Feature GA07, “Ordering by discarded binding variables”, in conforming GQL langauge, the <group by clause> immediately contained in a <return statement> shall not directly contain a <sort key> that directly contains a <binding variable reference> that is not equivalent to the <identifier> immediately contained in a <return item alias> that is directly contained in the <return statement> unless the referenced binding variable of the <binding variable reference> is defined by an intervening BNF non-terminal simply contained in the <sort key>. 184 IWD 39075:2023(E) "
  },
  {
    "section": "14.11",
    "title": "<return statement>",
    "text": ""
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "Function Provide an SQL-style query over graph data, which produces a binding table result. Format <select statement> ::= SELECT [ <set quantifier> ] { <asterisk> | <select item list> }     [ <select statement body>     [ <where clause> ]     [ <group by clause> ]     [ <having clause> ]     [ <order by clause> ]     [ <offset clause> ] [ <limit clause> ] ] <select item list> ::= <select item> [ { <comma> <select item> }... ] <select item> ::= <aggregating value expression> [ <select item alias> ] <select item alias> ::= AS <identifier> <having clause> ::= HAVING <search condition> <select statement body> ::= FROM { <select graph match list> | <select query specification> } <select graph match list> ::= <select graph match> [ { <comma> <select graph match> }... ] <select graph match> ::= <graph expression> <match statement> <select query specification> ::= <nested query specification> | <graph expression> <nested query specification> ** Editor’s Note (number 23) ** Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 . Syntax Rules 1) The Syntax Rules of this Subclause are applied before all other Syntax Rules. 2) Let SELECTSTM be the <select statement>. 3) Let NAMES_IN_USE be the set of the canonical name forms of all <identifier>s contained in the <GQL- program> that contains SELECTSTM. 4) In this Subclause, each use of the phrase freshly generated identifier stands for an implicitly generated new <regular identifier> RI that is determined as follows: 185 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "The <regular identifier>RI is an implementation-dependent (UV015) <regular identifier> whose canonical name form is not included in NAMES_IN_USE. a) b) The canonical name form of RI is added to NAMES_IN_USE. 5) If SELECTSTM does not immediately contain a <set quantifier>, then ALL is implicit. 6) Let SETQ be the explicit or implicit <set quantifier> that is immediately contained in SELECTSTM. 7) If SETQ is DISTINCT, then each <select item> immediately contained in the <select item list> immediately contained in SELECTSTM is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations”, apply. 8) LetSSB be definedas follows. If <selectstatementbody>isspecified,thenSSB isthe<selectstatement body>; otherwise, SSB is the zero-length character string. 9) If SELECTSTM immediately contains an <asterisk>, then: a) SSB shall not be the zero-length character string. b) SELECTSTM shall not immediately contain a <group by clause>. c) Let FROM_ITEMS be the set of names defined as follows. Case: i) If the <select statement body> of SELECTSTM immediately contains a <select graph match list> SGML, then FROM_ITEMSis the set of names of binding variablesreferenced by all <binding variable reference>s that are declared in <graph pattern>s directly contained in SGML without an intervening instance of (another) <graph pattern>. ii) Otherwise, the <select statement body> of SELECTSTM immediately contains a <select query specification> SQS and FROM_ITEMS is the set of column names of the declared type of the outgoing working table of the <nested query specification> immediately contained in SQS. d) Let FNSEQ be the sequence of all names of FROM_ITEMS in ascending order and let NFNSEQ be the number of such names. e) For 1 (one) ≤i ≤NFNSEQ: Let FROM_ITEMi be the i-th name in FNSEQ and let BVRi be an <identifier> whose canonical name form is FROM_ITEMi. f) Let the <select item list> NEWSIL be the comma-separated list of <select item>s defined as follows: BVR1 AS BVR1, ..., BVRNFNSEQ AS BVRNFNSEQ g) The <asterisk>immediately contained in SELECTSTM is effectively replaced by the <select item list>: NEWSIL 10) For each explicit <select item> SI immediately contained in the <select item list> immediately con- tained in SELECTSTM, Case: a) If the <aggregating value expression> immediately contained in SI is a <binding variable ref- erence> SIBVR and SI does not immediately contain a <select item alias>, then SI is effectively replaced by: SIBVR AS SIBVR 186 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "b) Otherwise, SI shall immediately contain a <select item alias>. 11) Let FILTERSTM be defined as follows. Case: a) If a <where clause> WHERECL is specified, then FILTERSTM is: FILTER WHERECL b) Otherwise, Case: i) If SSB contains the <select graph match list> SGML and if the last <select graph match> in SGML immediately contains a <match statement> that contains a <graph pattern> GP that contains a <graph pattern where clause> GPWC that is not followed by a <yield clause>, then FILTERSTM is: FILTER GPWC and GPWC is removed from GP. ii) Otherwise, FILTERSTM is the zero-length character string. 12) Let XOISIL be the list of explicit or implicit <select item>s immediately contained in SELECTSTM in the order of their appearance, let XOISISET be the set of <select item>s in XOISIL, let XOISIASEQ be the sequence of <identifier>s immediately contained in <select item alias>es in XOISIL, and let NUM_SIS be the number of elements of XOISIL. 13) Let AGGREGATING_ITEMS be the set of all <select item>s in XOISISET that directly contain an <aggregate function> and let NUM_AGGREGATING be the number of elements of AGGREGAT- ING_ITEMS. 14) Letthe<groupbyclause>GROUP_BYandthesetof<returnitem>sGKRISETbedeterminedasfollows. Case: a) If SELECTSTM immediately contains a <group by clause> GBC that does not simply contain an <empty grouping set>, then: i) Let GEL be the <grouping element list> immediately contained in GBC. ii) Let NUM_GE be the number of elements of GEL. iii) For 1 (one) ≤j ≤NUM_GE: « WG3:CMN-019 P00-USA-080 » 1) Let GEj be the j-th <grouping element> contained in GEL. 2) Let GEIDj be a freshly generated identifier. 3) The following <return item> is added to GKRISET: GEj AS GEIDj « WG3:CMN-019 P00-USA-081 » iv) GROUP_BY is: GROUP BY GE1, ..., GENUM_GE 187 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "b) Otherwise, GROUP_BY is the zero-length character string and GKRISET is the empty set. 15) Let NONAGGREGATING_ITEMS be the set of <select item>s determined as follows: a) Initially, NONAGGREGATING_ITEMS is the empty set. b) For every <select item> SI in XOISISET not included in AGGREGATING_ITEMS, Case: i) If GKRISET is not empty, then: 1) Let COSI be a copy of SI with every simply contained <binding variable reference> that is a <value expression> of a <return item> RI in GKRISET replaced with the <identifier> immediately contained in the <return item alias> immediately con- tained in RI. 2) COSI is added to NONAGGREGATING_ITEMS ii) Otherwise, SI is added to NONAGGREGATING_ITEMS. 16) Let the set of <return item>s SARISET be determined as follows. Case: a) If SELECTSTM immediately contains an <order by clause> OBC, then: i) Initially, SARISET is the empty set. ii) For every <sort key> SK simply contained in OBC that directly contains an <aggregate function>: 1) Let OBVE be the <value expression> immediately contained in SK. 2) Let OBVEID be a freshly generated identifier. 3) The following <return item> is added to SARISET: OBVE AS OBVEID b) Otherwise, SARISET is the empty set. 17) Let the sets of <return item>s ARISET and PARISET be determined as follows. Case: a) If AGGREGATING_ITEMS is not the empty set, then: i) Initially, both ARISET and PARISET are the empty set. ii) For 1 (one) ≤k ≤NUM_AGGREGATING: 1) Let ITEMk be the k-th element of AGGREGATING_ITEMS. 2) ITEMk shall immediately contain a <select item alias>. Let ITEM_ALIASk be the <identifier> immediately contained in that <select item alias>. 3) Let ITEM_EXPRk be the <value expression> immediately contained in ITEMk. 4) Let ITEM_IDk be a freshly generated identifier. 5) The following <return item> is added to ARISET: ITEM_EXPRk AS ITEM_IDk 188 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "6) The following <return item> is added to PARISET: ITEM_IDk AS ITEM_ALIASk b) Otherwise, both ARISET and PARISET are the empty set. 18) Let the set of <return item>s HARISET and the <filter statement> HAVING_FILTER be defined as follows. Case: a) If SELECTSTM immediately contains a <having clause> HC, then: i) Let HCCOND be the <search condition> immediately contained in HC. ii) Let HCBVE be the <boolean value expression> immediately contained in HCCOND. iii) Let HCID be a freshly generated identifier. iv) HARISET is the set comprising the <return item>: HCBVE AS HCID v) HAVING_FILTER is: FILTER WHERE HCID b) Otherwise, HARISET is the empty set and HAVING_FILTER is the zero-length character string. 19) Let LET_ITEMS be determined as follows. Case: a) If XOISISET does not directly contain an <aggregate function> and SELECTSTM immediately contains an <order by clause> LOBC that directly contains a <sort key> that is not a <binding variable reference> and does not contain an <aggregate function>: i) Initially, LET_ITEMS is the empty set. ii) For every <sort key> LSK directly contained in LOBC that is not a <binding variable reference> and that does not contain an <aggregate function>: 1) Let LET_IDENT be a freshly generated identifier. 2) Let LET_EXPR be the <value expression> immediately contained in LSK. 3) The following <let variable definition> is added to LET_ITEMS: LET_IDENT = LET_EXPR b) Otherwise, LET_ITEMS is the empty set. 20) Let LETSTM be defined as follows. Case: a) If LET_ITEMS is not empty, then: i) Let NUM_LET_ITEMS be the number of elements in LET_ITEMS. « WG3:CMN-019 P00-NLD-050 » ii) For l, 1 (one) ≤l ≤NUM_LET_ITEMS, let LET_ITEMl be the l-th element of LET_ITEMS. 189 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "iii) LETSTM is the <let statement>: LET LET_ITEM1, ..., LET_ITEMNUM_LET_ITEMS b) Otherwise, LETSTM is the zero-length character string. 21) IfSELECTSTMimmediatelycontainsa<selectitemlist>thatdirectlycontainsan<aggregatefunction> or if SELECTSTM immediately contains a <group by clause> that does not simply contain an <empty grouping set>, then for every <sort key> SESK directly contained in SELECTSTM, Case: a) If SESK is a <binding variable reference> SEBVR, then SEBVR shall be equivalent to an <iden- tifier> that is immediately contained in a <select item alias> directly contained in SELECTSTM or a <regular identifier> that is a <grouping element> directly contained in SELECTSTM. b) Otherwise, for every <binding variable reference> OSEBVR that is directly contained in SESK, OSEBVR shall be equivalent to a <grouping element> of a <group by clause> immediately contained in SELECTSTM. 22) Let ORDER_BY be defined as follows. Case: a) If SELECTSTM immediately contains an <order by clause> OIOBC, then: i) Let OISEQ be the sequence determined as follows. 1) Initially, OISEQ is the empty sequence. 2) For every <sort key> OISK simply contained in OIOBC, Case: A) If SARISET is not the empty set and OISK directly contains an <aggregate function>, then the <identifier> immediately contained in the <return item alias> immediately contained in a <return item> in ARISET whose <value expression> is OISK is added to OISEQ. B) If GKRISET is not the empty set and OISK is not a <binding variable refer- ence>, then: I) Let COOISK be a copy of OISK in which all simply contained <binding variable reference>s that are the <value expression> of a <return item>OIRIinGKRISETarereplacedwiththe<identifier>immediately contained in the <return item alias> immediately contained in OIRI. II) COOISK is added to OISEQ. C) If LET_ITEMS is not the empty set and OISK is a <value expression> imme- diately contained in a <let variable definition> OILVD, then the <value variable> immediately contained in OILVD is added to OISEQ. D) Otherwise, OISK is added to OISEQ. ii) Let NUM_OIS be the number of elements of OISEQ. « WG3:CMN-019 P00-NLD-050 » iii) For m, 1 ≤m ≤NUM_OIS, let OIm be the m-th element of OISEQ. iv) ORDER_BY is the comma-separated concatenation of the elements of OISEQ: 190 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "OI1, ..., OINUM_OIS b) Otherwise, ORDER_BY is the zero-length character string. 23) Let RETURN_FIRST be defined as follows. Case: a) If AGGREGATING_ITEMS is not empty, then: i) Let FIRST_ITEMS be the union of GKRISET, SARISET, ARISET, and HARISET. ii) Let NUM_FIRST be the number of elements of FIRST_ITEMS. « WG3:CMN-019 P00-NLD-050 » iii) Let FSTRIL be a permutation of FIRST_ITEMS. For p, 1 ≤p ≤NUM_FIRST, let FIRST_ITEMp be the p-th element of FSTRIL. iv) RETURN_FIRST is the comma-separated concatenation of the elements of FIRST_ITEMS: FIRST_ITEM1, ..., FIRST_ITEMNUM_FIRST.  b) Otherwise, RETURN_FIRST is the zero-length character string. 24) Let RETURN_LAST be defined as follows. a) Let LAST_ITEMS be the union of NONAGGREGATING_ITEMS and PARISET. b) For q, 1 ≤q ≤NUM_SIS, let LAST_ITEMq be defined as follows: i) Let ALIAS be the q-th element of XOISIASEQ. ii) LAST_ITEMq is the element of LAST_ITEMS whose <return item alias> immediately contains an <identifier> that is equivalent to ALIAS. c) RETURN_LAST is the comma-separated concatenation of the elements of LAST_ITEMS: LAST_ITEM1, ..., LAST_ITEMNUM_SIS 25) Let OFFCL be defined as follows. If <offset clause> is specified, then OFFCL is the <offset clause>; otherwise, OFFCL is the zero-length character string. 26) Let LIMCL be defined as follows. If <limit clause> is specified, then LIMCL is the <limit clause>; otherwise, LIMCL is the zero-length character string. 27) Let BODY be defined as follows. Case: a) If SSB immediately contains the <select graph match list> SGML, then: i) Let NUM_SGMS be the number of <select graph match>es immediately contained in SGML. ii) For r, 1 (one) ≤r ≤NUM_SGMS: 1) Let SGMr be the r-th <select graph match> in SGML. 2) Let GREXPr be the <graph expression> immediately contained in SGMr. 3) Let MATCHSTMr be the <match statement> immediately contained in SGMr. 191 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "iii) BODY is: USE GREXP1 MATCHSTM1 ... USE GREXPNUM_SGMS MATCHSTMNUM_SGMS b) If SSB immediately contains the <select query specification> SQS, then: i) Let NQS be the <nested query specification> immediately contained in SQS. ii) Case: 1) If SQS immediately contains a <graph expression>, then NQS shall simply contain an <ambient linear query statement>. 2) Otherwise, SQS does not immediately contain a <graph expression> and NQS shall simply contain a <focused linear query statement>. iii) Let USECL be defined as follows. Case: 1) If SQS immediately contains a <graph expression> GREXP, then USECL is: USE GREXP 2) Otherwise USECL is the zero-length character string. iv) BODY is: USECL CALL NQS c) Otherwise, BODY is the zero-length character string. 28) After the application of all preceding Syntax Rules, Case: a) If BODY is the zero-length character string, then SELECTSTM is equivalent to: RETURN SETQ XOISIL and no further Syntax Rules of this Subclause are applied. b) Otherwise: i) Let REPLACEMENT be determined as follows: 1) Initially, REPLACEMENT is: BODY FILTERSTM 2) If RETURN_FIRST is not the zero-length character string, then the following is appended to REPLACEMENT: RETURN SETQ RETURN_FIRST GROUP_BY NEXT 3) The following is appended to REPLACEMENT: 192 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "HAVING_FILTER LETSTM RETURN SETQ RETURN_LAST ORDER_BY OFFCL LIMCL ii) SELECTSTM is effectively replaced by REPLACEMENT. General Rules None. Conformance Rules « WG3:CMN-019 P00-USA-077 » 1) Without Feature GA07, “Ordering by discarded binding variables”, in conforming GQL langauge, the <group by clause> immediately contained in a <select statement> shall not directly contain a <sort key> that directly contains a <binding variable reference> that is not equivalent to the <identifier> immediately contained in a <select item alias> that is directly contained in the <select statement> unless the referenced binding variable of the <binding variable reference> is defined by an intervening BNF non-terminal simply contained in the <sort key>. « WG3:CMN-019 P00-USA-083 » 2) Without Feature GQ14, “Complex expressions in sort keys”, in conforming GQL langauge, the <value expression> immediately contained in a <sort key> shall be a <binding variable reference>. 3) Without Feature GQ15, “GROUP BY clause”, conforming GQL language shall not contain a <group by clause>. « WG3:CMN-019 P00-USA-077 » 4) Without Feature GQ16, “Pre-projection aliases in sort keys”, in conforming GQL langauge, the <value expression> immediately contained in a <sort key> shall not simply contain a <binding variable reference> that is not a <return item alias> in the preceding <return statement>. 193 IWD 39075:2023(E) "
  },
  {
    "section": "14.12",
    "title": "<select statement>",
    "text": "15 Common statements and related elements 15.1 <call procedure statement> and <procedure call> Function Execute a procedure. Format <call procedure statement> ::= [ OPTIONAL ] CALL <procedure call> <procedure call> ::= <inline procedure call> | <named procedure call> ** Editor’s Note (number 24) ** Consider allowing <where clause>. See Language Opportunity GQL-169 . ** Editor’s Note (number 25) ** Consider adding standalone calls. A standalone call is a syntax shorthand for a <call procedure statement> that implies YIELD * RETURN * and that can only occuras valid singular(orperhaps last) top-level statement executed by a procedure. Standalone calls could be added by following existing syntactic precedence from Cypher or by introducing completely new syntax. See Language Opportunity GQL-168 . Syntax Rules 1) Let CPS be the <call procedure statement>. 2) Let PC be the <procedure call> immediately contained in CPS. 3) Let the record type IREDT be the declared type of the incoming working record of CPS. 4) Let ITART be the record type of the declared type of the incoming working table of CPS. 5) Let IREDTPC be IREDT amended by ITART. 6) The declared type of the incoming working record of PC is IREDTPC. 7) The declared type of the incoming working table of PC is the material unit binding table type. 8) Let OTARTPC be defined as follows. Case: a) If PC is the <named procedure call> NPC and NPC has a declared type, then OTARTPC is the record type of the declared type of NPC. 194 IWD 39075:2023(E) b) If PC is the <inline procedure call> IPC and IPC has a declared type, then OTARTPC is the record type of the declared type of IPC. c) Otherwise, OTARTPC is the material unit record type. 9) ITART and OTARTPC shall be field name-disjoint. 10) Let OTART be ITART amended with OTARTPC. « WG3:CMN-019 P00-NLD-019 » 11) The declared type of the outgoing working record of CPS is IREDT. 12) The declared type of the outgoing working table of CPS is the binding table type whose record type is OTART. 13) CPS has no declared type. General Rules 1) Let TABLE be the current working table. 2) Let NEW_TABLE be a new empty binding table. 3) For each record R of TABLE in a new child execution context amended with R: a) The General Rules of PC are applied. b) Let RESULT be a new binding table defined as follows. Case: i) If the current execution result is a binding table, then RESULT is the current execution result. ii) Otherwise, the current execution result is omitted and RESULT is a unit binding table. c) If CPS immediately contains OPTIONAL, then Case: « WG3:CMN-019 P00-USA-366 » i) If RESULT is an empty binding table, then: 1) Let NULLS be a new record of type RTPC such that every field value is null. 2) Let NR be R amended with NULLS. 3) NR is appended to NEW_TABLE. ii) Otherwise, the Cartesian product of R and RESULT is appended to NEW_TABLE. « WG3:CMN-019 P00-USA-351 » 4) The current working table is set to NEW_TABLE. 5) The current execution outcome is set to a successful outcome with an omitted result. Conformance Rules None. 195 IWD 39075:2023(E) "
  },
  {
    "section": "15.1",
    "title": "<call procedure statement> and <procedure call>",
    "text": "15.2 <inline procedure call> Function Execute a procedure that is specified inline. Format <inline procedure call> ::= [ <variable scope clause> ] <nested procedure specification> <variable scope clause> ::= <left paren> [ <binding variable reference list> ] <right paren> <binding variable reference list> ::= <binding variable reference> [ { <comma> <binding variable reference> }... ] Syntax Rules 1) Let IPC be the <inline procedure call>. 2) Let PROC be the <nested procedure specification> that is immediately contained in IPC. 3) If <variable scope clause> is not specified, then: a) Let FNL be a comma-separated list of all the field names of the declared type of the incoming working record of IPC. b) IPC is effectively replaced by: (FNL) PROC 4) Let VSC be the <variable scope clause> immediately contained in IPC. 5) Let BVRLN be defined as follows: a) If VSC immediately contains a <binding variable reference list> BVRL, then: i) BVRLN is the sequence of names of the binding variables referenced by the <binding variable reference>s immediately contained in BVRL. ii) BVRLN shall not contain two equal names at different positions. « WG3:CMN-019 P00-NLD-060 » b) Otherwise, BVRLN is the empty sequence. 6) The declared type of the incoming working record of PROC is the declared type of the incoming working record of IPC without the field types not identified by BVRLN. 7) The declared type of the incoming working table of PROC is the declared type of the incoming working table of IPC. 8) The declared type of the outgoing working record of IPC is the declared type of the outgoing working record of PROC. 9) The declared type of the outgoing working table of IPC is the declared type of the outgoing working table of PROC. 10) The declared type of IPC is the declared type of PROC. 196 IWD 39075:2023(E) "
  },
  {
    "section": "15.2",
    "title": "<inline procedure call>",
    "text": "General Rules 1) Let R be the current working record without the fields not identified by BVRLN. « WG3:CMN-019 P00-USA-351 » 2) The current working record is set to R. 3) The General Rules of PROC are applied. 4) The outcome of IPC is the outcome of PROC. Conformance Rules 1) Without Feature GP01, “Inline procedure”, conforming GQL language shall not contain an <inline procedure call>. 2) Without Feature GP02, “Inline procedure with implicit nested variable scope”, in conforming GQL language, an <inline procedure call> shall contain a <variable scope clause>. 3) Without Feature GP03, “Inline procedure with explicit nested variable scope”, in conforming GQL language, an <inline procedure call> shall not contain a <variable scope clause>. 197 IWD 39075:2023(E) "
  },
  {
    "section": "15.2",
    "title": "<inline procedure call>",
    "text": "15.3 <named procedure call> Function Execute a named procedure. ** Editor’s Note (number 26) ** Bindings for host languages should eventually be defined. See Language Opportunity GQL-003 . Format <named procedure call> ::= <procedure reference> <left paren> [ <procedure argument list> ] <right paren>     [ <yield clause> ] <procedure argument list> ::= <procedure argument> [ { <comma> <procedure argument> }... ] <procedure argument> ::= <value expression> Syntax Rules 1) Let NPC be the <named procedure call> and let PROC be the procedure identified by the <procedure reference> that is immediately contained in NPC. 2) Let PROCDESC be the named procedure descriptor of PROC. 3) Let PARAMS be the list of procedure parameters of PROCDESC, let PARAMSMIN be the number of procedure parameters required by PROCDESC and let PARAMSMAX be the maximum number of procedure parameters allowed by PROCDESC. 4) Let ARGEXPS be the sequence of all <value expression>s that are simply contained in NPC in the order of their occurrence in NPC from left to right and let NUMARGS be the number of such elements in ARGEXPS. 5) NUMARGS shall be greater than or equal to PARAMSMIN. 6) NUMARGS shall be less than or equal to PARAMSMAX. « WG3:CMN-019 P00-USA-087 » 7) For i, 1 (one) ≤i ≤NUMARGS: a) Let ARGEXPi be the i-th element of ARGEXPS. b) Let PTi be the declared type of the i-th element of PARAMS. c) The Syntax Rules of Subclause 22.1, “Store assignment”, are applied with a transient site of type PTi as TARGET and ARGEXPi as VALUE. 8) If NPC immediately contains a <yield clause>, then the procedure result type of PROCDESC shall be a binding table type. 9) The declared type of NPC is the procedure result type of PROCDESC. 198 IWD 39075:2023(E) "
  },
  {
    "section": "15.3",
    "title": "<named procedure call>",
    "text": "General Rules « WG3:CMN-019 P00-NLD-050 » 1) For i, 1 (one) ≤i ≤PARAMSMAX, let ARGVALi be defined as follows. Case: a) If i ≤NUMARGS, then ARGVALi is the result of ARGEXPi. b) Otherwise, ARGVALi is the default value of the i-th element of PARAMS. « WG3:CMN-019 P00-NLD-050 » 2) For i, 1 (one) ≤i ≤PARAMSMAX, let R be a new record comprising fields Fi defined as follows: a) Let Ti be the declared type of the i-th element of PARAMS. b) Let TS be a transient site of type Ti. The General Rules of Subclause 22.1, “Store assignment”, are applied with TS as TARGET and ARGVALi as VALUE. Let TSVi be the value of TS. c) The field name of Fi is the procedure parameter name of the i-th element of PARAMS and the field value of Fi is TSVi. 3) The following steps are performed in a new child execution context with R as its working record: a) Execute PROC. b) Let RESULT be the result returned from the successful execution of PROC. c) The current execution outcome is set as follows. Case: i) If a <yield clause> YC is specified, then: 1) The General Rules of YC are applied; let YIELD be the result returned from the application of these General Rules. « WG3:CMN-019 P00-USA-351 » 2) The current execution outcome is set to a successful outcome with YIELD as its result. « WG3:CMN-019 P00-USA-089 » ii) Otherwise, set the current execution outcome to a successful outcome with RESULT as its result. Conformance Rules 1) Without Feature GP04, “Named procedure calls”, conforming GQL Language shall not contain a <named procedure call>. 2) Without Feature GP09, “Graphs as procedure arguments”, in conforming GQL language, the declared typeofa <valueexpression>immediatelycontainedina <procedureargument>shallnotbea graph reference value type. 3) Without Feature GP08, “Binding tables as procedure arguments”, in conforming GQL language, the declared type of a <value expression> immediately contained in a <procedure argument> shall not be a binding table reference value type. 199 IWD 39075:2023(E) "
  },
  {
    "section": "15.3",
    "title": "<named procedure call>",
    "text": "16 Common elements 16.1 <use graph clause> Function Declare a working graph and its scope. Format <use graph clause> ::= USE <graph expression> Syntax Rules 1) Let UGC be the <use graph clause>. 2) Let GE be the <graph expression> simply contained in UGC. 3) Let PART be the instance of the BNF non-terminal that immediately contains UGC. 4) The scope clause of UGC is Case: a) If PART is simply contained in a <focused linear query statement> FLQS, then FLQS. b) If PART is simply contained in a <focused linear data-modifying statement> FLDMS, then FLDMS. 5) The scope of G comprises Case: a) If PART is a <focused linear query statement part>, then the <simple linear query statement> immediately contained in PART. b) If PART is a <focused linear query and primitive result statement part>, then the <simple linear query statement> and the <primitive result statement> immediately contained in PART. c) If PART is a <focused primitive result statement>, then the <primitive result statement> immediately contained in PART. d) If PART is a <focused nested query specification>, then the <nested query specification> immediately contained in PART. e) If PART is a <focused linear data-modifying statement body>, then the <simple linear query statement>, the <simple data-modifying statement>, the <simple linear data-accessing state- ment>, and the <primitive result statement> immediately contained in PART. f) If PART is a <focused nested data-modifying procedure specification>, then the <nested data- modifying procedure specification> immediately contained in PART. 6) UGC declares GE as a working graph. 200 IWD 39075:2023(E) General Rules None. Conformance Rules 1) WithoutFeature GQ01,“USE graph clause”, conformingGQLlanguage shallnot containa <usegraph clause>. 201 IWD 39075:2023(E) "
  },
  {
    "section": "16.1",
    "title": "<use graph clause>",
    "text": "16.2 <at schema clause> Function Declare a working schema and its scope. Format <at schema clause> ::= AT <schema reference> Syntax Rules 1) Let ASC be the <at schema clause>. 2) Let S be the GQL-schema identified by the <schema reference> that is immediately contained in ASC. 3) Let PB be the <procedure body> immediately containing ASC. 4) The scope clause of ASC is PB. 5) The scope of S comprises PB. 6) ASC declares S as a working schema. General Rules None. Conformance Rules None. 202 IWD 39075:2023(E) "
  },
  {
    "section": "16.2",
    "title": "<at schema clause>",
    "text": "16.3 <binding variable reference> Function Specify binding variable references. Format <binding variable reference> ::= <binding variable> Syntax Rules 1) Let BVR be the <binding variable reference>. 2) BVR specifies a binding variable reference. 3) Let BV be the <binding variable> immediately contained in BVR. 4) The referenced binding variable of BVR is the binding variable identified by BVR. NOTE 144 — See Subclause 21.2, “Names and variables”. 5) The name of BVR is the name of the referenced binding variable of BVR. 6) Let BVN be the name of BVR. 7) Let IREDT be the declared type of the incoming working record of BVR. 8) IREDT shall have a field type whose field name is BVN. Let BVFT be that field type. NOTE 145 — The field value type of the incoming working record corresponding to a referenced binding variable ABV of a <binding variable reference> that is declared by a <graph pattern> AGP is defined by SR 25) of Subclause 16.7, “<graph pattern binding table>” to be the same as the projected field type of the <binding variable reference> to ABV in the <graph pattern yield clause> of AGP. See SR 13), for the definition of projected field type. 9) The declared type of BVR is the value type of BVFT. 10) The binding graph pattern of BVR is defined, if existing, as the innermost <graph pattern> GP for which it holds that: a) GP declares an <element variable> or a <path variable> equivalent to BV. b) At least one of the following holds: i) BVR is simply contained in the <graph pattern where clause> of GP. ii) BVR is contained in a <parenthesized path pattern where clause> simply contained in GP. 11) The degree of reference of BVR is defined as follows. Case: a) If the binding graph pattern GP of BVR is defined and declares an <element variable> EV equivalent to BV, then Case: 203 IWD 39075:2023(E) "
  },
  {
    "section": "16.3",
    "title": "<binding variable reference>",
    "text": "i) If BVR is simply contained in the <graph pattern where clause> of GP, then the degree of reference of BVR is the degree of exposure of EV by GP. NOTE 146 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and Subclause 16.10, “<path pattern expression>”. ii) If BVR is contained in a <parenthesized path pattern where clause> PPPWC simply contained in GP, then let PPPE be the <parenthesized path pattern expression> that simply contains PPPWC. NOTE 147 — This rule is applied after the syntactic transform that converts any <element pattern where clause> to a <parenthesized path pattern where clause>. Case: 1) If EV is declared by PPPE, then the degree of reference of BVR is the degree of exposure of EV by PPPE. NOTE 148 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and Subclause 16.10, “<path pattern expression>”. 2) Otherwise, let PP be the innermost <graph pattern> or <parenthesized path pat- tern expression> that contains PPPWC and that declares EV. The degree of refer- ence of BVR is the degree of exposure of EV by PP. The degree of reference of BVR shall be singleton. NOTE 149 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and Subclause 16.10, “<path pattern expression>”. b) If the binding graph pattern GP of BVR is defined and declares a <path variable> PV equivalent to BV, then the degree of reference of BVR is unconditional singleton. c) Otherwise, the degree of reference of BVR is defined as follows. Case: i) If the declared type of BVR is a group list value type or a dynamic union type whose component types are group list value types, then BVR has group degree of reference. ii) Otherwise, the declared type of BVR is not a group list value type and Case: 1) If the declared type of BVR is material, then the degree of reference of BVR is unconditional singleton. 2) Otherwise, the declared type of BVR is nullable and the degree of reference of BVR is conditional singleton. 12) Let DEG be the degree of reference of BVR. If DEG is not singleton, then DEG shall be effectively bounded group and the declared type of BVR shall be a group list value type. 13) If the binding graph pattern GP of BVR is defined, then the projected field type PFT of BVR is the field type whose name is BVN and whose value type is determined as follows: Case: a) If GP declares an <element variable> equivalent to BVN, then Case: i) If DEG is unconditional singleton, then the value type of PFT is a value type that is determinedusing an implementation-defined(IW011)mechanismsuchthat it contains 204 IWD 39075:2023(E) "
  },
  {
    "section": "16.3",
    "title": "<binding variable reference>",
    "text": "every reference value of a graph element to which BV can be bound by the evaluation of GP. ii) If DEG is conditional singleton, then the value type of PFT is a value type that is determinedusing an implementation-defined(IW011)mechanismsuchthat it contains every reference value of a graph element to which BV can be bound by the evaluation of GP and the null value. iii) Otherwise, DEG is group and the value type of PFT is determined using an implemen- tation-defined (IW011) mechanism such that: 1) The value type of PFT is either a group list value type or a dynamic union type whose component types are group list value types. 2) The value type of PFT contains every list of reference values to a graph element to which BV can be bound by the evaluation of GP. b) Otherwise, GP declares a <path variable> equivalent to BVN and the value type of PFT is the path value type. General Rules 1) Let F be the field of the current working record whose field name is BVN. 2) Let FV be the field value of F. 3) If the degree of reference of BVR is group and FV is not either a list value or the null value, then an exception condition is raised: data exception — invalid group variable value (22G13). 4) The result of BVR is FV. NOTE 150 — Every <binding variable reference> is evaluated by looking it up in the current working record. The referenced binding variable of a <binding variable reference> declared by a <graph pattern> is bound in the Subclause 22.6, “Application of bindings to evaluate an expression”. Conformance Rules 1) Without Feature GP07, “Procedure-local graph variable definitions”, in conforming GQL language, the declared type of a <binding variable reference> shall not be a graph reference value type. 2) Without Feature GP06, “Procedure-local binding table variable definitions”, in conforming GQL language, the declared type of a <binding variable reference> shall not be a binding table reference value type. 205 IWD 39075:2023(E) "
  },
  {
    "section": "16.3",
    "title": "<binding variable reference>",
    "text": "16.4 <element variable reference> Function Specify element variable references. Format <element variable reference> ::= <binding variable reference> Syntax Rules 1) Let EVR be the <element variable reference>. 2) Let EVRDT be the declared type of EVR. 3) Case: a) If the degree of reference of EVR is singleton, then EVRDT shall be a node reference value type or an edge reference value type. b) Otherwise, the degree of reference of EVR is group and EVRDT shall be a group list value type whose list element type only includes node reference values, edge reference values, or the null value. General Rules None. NOTE 151 — Every <element variable reference> is evaluated in the General Rules of Subclause 16.3, “<binding variable reference>” by looking it up in the current working record or the current working schema. However the actual element variable reference value is originally constructed and bound in the General Rules of Subclause 22.6, “Application of bindings to evaluate an expression”. Conformance Rules None. 206 IWD 39075:2023(E) "
  },
  {
    "section": "16.4",
    "title": "<element variable reference>",
    "text": "16.5 <path variable reference> Function Specify path variable references. Format <path variable reference> ::= <binding variable reference> Syntax Rules 1) Let PVR be the <path variable reference>. 2) The degree of reference of PVR shall be unconditional singleton. 3) The declared type of PVR shall be a path value type. General Rules None. NOTE 152 — Every <path variable reference> is evaluated in the General Rules of Subclause 16.3, “<binding variable reference>” by looking it up in the current working table. However the actual path value is originally constructedandboundintheGeneralRulesofSubclause22.6,“Applicationofbindingstoevaluateanexpression”. Conformance Rules None. 207 IWD 39075:2023(E) "
  },
  {
    "section": "16.5",
    "title": "<path variable reference>",
    "text": "16.6 <parameter> Function Specify parameters. Format <parameter> ::= <parameter name> Syntax Rules « Editorial: Define symbol P » 1) LetPbe<parameter>.LetPNbethenamespecifiedbythe<parametername>immediatelycontained in P. 2) Case: a) If there is a request parameter RP with parameter name PN in the current request context, then P identifies RP and the declared type of P is the value type of the parameter value of RP. b) If there is a session parameter SP with parameter name PN in the current session context, then P identifies SP and the declared type of P is the value type of the parameter value of SP. c) Otherwise, an exception condition is raised: syntax error or access rule violation — invalid reference (42002). 3) The result of P is the parameter value of the parameter identified by P. NOTE 153 — The result of P is determinedfrom the GQL-requestbefore regular executionand is available during the evaluation of Syntax Rules. General Rules None. Conformance Rules 1) Without Feature GE04, “Graph parameters”, in conforming GQL language, the declared type of a <parameter> shall not be a graph reference value type. 2) Without Feature GE05, “Binding table parameters”, in conforming GQL language, the declared type of a <parameter> shall not be a binding table reference value type. 208 IWD 39075:2023(E) "
  },
  {
    "section": "16.6",
    "title": "<parameter>",
    "text": "16.7 <graph pattern binding table> Function Evaluate a <graph pattern> to a binding table. Format <graph pattern binding table> ::= <graph pattern> [ <graph pattern yield clause> ] <graph pattern yield clause> ::= YIELD <graph pattern yield item list> <graph pattern yield item list> ::= <graph pattern yield item> [ { <comma> <graph pattern yield item> }... ] | NO BINDINGS <graph pattern yield item> ::= <element variable reference> | <path variable reference> Syntax Rules 1) Let GPBT be the <graph pattern binding table> and let GP be the <graph pattern> simply contained in GPBT. 2) Every variable in the scope of GP is also in the scope of the <graph pattern yield clause> simply contained in GPBT. 3) Let EVSET be the set of names of element variable declared by GP, let PVSET be the set of names of path variables declared by GP, and let GPVARS be a permutation of EVSET ∪PVSET in the order of their first occurrence as an <element variable declaration> or a <path variable declaration>, respectively, that is simply contained in GP. Let SPVSET be the set of names of subpath variables declared by GP. ** Editor’s Note (number 27) ** Handling of subpath variables to be decided. See Language Opportunity GQL-194 . 4) Each graph pattern variable name in GPVARS shall identify exactly one graph pattern variable in GP at the same depth of graph pattern matching. 5) Let GLOBALS be GPVARS restricted to the names of graph pattern variables in the scope of GP. 6) Let IREDT be the declared type of the incoming working record of GPBT. 7) IREDT shall not contain a field whose name is in SPVSET. 8) Let ITART be the record type of the declared type of the incoming working table of GPBT. 9) ITART shall not contain a field whose name is in SPVSET. 10) Let RECORD_OVERLAP be GLOBALS restricted to the names of fields of IREDT, let TABLE_OVERLAP be GLOBALS restricted to the names of fields of ITART, and let OVERLAP be the concatenation of RECORD_OVERLAP with TABLE_OVERLAP. 11) The sequence of variable names XGPYCVARS is defined as follows. 209 IWD 39075:2023(E) "
  },
  {
    "section": "16.7",
    "title": "<graph pattern binding table>",
    "text": "Case: a) If an explicit <graph pattern yield clause> XGPYC is specified, then XGPYCVARS is the sequence of names of variables identifiedby instances of <binding variable reference>s simply contained in XGPYC. « WG3:CMN-019 P00-NLD-060 » b) Otherwise, XGPYCVARS is the empty sequence. 12) Case: a) If the length of XGPYCVARS is at least 1 (one), then: i) XGPYCVARS shall not contain two equal names at different positions. ii) Every name in XGPYCVARS shall be contained in GLOBALS. iii) Let OGPYCVARS be OVERLAP without the names contained in XGPYCVARS. iv) Let GPYIL be the comma-separated list of the elements of the concatenation of OGPYCVARS with XGPYCVARS. v) XGPYC is equivalent to: YIELD GPYIL « WG3:CMN-019 P00-NLD-060 » b) Otherwise, XGPYCVARS is the empty sequence. Case: i) If GLOBALS is empty, then the implicit <graph pattern yield clause> of GPBT is: YIELD NO BINDINGS ii) Otherwise,GLOBALSisnotempty.LetGPYILbethecomma-separatedlistoftheelements of GLOBALS. The implicit <graph pattern yield clause> of GPBT is: YIELD GPYIL 13) Let GPYC be the explicit or implicit <graph pattern yield clause> after the application of SR 12). « WG3:CMN-019 P00-USA-091 » 14) Let GPYCREFS be defined as follows: Case: « WG3:CMN-019 P00-NLD-060 » a) If GPYC is YIELD NO BINDINGS, then GPYCREFS is the empty sequence. b) Otherwise, GPYCREFS is the sequence of <binding variable reference>s simply contained in GPYC. NOTE 154 — This is restricted to variable names from GLOBALS, i.e., in particular contains no names of subpath variables declared by GP. 15) The binding graph pattern of each <binding variable reference> in GPYCREFS shall be GP. NOTE 155 — See SR 10) of Subclause 16.3, “<binding variable reference>”, for the definition of binding graph pattern. 210 IWD 39075:2023(E) "
  },
  {
    "section": "16.7",
    "title": "<graph pattern binding table>",
    "text": "16) For every <binding variable reference> BVR2 with name NAME in GPYCREFS for which it holds that NAME is the name of a field in IREDT or ITART: a) Let STM be the innermost <linear query statement> or <linear data-modifying statement> that simply contains GPBT. b) Let TEMPVAR be an implementation-dependent(UV012)variable name not equal to the name of any field of IREDT or ITART. c) Let LS be the <let statement> simply contained in a simulated transformation of the current <GQL-program> obtained as the result of substituting STM with: CALL { LET TEMPVAR = NAME FINISH }  STM d) Let BVR1 be the instance of <binding variable reference> simply contained in LS. e) Let DEG1 and DEG2 be the degrees of reference of BVR1 and BVR2, respectively. f) It shall hold that either both DEG1 and DEG2 are singleton or both DEG1 and DEG2 are group. 17) Let GPYCVARS be the sequence of the names of the binding variables identified by the elements of GPYCREFS in the same order as in GPYCREFS. 18) Let GPYCFTSET be the set of the projected field types of all elements of GPYCREFS. NOTE 156 — See SR 13) of Subclause 16.3, “<binding variable reference>”, for the definition of projected field type. 19) Let GPYCRT be the closed record type whose field type set is GPYCFTSET. 20) The declared type of the incoming working record of GPBT and GPYCRT shall be field type-compar- able. 21) The record type of the declared type of the incoming working table of GPBT and GPYCRT shall be field type-comparable. 22) For each <element property specification> EPS simply contained in GP: a) Let EPP be the <element pattern predicate> that simply contains EPS. b) Let EPF be the <element pattern filler> that simply contains EPP. c) Let EVARDECL and EVAR be defined as follows. Case: i) If EPF simply contains an <element variable declaration> EVARDECL, then EVAR is the <identifier> contained in the <element variable declaration> simply contained in EPF. ii) Otherwise,EVAR is an implementation-dependent(UV008)<element variable> distinct from every element variable, subpath variable, and path variable contained in GP and EVARDECL is TEMP EVAR. NOTE 157 — In this case, EVAR specifies a temporary element variable which is never contained in GPYC. « WG3:CMN-019 P00-USA-095 » d) Let EPILE be defined as follows: If EPF simply contains the <is label expression> EPILE_CAND, then EPILE is EPILE_CAND; otherwise, EPILE is the zero-length character string. 211 IWD 39075:2023(E) "
  },
  {
    "section": "16.7",
    "title": "<graph pattern binding table>",
    "text": "e) Let PECL be the <property key value pair list> simply contained in EPS. f) Let NOPEC be the number of <property key value pair>s simply contained in PECL. g) Let PEC1, ..., PECNOPEC be the <property key value pair>s simply contained in PECL. « WG3:CMN-019 P00-NLD-050 » h) For i, 1 (one) ≤i ≤NOPEC: i) Let PROPi be the <property name> simply contained in PECi. ii) Let VALi be the <value expression> simply contained in PECi. iii) Let RPECi be a <comparison predicate> formed as: EVAR.PROPi = VALi i) Let EPSC be a <boolean value expression> formed through the concatenation of <boolean factor>s: RPEC1 AND ... AND ... RPECNOPEC. j) EPF is effectively replaced by: EVARDECL EPILE WHERE EPSC 23) Let GPT be the <graph pattern> simply contained in GPBT after the preceding transformations and let PPLT be the <path pattern list> simply contained in GPT. 24) Let PG be the current working graph available at GPBT. NOTE 158 — If no current working graph is available at GPBT, then this rule cannot be satisfied. See Subclause 4.7.3, “Working objects”. 25) For every <value expression> or <search condition> EXP simply contained in GP, if EXP is evaluated in a new child executioncontext CONTEXT during the applicationof the Subclause 22.6, “Application of bindings to evaluate an expression”, then: a) The declared type of the incoming working record of EXP is the record type whose field types are given by the union between: i) IREDT without the fields identified by RECORD_OVERLAP. ii) ITART without the fields identified by TABLE_OVERLAP. iii) The projected field types of all graph pattern variable references simply contained in EXP whose variables are declared by GP and that are exposed in EXP. NOTE 159 — See SR 13) of Subclause 16.3, “<binding variable reference>”, for the definition of projected field type. b) The declared type of the incoming working table of EXP is the unit binding table type. 26) Let GPBTRT be the closed record type whose field types are given by the union between: a) IREDT without the fields identified by RECORD_OVERLAP. b) ITART without the fields identified by TABLE_OVERLAP. c) GPYCFTSET. 27) The declared type of GPBT is the binding table type whose record type is GPBTRT. 212 IWD 39075:2023(E) "
  },
  {
    "section": "16.7",
    "title": "<graph pattern binding table>",
    "text": "General Rules 1) The General Rules of Subclause 22.2, “Machinery for graph pattern matching”, are applied with PG as PROPERTY GRAPH and PPLT as PATH PATTERN LIST; let MACH be the MACHINERY returned from the application of those General Rules. 2) Let MATCH_TABLE be a new empty binding table whose columns are the columns of the declared type of GPBT. 3) The preferred column name sequence PCNS of MATCH_TABLE is the concatenation of the following sequences of names in the order given. Case: a) If the current working table has a preferred column name sequence PCS, then PCNS is the concatenation of: i) The field names of IREDT not included in XGPYCVARS, in ascending order. ii) PCS without the names included in XGPYCVARS. iii) XGPYCVARS. b) Otherwise, PCNS is the concatenation of: i) The field names of IREDT and ITART not included in XGPYCVARS, in ascending order. ii) XGPYCVARS. 4) Let CWR be the current working record. 5) For each record OUTER in the current working table: a) Let INNER_TABLE be a new empty binding table whose columns are the field types in GPYCFTSET. b) Let COMBINED be CWR amended with OUTER. c) Let SANITIZED be COMBINED without the fields identified by OVERLAP. d) In a new child execution context whose working record is SANITIZED, the General Rules of Subclause 16.8, “<graph pattern>”, are applied with PG as PROPERTY GRAPH, GPT as GRAPH PATTERN, PPLT as PATH PATTERN LIST, and MACH as MACHINERY; let MATCHES be the SET OF REDUCED MATCHES returned from the application of those General Rules. e) For each reduced match RM in MATCHES: i) The General Rules of Subclause 22.8, “Application of bindings to generate a record”, are applied with GPT as GRAPH PATTERN, GPYC as YIELD CLAUSE, RM as MULTI-PATH BINDING, and MACH as MACHINERY; let INNER be the RECORD returned from the application of those General Rules. ii) INNER is appended to INNER_TABLE. f) The binding table constructed as the natural join between COMBINED and INNER_TABLE is appended to MATCH_TABLE. 6) The result of GPBT is MATCH_TABLE. 213 IWD 39075:2023(E) "
  },
  {
    "section": "16.7",
    "title": "<graph pattern binding table>",
    "text": "Conformance Rules 1) Conforming GQL language shall not contain a <graph pattern yield item list> that contains NO BINDINGS. NOTE 160 — A <graph pattern yield item list> that contains NO BINDINGS is a specification device and is not syntax available to the user. 2) Without Feature GQ19, “Graph pattern YIELD clause”, conforming GQL language shall not contain a <graph pattern binding table> that immediately contains a <graph pattern yield clause>. 214 IWD 39075:2023(E) "
  },
  {
    "section": "16.7",
    "title": "<graph pattern binding table>",
    "text": "16.8 <graph pattern> Function Specify a pattern to be matched in a graph. Subclause Signature “<graph pattern>” [General Rules] (   Parameter: “PROPERTY GRAPH”,    Parameter: “GRAPH PATTERN”,    Parameter: “PATH PATTERN LIST”,    Parameter: “MACHINERY” ) Returns: “SET OF REDUCED MATCHES” PROPERTY GRAPH — a property graph GRAPH PATTERN — a <graph pattern>. PATH PATTERN LIST — a <path pattern list>. MACHINERY — the machinery for graph pattern matching. SET OF REDUCED MATCHES — the resulting set of reduced matches. —This signature is invoked from Subclause 16.7, “<graph pattern binding table>”, GR 5)d) Format <graph pattern> ::= [ <match mode> ] <path pattern list>     [ <keep clause> ]     [ <graph pattern where clause> ] <match mode> ::= <repeatable elements match mode> | <different edges match mode> <repeatable elements match mode> ::= REPEATABLE <element bindings or elements> <different edges match mode> ::= DIFFERENT <edge bindings or edges> <element bindings or elements> ::= ELEMENT [ BINDINGS ] | ELEMENTS <edge bindings or edges> ::= <edge synonym> [ BINDINGS ] | <edges synonym> <path pattern list> ::= <path pattern> [ { <comma> <path pattern> }... ] <path pattern> ::= [ <path variable declaration> ] [ <path pattern prefix> ] <path pattern expression> <path variable declaration> ::= 215 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "<path variable> <equals operator> <keep clause> ::= KEEP <path pattern prefix> <graph pattern where clause> ::= WHERE <search condition> Syntax Rules 1) Let GP be the <graph pattern>. 2) If BNF1 and BNF2 are instances of two BNF non-terminals, both contained in GP without an inter- vening <graph pattern>, then BNF1 and BNF2 are said to be at the same depth of graph pattern matching. NOTE 161 — BNF1 can contain BNF2 while being at the same depth of graph pattern matching. 3) In a <path pattern list>, if two <path pattern>s expose an element variable EV, then both shall expose EV as an unconditional singleton variable. NOTE 162 — This case expresses an implicit join on EV. Implicit joins between conditional singleton variables or group variables are forbidden. 4) Two <path pattern>s shall not expose the same subpath variable. NOTE 163 — Implicit equijoins on subpath variables are not supported. 5) The name of a node variable shall not be equivalent to the name of an edge variable declared at the same depth of graph pattern matching. 6) If <keep clause> KP is specified, then: a) Let PSP be the <path pattern prefix> simply contained in KP. b) For each <path pattern> PP simply contained in GP: i) PP shall not contain a <path search prefix>. ii) Case: 1) IfPPspecifiesa<pathvariabledeclaration>,thenletPVDECLbethat<pathvariable declaration>. 2) Otherwise, let PVDECL be the zero-length character string. iii) Case: 1) If PP specifies a <path mode prefix>, then let PMP be that <path mode prefix>. 2) Otherwise, let PMP be the zero-length character string. iv) Let PPE be the <path pattern expression> simply contained in PP. v) PP is replaced by PVDECL PSP ( PMP PPE ) c) The <keep clause> is removed from the <graph pattern>. ** Editor’s Note (number 28) ** 216 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "It has been suggested that it might be possible to treat the <path pattern prefix> specified in <keep clause> as merely providing a default <path pattern prefix> rather than a mandatory one for each <path pattern>. Whereas nested <path pattern prefix> is prohibited, this may be a feasible avenue of growth. On the other hand, perhaps a less definitive verb than KEEP may be appropriate when spe- cifying a default <path pattern prefix>. See Language Opportunity GQL-057 . 7) After the preceding transformations, for every <path pattern> PP, if PP contains a <path pattern prefix> PPP that specifies a <path mode> PM, then: a) Case: i) If PP specifies a <path variable declaration>, then let PVDECL be that <path variable declaration>. ii) Otherwise, let PVDECL be the zero-length character string. b) Let PPE be the <path pattern expression> simply contained in PP. c) PP is replaced by PVDECL PPP ( PM PPE ) NOTE 164 — One effect of the preceding transforms is that every <path mode> expressed outside a <parenthesized path pattern expression> is also expressed within a <parenthesized path pattern expression>. For example, ALL SHORTEST TRAIL GROUP <path pattern expression> is rewritten as ALL SHORTEST TRAIL GROUP ( TRAIL <path pattern expression> ) The TRAIL specified outside the parentheses is now redundant. The benefit is that the definition of a consistent path binding in Subclause 22.2, “Machinery for graph pattern matching”, only has to consider <path mode>s declared in <parenthesized path pattern expression>s. 8) Let GPT be the <graph pattern> after the preceding syntactic transformations. 9) Let PPL be the <path pattern list> simply contained in GPT. 10) If GPT does not specify a <match mode>, then an implementation-defined (ID086) <match mode> is implicit. 11) Let MM be the <match mode> implicitly or explicitly specified by GPT. 12) If MM is <different edges match mode> and PPL simply contains a <path pattern> that is selective, then PPL shall not simply contain any other <path pattern>. NOTE 165 — If MM is <different edges match mode> and there is a selective <path pattern> SPP, then PPL must only contain SPP. If there is no selective <path pattern> in GPT, then there are no restrictions on how many non-selective <path pattern>s are contained in PPL. If MM is <repeatable elements match mode>, then there is no restriction on how many (selective and non-selective) <path pattern>s are con- tained in PPL. 13) Let E be an element variable declared by GPT. Case: a) If E is exposed by GPT as an unconditional singleton, then E is a global unconditional singleton of GPT. b) Otherwise, let PPPE be the outermost <parenthesized path pattern expression> that exposes E as an unconditional singleton; the unconditional singleton scope index of E in GPT is the bracket index of PPPE. 217 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "NOTE 166 — Bracket index is defined in Subclause 22.2, “Machinery for graph pattern matching”. The unconditional singleton scope index is well-defined because implicit equijoins between condi- tional singleton variables or group variables are forbidden. Hence there cannot be two <parenthes- ized path pattern expression>s that expose E as a conditional singleton or group variable unless one is contained in the other. For example, ( ( ( -[E]-> ) -[E]-> )* -[F]-> )* The unconditional singleton scope of E is the middle <parenthesized path pattern expression> in the nest of three. 14) After the preceding transformations, for every <quantified path primary> QPP contained in GPT, at least one of the following shall be true: a) The <graph pattern quantifier> of QPP is bounded. b) QPP is contained in a restrictive <parenthesized path pattern expression>. c) QPP is contained in a selective <path pattern>. d) MM is <different edges match mode>. « Editorial: Standardize the spelling of keyword » NOTE 167 — Unless an explicit <path mode> other than WALK is specified, an explicit or implicit specificationof a <different edges match mode> effectively imparts the <path mode> TRAIL without the presence of the keyword TRAIL. « WG3:CMN-019 P00-USA-007 » 15) Each <path variable> PV contained in GPT is the name of a path variable. The degree of exposure of the path variable that PV identifies is unconditional singleton. General Rules 1) Let PG be the PROPERTY GRAPH, let GPT be the GRAPH PATTERN, let PPL be the PATH PATTERN LIST, and let MACH be the MACHINERY in an application of the General Rules of this Subclause. The result of the application of this Subclause is returned as SET OF REDUCED MATCHES. NOTE 168 — In this document, PG is always the current working graph. 2) The following components of MACH are identified: a) ABC, the alphabet, formed as the disjoint union of the following: i) SVV, the set of names of node variables. ii) SEV, the set of names of edge variables. iii) SPS, the set of subpath symbols. iv) SAS, the set of anonymous symbols. v) SBS, the set of bracket symbols. b) REDUCE, the function mapping path bindings to path bindings, and multi-path bindings to multi-path bindings. 3) Let NP be the number of <path pattern>s simply contained in PPL. Let PP1, ..., PPNP be the <path pattern>s simply contained in PPL after the transformations in the Syntax Rules. 4) A multi-path binding MPBINDING is different-edges-matched if, for every edge binding EB1 = (EV1, E) contained in MPBINDING, there is no edge binding EB2 = (EV2, E) contained in MPBINDING at a different position than EB1 that binds the edge E. 218 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "5) For every i, 1 (one) ≤i ≤NP: a) Let PPE be the <parenthesized path pattern expression> simply contained in PPi. b) The General Rules of Subclause 22.3, “Evaluation of a <path pattern expression>”, are applied with PG as PROPERTY GRAPH, PPL as PATH PATTERN LIST, MACH as MACHINERY, and PPE as SPECIFIC BNF INSTANCE; let SMPPEi be the SET OF MATCHES returned from the application of those General Rules. NOTE 169 — If an elementary variable has been multiply declared within a restrictive <parenthes- ized path pattern expression> PP, then no matches are returned for PP. For example: MATCH ACYCLIC (X) -> (X) does not find any results, even if there are nodes with self-edges. c) Case: i) If PPi is a selective <path pattern>, then: 1) Case: A) If MM is <different edges match mode>, then let SMUPi be the set of different- edges-matched multi-path bindings in SMPPEi. NOTE 170 — If an edge variable has been multiply declared within a <path pattern> PP, then no matches are returned for PP. For example, the following produces no results: MATCH DIFFERENT EDGES ANY SHORTEST () -[E]-> () -[E]-> () B) Otherwise, let SMUPi be SMPPEi. 2) The General Rules of Subclause 22.4, “Evaluation of a selective <path pattern>”, are applied with PG as PROPERTY GRAPH, PPL as PATH PATTERN LIST, MACH as MACHINERY, PPi as SELECTIVE PATH PATTERN, and SMUPi as INPUT SET OF LOCAL MATCHES; let SMi be the OUTPUT SET OF LOCAL MATCHES returned from the application of those General Rules. ii) Otherwise, let SMi be SMPPEi. 6) Let CROSS be the cross product SM1 ⨯... ⨯SMNP. 7) LetINNERbethesetofmulti-pathbindingsMPBinCROSSsuchthat,foreveryunconditionalsingleton <element variable> USV exposed by PPL, USV is bound to a unique graph element by the elementary bindings of USV contained in MPB. NOTE 171 — Anonymous symbols are not <element variable>s; there is no requirement that two anonymous symbols bind to the same graph element. 8) Case: a) IfMMis<differentedgesmatchmode>,thenletBINDINGSbethesetofdifferent-edges-matched multi-path bindings in INNER. NOTE 172 — If an edge variable has been multiply declared within a <graph pattern> GP, then no matches are returned for GP. For example, the following produces no results: MATCH DIFFERENT EDGES () -[E]-> (), () -[E]-> () and neither does the following: 219 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "MATCH DIFFERENT EDGES () -[E]-> () -[E]-> () b) Otherwise, let BINDINGS be INNER. 9) A match of GPT is a multi-path binding M = ( PB1, ..., PBNP ) of NP path bindings in BINDINGS, such that all of the following are true: a) For every j, 1 (one) ≤j ≤NP, and for every <parenthesized path pattern expression> PPPE contained in PPj, let i be the bracket index of PPPE, and let `[i` and `]i` be the bracket symbols associated with PPPE. A binding of PPPE is a substring of PBj that begins with the bracket binding (`[i`, `[i`) and ends with the next bracket binding (`]i`, `]i`). NOTE 173 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”. For every binding BPPPE of PPPE contained in PBj, all of the following are true: i) For every <elementvariable>EV that is exposedas an unconditionalsingleton by PPPE, EV is bound to a unique graph element by the element variable bindings contained in BPPPE. NOTE 174 — Anonymous symbols are not <element variable>s; there is no requirement that two anonymous symbols bind to the same graph element. « Editorial: Use new applySC asTest option » ii) If PPPE contains a <parenthesized path pattern where clause> PPPWC, then True is the VALUE returned as V1 when the General Rules of Subclause 22.6, “Application of bindings to evaluate an expression”, are applied with GPT as GRAPH PATTERN, the <search condition> simply contained in PPPWC as EXPRESSION, MACH as MACHINERY, M as MULTI-PATH BINDING, and a reference to BPPPE as REFERENCE TO LOCAL CON- TEXT. « Editorial: Use new applySC asTest option » b) If GPT contains a <graph pattern where clause> GPWC, then True is the VALUE returned as V2 when the General Rules of Subclause 22.6, “Application of bindings to evaluate an expression”, are applied with GPT as GRAPH PATTERN, GPWC as EXPRESSION, MACH as MACHINERY, M as MULTI-PATH BINDING, and a reference to M as REFERENCE TO LOCAL CONTEXT. 10) A reduced match RM = ( RPB1, ..., RPBNP ) is obtained from a match M = ( PB1, ..., PBNP ) as RM = REDUCE(M). NOTE 175 — Set-theoretic deduplication will occur here. That is, two or more matches can reduce to the same reduced match; this scenario is regarded as contributing only a single reduced match to the result set. 11) Let SRM be the set of reduced matches. 12) Evaluation of the General Rules is terminated and control is returned to the invoking Subclause, which receives SRM as SET OF REDUCED MATCHES. Conformance Rules 1) Without Feature G002, “Different-edges match mode”, conforming GQL language shall not contain a <different edges match mode>. 2) Without Feature G003, “Explicit REPEATABLE ELEMENTS keyword”, conforming GQL language shallnotcontaina<matchmode>thatspecifiesREPEATABLEELEMENTSorREPEATABLEELEMENT BINDINGS. 220 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "3) Without Feature G004, “Path variables”, conforming GQL language shall not contain a <path pattern> that simply contains a <path variable declaration>. 4) Without Feature G005, “Path search prefix in a path pattern”, conforming GQL language shall not contain a <path pattern> that simply contains a <path pattern prefix> that is a <path search prefix>. 5) Without Feature G006, “Graph pattern KEEP clause: path mode prefix”, conforming GQL language shall not contain a <keep clause> that simply contains a <path mode prefix>. 6) Without Feature G007, “Graph pattern KEEP clause: path search prefix”, conforming GQL language shall not contain a <keep clause> that simply contains a <path search prefix>. 221 IWD 39075:2023(E) "
  },
  {
    "section": "16.8",
    "title": "<graph pattern>",
    "text": "16.9 <path pattern prefix> Function Specify a path-finding operation and a path mode. Format <path pattern prefix> ::= <path mode prefix> | <path search prefix> <path mode prefix> ::= <path mode> [ <path or paths> ] <path mode> ::= WALK | TRAIL | SIMPLE | ACYCLIC <path search prefix> ::= <all path search> | <any path search> | <shortest path search> ** Editor’s Note (number 29) ** The ability to specify “cheapest” queries (analogous to SHORTEST, but minimizing the sum of costs along a path) is desirable. See Language Opportunity GQL-052 . <all path search> ::= ALL [ <path mode> ] [ <path or paths> ] <path or paths> ::= PATH | PATHS <any path search> ::= ANY [ <number of paths> ] [ <path mode> ] [ <path or paths> ] <number of paths> ::= <unsigned integer specification> ** Editor’s Note (number 30) ** This differs from the SQL/PGQ definition of <number of paths>. <shortest path search> ::= <all shortest path search> | <any shortest path search> | <counted shortest path search> | <counted shortest group search> <all shortest path search> ::= ALL SHORTEST [ <path mode> ] [ <path or paths> ] <any shortest path search> ::= ANY SHORTEST [ <path mode> ] [ <path or paths> ] <counted shortest path search> ::= 222 IWD 39075:2023(E) "
  },
  {
    "section": "16.9",
    "title": "<path pattern prefix>",
    "text": "SHORTEST <number of paths> [ <path mode> ] [ <path or paths> ] <counted shortest group search> ::= SHORTEST [ <number of groups> ] [ <path mode> ] [ <path or paths> ] { GROUP | GROUPS } <number of groups> ::= <unsigned integer specification> ** Editor’s Note (number 31) ** This differs from the SQL/PGQ definition of <number of groups>. ** Editor’s Note (number 32) ** In addition to SHORTEST GROUP, it has been proposed to support SHORTEST [ k ] WITH TIES, with the semantics to return the first k matches (where k defaults to 1) when sorting matches in ascending order on number of edges, and also return every match that has the same number of edges as the last of the k matches. This is the semantics of WITH TIES in Subclause 7.17, “<query expression>” in SQL/Foundation. See Language Opportunity GQL-053 . Syntax Rules 1) If a <parenthesized path pattern expression> does not specify a <path mode prefix>, then WALK PATHS is implicit. 2) If a <path pattern prefix> PPP does not specify <all path search>, then: a) Case: i) If PPP does not simply contain a <path mode>, then let PM be WALK. ii) Otherwise, let PM be the <path mode> simply contained in PPP. b) Case: i) If PPP does not simply contain a <number of paths> or <number of groups>, then let N be an <unsigned integer> whose value is 1 (one). ii) Otherwise, let N be the <number of paths> or <number of groups> simply contained in PPP. The declared type of N shall be exact numeric with scale 0 (zero). If N is a <lit- eral>, then the value of N shall be positive. c) Case: i) If PPP is an <any path search>, then PPP is equivalent to: ANY N PM PATHS ii) If PPP is a <shortest path search>, then Case: 1) If PPP is <all shortest path search>, then PPP is equivalent to: SHORTEST 1 PM GROUP 2) If PPP is <any shortest path search>, then PPP is equivalent to: SHORTEST 1 PM PATH 3) If PPP is <counted shortest path search>, then PPP is equivalent to: 223 IWD 39075:2023(E) "
  },
  {
    "section": "16.9",
    "title": "<path pattern prefix>",
    "text": "SHORTEST N PM PATHS 4) If PPP is <counted shortest group search>, then PPP is equivalent to: SHORTEST N PM GROUPS 3) A<pathpatternprefix>thatspecifiesa<pathmode>otherthanWALKisrestrictive.A<parenthesized path pattern expression> that immediately contains a restrictive <path mode prefix> is restrictive. 4) A <path search prefix> other than <all path search> is selective. A <path pattern> that simply contains a selective <path search prefix> is selective. 5) Let PPPE be a selective <path pattern>. a) An element variable exposed by PPPE is an interior variable of PPPE. b) A node variable LVV is the left boundary variable of PPPE if all of the following conditions are true: i) PPPE exposes LVV as an unconditional singleton variable. ii) LVV is declared in the first explicit or implicit <node pattern> LVP contained in PPPE. iii) LVP is not contained in a <path pattern union> or <path multiset alternation> that is contained in PPPE. c) A node variable RVV is the right boundary variable of PPPE if all of the following conditions are true: i) PPPE exposes RVV as an unconditional singleton variable. ii) RVV is declared in the last explicit or implicit <node pattern> RVP contained in PPPE. iii) RVP is not contained in a <path pattern union> or <path multiset alternation> that is contained in PPPE. ** Editor’s Note (number 33) ** With more work, it is possible to recognize when a node variable is declared uniformly in the first or the last position in every operand of a <path pattern union>. However, WG3:W04- 009R1 declined to make the effort because it is easy for the user to factor out such a node pattern. For example, instead of (X) -> (Y) | (X) -> (Z) the user can write (X) ( -> (Y) | -> (Z)) Thus a more general definition of right or left boundary variable is possible. See Language Opportunity GQL-056 . d) An element variable that is exposed by PPPE that is neither a left boundary variable of PPPE nor a right boundary variable of PPPE is a strict interior variable of PPPE. 6) An element variable that is not declared in a selective <path pattern> is an exterior variable. « Editorial » 7) A strict interior variable of one selective <path pattern> shall not be equivalent to an exterior variable, or to an interior variable of another selective <path pattern>. « WG3:CMN-019 P00-ISO-031 » 224 IWD 39075:2023(E) "
  },
  {
    "section": "16.9",
    "title": "<path pattern prefix>",
    "text": "NOTE 176 — This does not prohibit implicit joins of boundary variables of selective <path pattern>s with exterior variables or boundary variables of other selective <path pattern>s. 8) A selective <path pattern> SPP shall not contain a reference to a graph pattern variable that is not declared by SPP. NOTE 177 — This rule, and the prohibition of implicit joins to exterior variables and interior variables of other selective <path pattern>s, insure that each selective <path pattern> can be evaluated in isolation from any other <path pattern>. General Rules None. NOTE 178 — Restrictive <path mode>s are enforced as part of the check for consistent path bindings in the generation of the set of local matches in Subclause 16.10, “<path pattern expression>”. Selective <path pattern>s are evaluated by Subclause 22.4, “Evaluation of a selective <path pattern>”. Conformance Rules 1) Without Feature G010, “Explicit WALK keyword”, conforming GQL language shall not contain a <path mode> that specifies WALK. 2) Without Feature G011, “Advanced path modes: TRAIL”, conforming GQL language shall not contain a <path mode> that specifies TRAIL. 3) Without Feature G012, “Advanced path modes: SIMPLE”, conforming GQL language shall not contain a <path mode> that specifies SIMPLE. 4) WithoutFeature G013,“Advancedpath modes:ACYCLIC”, conformingGQLlanguage shallnot contain a <path mode> that specifies ACYCLIC. 5) Without Feature G014, “Explicit PATH/PATHS keywords”, conforming GQL language shall not contain a <path or paths>. 6) Without Feature G015, “All path search: explicit ALL keyword”, conforming GQL language shall not contain an <all path search>. 7) Without Feature G016, “Any path search”, conforming GQL language shall not contain an <any path search>. 8) Without Feature G017, “All shortest path search”, conforming GQL language shall not contain an <all shortest path search>. 9) Without Feature G018, “Any shortest path search”, conforming GQL language shall not contain an <any shortest path search>. 10) Without Feature G019, “Counted shortest path search”, conforming GQL language shall not contain a <counted shortest path search>. 11) Without Feature G020, “Counted shortest group search”, conforming GQL language shall not contain a <counted shortest group search>. 225 IWD 39075:2023(E) "
  },
  {
    "section": "16.9",
    "title": "<path pattern prefix>",
    "text": ""
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "Function Specify a pattern to match a single path in a property graph. Format <path pattern expression> ::= <path term> | <path multiset alternation> | <path pattern union> <path multiset alternation> ::= <path term> <multiset alternation operator> <path term>     [ { <multiset alternation operator> <path term> }... ] <path pattern union> ::= <path term> <vertical bar> <path term> [ { <vertical bar> <path term> }... ] <path term> ::= <path factor> | <path concatenation> <path concatenation> ::= <path term> <path factor> <path factor> ::= <path primary> | <quantified path primary> | <questioned path primary> <quantified path primary> ::= <path primary> <graph pattern quantifier> <questioned path primary> ::= <path primary> <question mark> NOTE 179 — Unlike most regular expression languages, <question mark> is not equivalent to the quantifier {0,1}: the quantifier {0,1} exposes variables as group, whereas <question mark> does not change the singleton variables that it exposes to group. However, <question mark> does expose any singleton variables as conditional singletons. <path primary> ::= <element pattern> | <parenthesized path pattern expression> | <simplified path pattern expression> <element pattern> ::= <node pattern> | <edge pattern> <node pattern> ::= <left paren> <element pattern filler> <right paren> <element pattern filler> ::= [ <element variable declaration> ] [ <is label expression> ] [ <element pattern predicate> ] <element variable declaration> ::= 226 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "[ TEMP ] <element variable> <is label expression> ::= <is or colon> <label expression> <is or colon> ::= IS | <colon> <element pattern predicate> ::= <element pattern where clause> | <element property specification> <element pattern where clause> ::= WHERE <search condition> <element property specification> ::= <left brace> <property key value pair list> <right brace> <property key value pair list> ::= <property key value pair> [ { <comma> <property key value pair> }... ] <property key value pair> ::= <property name> <colon> <value expression> <edge pattern> ::= <full edge pattern> | <abbreviated edge pattern> <full edge pattern> ::= <full edge pointing left> | <full edge undirected> | <full edge pointing right> | <full edge left or undirected> | <full edge undirected or right> | <full edge left or right> | <full edge any direction> <full edge pointing left> ::= <left arrow bracket> <element pattern filler> <right bracket minus> <full edge undirected> ::= <tilde left bracket> <element pattern filler> <right bracket tilde> <full edge pointing right> ::= <minus left bracket> <element pattern filler> <bracket right arrow> <full edge left or undirected> ::= <left arrow tilde bracket> <element pattern filler> <right bracket tilde> <full edge undirected or right> ::= <tilde left bracket> <element pattern filler> <bracket tilde right arrow> <full edge left or right> ::= <left arrow bracket> <element pattern filler> <bracket right arrow> <full edge any direction> ::= <minus left bracket> <element pattern filler> <right bracket minus> ** Editor’s Note (number 34) ** In the BNF for <full edge any direction>, the delimiter tokens <~[ ]~> have been suggested as a synonym for -[ ]- as part of Feature GH03, “Undirected edge patterns”. The synonym for the <abbreviated edge pattern> - (<minus sign>) would then be <~>, the synonym for <simplified defaulting any direction> would use the delimiter tokens 227 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "<~/ /~> and the synonym for <simplified override any direction> would use the tokens <~ and > surrounding a label as originally proposed in WG3:MMX-060. These synonyms might be considered to make the table of edge patterns more harmonious and internally consistent. See Language Opportunity GQL-212 . <abbreviated edge pattern> ::= <left arrow> | <tilde> | <right arrow> | <left arrow tilde> | <tilde right arrow> | <left minus right> | <minus sign> <parenthesized path pattern expression> ::= <left paren>     [ <subpath variable declaration> ]     [ <path mode prefix> ] <path pattern expression>     [ <parenthesized path pattern where clause> ] <right paren> <subpath variable declaration> ::= <subpath variable> <equals operator> <parenthesized path pattern where clause> ::= WHERE <search condition> Syntax Rules 1) Let RIGHTMINUS be the following collection of <token>s: <right bracket minus>, <left arrow>, <slash minus>, and <minus sign>. NOTE 180 — These are the tokens ]-, <-, /-, and -, which expose a minus sign on the right. 2) Let LEFTMINUS be the following collection of <token>s: <minus left bracket>, <right arrow>, <minus slash>, and <minus sign>. NOTE 181 — These are the tokens -[, ->, -/, and -, which expose a minus sign on the left. <minus sign> itself is in both RIGHTMINUS and LEFTMINUS. 3) A <path pattern expression> shall not juxtapose a <token> from RIGHTMINUS followed by a <token> from LEFTMINUS without a <separator> between them. NOTE 182 — Otherwise, the concatenation of the two tokens would include the sequence of two <minus sign>s, which is a <simple comment introducer>. 4) A <path pattern expression> that contains at the same depth of graph pattern matching a variable quantifier, a <questioned path primary>, a <path multiset alternation>, or a <path pattern union> is a possibly variable length path pattern. 5) A <path pattern expression> that is not a possibly variable length path pattern is a fixed length path pattern. 6) The minimum path length of certain BNF non-terminals defined in this Subclause is defined recursively as follows: a) The minimum path length of a <node pattern> is 0 (zero). b) The minimum path length of an <edge pattern> is 1 (one). 228 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "c) The minimum path length of a <path concatenation> is the sum of the minimum path lengths of its operands. d) The minimum path length of a <path pattern union> or <path multiset alternation> is the minimum of the minimum path length of its operands. e) The minimum path length of a <quantified path primary> is the product of the minimum path length of the simply contained <path primary> and the value of the <lower bound>. f) The minimum path length of a <questioned path primary> is 0 (zero). g) The minimum path length of a <parenthesized path pattern expression> is the minimum path length of the simply contained <path pattern expression>. h) If BNT1 and BNT2 are two BNF non-terminals such that BNT1 ::= BNT2 and the minimum path length of BNT2 is defined, then the minimum path length of BNT1 is also defined and is the same as the minimum path length of BNT2. 7) The <path primary> immediately contained in a <quantified path primary> or <questioned path primary> shall have minimum path length that is greater than 0 (zero). 8) The <path primary> simply contained in a <quantified path primary> shall not contain a <quantified path primary> at the same depth of graph pattern matching. ** Editor’s Note (number 35) ** It may be possible to permit nested quantifiers. WG3:W01-014 contained a discussion of a way to support aggregates at different depths of aggregation if there are nested quantifiers. See Language Opportunity GQL-036 . 9) Let PMA be a <path multiset alternation>. a) A <path term> simply contained in PMA is a multiset alternation operand of PMA. b) Let NOPMA be the number of multiset alternation operands of PMA. Let OPMA1, ..., OPMANOPMA be an enumeration of the operands of PMA. c) Any <subpath variable>s declared by <subpath variable declaration>s simply contained in the multiset alternation operands of PMA shall be mutually distinct. d) Let SOPMA1, ..., SOPMANOPMA be implementation-dependent (UV008) <identifier>s that are mutually distinct and distinct from every <element variable>, <subpath variable> and <path variable> contained in GP. « WG3:CMN-019 P00-NLD-050 » e) For i, 1 (one) ≤i ≤NOPMA, Case: i) If OPMAi is a <parenthesized path pattern expression> that simply contains a <subpath variable declaration>, then let OPMAXi be OPMAi. ii) Otherwise, let OPMAXi be the <parenthesized path pattern expression> (SOPMAi = OPMAi) f) PMA is equivalent to: OPMAX1 | ... | OPMAXNOPMA 229 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "10) A <path term> PPUOP simply contained in a <path pattern union> PSD is a path pattern union operand of PSD. ** Editor’s Note (number 36) ** Path pattern union is not defined using left recursion. WG3:SXM-052 believed that it should be possible to support left recursion but declined to do so for expediency. It is a Language Opportunity to support left recursion. See Language Opportunity GQL-025 . PPUOP shall not contain a reference to an element variable that is not declared in PPUOP or outside of PSD. 11) An <element pattern> EP that contains an <element pattern where clause> EPWC is transformed as follows: a) Let EPF be the <element pattern filler> simply contained in EP. b) Let PREFIX be the <delimiter token> contained in EP before EPF and let SUFFIX be the <delimiter token> contained in EP after EPF. « WG3:CMN-019 P00-USA-097 » c) Let EV be the <element variable> simply contained in EPF. d) Let ILE be defined as follows: If EPF simply contains the <is label expression> ILE_CAND, then ILE is ILE_CAND; otherwise, ILE is the zero-length character string. e) EP is replaced by ( PREFIX EV ILE SUFFIX EPWC ) 12) An <element pattern> that does not contain an <element variable declaration>, an <is label expression>, or an <element pattern predicate> is said to be empty. 13) Each <path pattern expression> is transformed in the following steps: a) If the <path primary> immediately contained in a <quantified path primary> or <questioned path primary> is an <edge pattern> EP, then EP is replaced by ( EP ) NOTE 183 — For example, ->* becomes: (->) {0,} which in later transformations becomes: (() -> ()) {0,} b) If two successive <element pattern>s contained in a <path concatenation> at the same depth of graph pattern matching are <edge pattern>s, then an implicit empty <node pattern> is inserted between them. c) If an edge pattern EP contained in a <path term> PST at the same depth of graph pattern matching is not preceded by a <node pattern> contained in PST at the same depth of graph pattern matching, then an implicit empty <node pattern> VP is inserted in PST immediately prior to EP. d) If an edge pattern EP contained in a <path term> PST at the same depth of graph pattern matching is not followed by a <node pattern> contained in PST at the same depth of graph 230 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "pattern matching, than an implicit empty <node pattern> VP is inserted in PST immediately after EP. NOTE 184 — As a result of the preceding transformations, a fixed length path pattern has an odd numberof<elementpattern>s,beginningandendingwith<nodepattern>s,andalternatingbetween <node pattern>s and <edge pattern>s. e) Every<abbreviatededgepattern>AEP isreplacedwithan empty<fulledgepattern>asfollows. Case: i) If AEP is <left arrow>, then AEP is replaced by the <full edge pointing left>: <-[ ]- ii) If AEP is <tilde>, then AEP is replaced by the <full edge undirected>: ~[ ]~ iii) If AEP is <right arrow>, then AEP is replaced by the <full edge pointing right>: -[ ]-> iv) If AEP is <left arrow tilde>, then AEP is replaced by the <full edge left or undirected>: <~[ ]~ v) If AEP is <tilde right arrow>, then AEP is replaced by the <full edge undirected or right>: ~[ ]~> vi) If AEP is <left minus right>, then AEP is replaced by the <full edge left or right>: <-[ ]-> vii) If AEP is <minus sign>, then AEP is replaced by the <full edge any direction>: -[ ]- 14) TheminimumnodecountofcertainBNFnon-terminalsdefinedinthisSubclauseisdefinedrecursively as follows: a) The minimum node count of a <node pattern> is 1 (one). b) The minimum node count of an <edge pattern> is 0 (zero). c) The minimum node count of a <path concatenation> PC is: Case: i) If two successive <elementpattern>s containedin PC at the same depth of graph pattern matching are <node pattern>s, then 1 (one) less than the sum of the minimum node counts of its operands. ii) Otherwise, the sum of the minimum node counts of its operands. d) The minimum node count of a <path pattern union> or <path multiset alternation> is the minimum of the minimum node count of its operands. e) The minimum node count of a <quantified path primary> is the product of the minimum node count of the simply contained <path primary> and the value of the <lower bound> of the simply contained <graph pattern quantifier>. 231 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "f) The minimum node count of a <questioned path primary> is 0 (zero). g) The minimum node count of a <parenthesized path pattern expression> is the minimum node count of the simply contained <path pattern expression>. h) If BNF1 and BNF2 are two BNF non-terminals such that BNF1 ::= BNF2 and the minimum node count of BNF2 is defined, then the minimum node count of BNF1 is also defined and is the same as the minimum node count of BNF2. 15) The <path pattern expression> simply contained in a <path pattern> shall have a minimum node count that is greater than 0 (zero). NOTE 185 — The minimum node count is computed after the syntactic transform that adds implicit node patterns. Thus a single <edge pattern> is a permitted <path pattern> because it implies two <node pat- tern>s. NOTE 186 — A later Syntax Rule makes the same requirement of a <parenthesized path pattern expres- sion> that simply contains a <subpath variable declaration>. 16) An <element variable> EV contained in an <element variable declaration> GPVD is said to be declared by GPVD, and by the <element pattern> EP that simply contains GPVD. The <element variable> is the name of an element variable, which is also declared by GPVD and EP. If GPVD simply contains TEMP, then EV is a temporary element variable. NOTE 187 — Element bindings to temporary element variables are removed prior to set-theoretic deduplication of matches. See GR 10) of Subclause 16.8, “<graph pattern>” and GR 14) of Subclause 22.2, “Machinery for graph pattern matching”. « WG3:CMN-019 P00-USA-007 » 17) An element variable that is declared by a <node pattern> is a node variable. An element variable that is declared by an <edge pattern> is an edge variable. 18) The scope of an <element variable> EV that is declared by an <element pattern> EP is defined as follows. If EV is a temporary element variable, then the scope of EV is the innermost <path term> containing EP; otherwise, the scope of EV is the innermost <graph pattern binding table> containing EP. « WG3:CMN-019 P00-USA-098 » 19) If PPPE simply contains a <subpath variable declaration>, then the minimum node count of PPPE shall be greater than 0 (zero). « WG3:CMN-019 P00-USA-099 » 20) If an <element pattern> EP that contains an <element pattern where clause> EPWC, then EP shall simply contain an <element variable declaration> GPVD. 21) If EV is an element variable or subpath variable, and BNT is an instance of a BNF non-terminal, then the terminology “BNT exposes EV” is defined as follows. The full terminology is one of the following: “BNT exposes EV as an unconditional singleton variable”, “BNT exposes EV as a conditional singleton variable”, “BNT exposes EV as an effectively bounded group variable” or “BNT exposes EV as an effectively unbounded group variable”. The terms “unconditional singleton variable”, “conditional singleton variable”, “effectively bounded group variable”, and “effectively unbounded group variable” are called the degree of exposure. a) An <element pattern> EP that declares an element variable EV exposes EV as an unconditional singleton. b) A <parenthesized path pattern expression> PPPE that simply contains a <subpath variable declaration> that declares EV exposes EV as an unconditional singleton variable. PPPE shall not contain another <parenthesized path pattern expression> that declares EV. 232 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "c) If a <path concatenation> PPC declares EV then let PT be the <path term> and let PF be the <path factor> simply contained in PPC. Case: i) If EV is exposed as an unconditional singleton by both PT and PF, then EV is exposed as an unconditional singleton by PPC. EV shall not be a subpath variable. NOTE 188 — This case expresses an implicit join on EV within PPC. Implicit joins between conditional singleton variables, group variables, or subpath variables are forbidden. ii) Otherwise, EV shall only be exposed by one of PT or PF. In this case EV is exposed by PPC in the same degree that it is exposed by PT or PF. d) If a <path pattern union> or <path multiset alternation> PA declares EV, then Case: i) If every operand of PA exposes EV as an unconditional singleton variable, then PA exposes EV as an unconditional singleton variable. ii) If at least one operand of PA exposes EV as an effectively unbounded group variable, then PA exposes EV as an effectively unbounded group variable. iii) If at least one operand of PA exposes EV as an effectively bounded group variable, then PA exposes EV as an effectively bounded group variable. iv) Otherwise, PA exposes EV as a conditional singleton variable. e) If a <quantified path primary> QPP declares EV, then let PP be the <path primary> simply contained in QPP. Case: i) If QPP contains a <graph pattern quantifier> that is a <fixed quantifier> or a <general quantifier> that contains an <upper bound> and PP does not expose EV as an effectively unbounded group variable, then QPP exposes EV as an effectively bounded group variable. ii) If QPP is contained at the same depth of graph pattern matching in a restrictive <par- enthesized path pattern expression>, then QPP exposes EV as an effectively bounded group variable. NOTE 189 — The preceding definitionis applied after the syntactic transformation to insure that every <path mode prefix> is at the head of a <parenthesized path pattern expression>. iii) Otherwise, QPP exposes EV as an effectively unbounded group variable. f) If a <questioned path primary> QUPP declares EV, then let PP be the <path primary> simply contained in QUPP. Case: i) If PP exposes EV as a group variable, then QUPP exposes EV as a group variable with the same degree of exposure. ii) Otherwise, QUPP exposes EV as a conditional singleton variable. g) A <parenthesizedpath patternexpression>exposesthesamevariablesas thesimply contained <path pattern expression>, in the same degree of exposure. NOTE 190 — A restrictive <path mode> declared by a <parenthesized path pattern expression> makes variables effectively bounded, but it does so even for proper subexpressions within the scopeofthe<pathmode>and hasalready beenhandledby therulesfor<quantifiedpath primary>. 233 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "h) If a <path pattern> PP declares EV, then let PPE be the simply contained <path pattern expression>. Case: i) If PPE exposes EV as an unconditionalsingleton, a conditionalsingleton, or an effectively bounded group variable, then PP exposes EV with the same degree of exposure. ii) Otherwise, PP exposes EV as an effectively bounded group variable. NOTE 191 — That is, even if PPE exposes EV as an effectively unbounded group variable, PP still exposes EV as effectively bounded, because in this case PP is required to be a selective <path pattern>. i) If BNT1 and BNT2 are two BNF non-terminals such that BNT1 ::= BNT2 and BNT2 exposes EV, then BNT1 exposes EV to the same degree of exposure as BNT2. ** Editor’s Note (number 37) ** WG3:W04-009R1 defined “effectively bounded group variable” but did not use the definition. The definition will be used when we define predicates on aggregates, at which time we will want a Syntax Rules stating that if a group variable GV is referenced in a WHERE clause, then it shall be effectively bounded and the reference shall be contained in an aggregated argument of an <aggregate function>. 22) If BNT is a BNF non-terminal that exposes a graph pattern variable GPV with a degree of exposure DEGREE, then BNT is also said to expose the name of GPV with degree of exposure DEGREE. 23) A <parenthesized path pattern where clause> PPPWC simply contained in a <parenthesized path pattern expression> PPPE shall not reference a path variable. ** Editor’s Note (number 38) ** WG3:W04-009R1 recognized that a graph query may have a sequence of MATCH clauses, with the bindings of one MATCH clause MC1 visible in all subsequent MATCH clauses in the same invocation of <graph table>, and that it should be permissible to reference such variables in any <parenthesized path pattern where clause> simply contained in a subsequent MATCH clause MC2. The relevance of this LO to GQL needs to be investigated. See Language Opportunity GQL-051 . General Rules None. NOTE 192 — The evaluation of a <path pattern expression> is performed by the General Rules of Subclause 22.3, “Evaluation of a <path pattern expression>”. Conformance Rules 1) Conforming GQL language shall not contain an <element variable declaration> that immediately contains TEMP. NOTE 193 — An <element variable declaration> containing TEMP is a specification device and is not syntax available to the user. 2) Without Feature G030, “Path multiset alternation”, conforming GQL language shall not contain a <path multiset alternation>. 3) Without Feature G031, “Path multiset alternation: variable length path operands”, in conforming GQL language, an operand of a <path multiset alternation> shall be a fixed length path pattern. 234 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": "4) Without Feature G032, “Path pattern union”, conforming GQL language shall not contain a <path pattern union>. 5) Without Feature G033, “Path pattern union: variable length path operands”, in conforming GQL language, an operand of a <path pattern union> shall be a fixed length path pattern. 6) WithoutFeature G035,“Quantifiedpaths”, conformingGQLlanguage shallnot containa <quantified path primary> that does not immediately contain a <path primary> that is an <edge pattern>. 7) Without Feature G036, “Quantified edges”, conforming GQL language shall not contain a <quantified path primary> that immediately contains a <path primary> that is an <edge pattern>. 8) WithoutFeatureG037,“Questionedpaths”,conformingGQLlanguageshallnotcontaina<questioned path primary>. 9) Without Feature G038, “Parenthesized path pattern expression”, conforming GQL language shall not contain a <parenthesized path pattern expression>. 10) Without Feature G041, “Non-local element pattern predicates”, in conforming GQL language, the <element pattern where clause> of an <element pattern> EP shall only reference the <element variable> declared in EP. 11) Without Feature G043, “Complete full edge patterns”, conforming GQL language shall not contain a <full edge pattern> that is not a <full edge any direction>, a <full edge pointing left>, or a <full edge pointing right>. 12) WithoutFeatureG044,“Basicabbreviatededgepatterns”,conformingGQLlanguageshallnotcontain an <abbreviated edge pattern> that is a <minus sign>, a <left arrow>, or a <right arrow>. 13) Without Feature G045, “Complete abbreviated edge patterns”, conforming GQL language shall not contain an <abbreviated edge pattern> that is not a <minus sign>, a <left arrow>, or a <right arrow>. 14) Without Feature G046, “Relaxed topological consistency: adjacent vertex patterns”, in conforming GQL language, between any two <node pattern>s contained in a <path pattern expression> there shall be at least one <edge pattern>, <left paren>, or <right paren>. 15) Without Feature G047, “Relaxed topological consistency: concise edge patterns”, in conforming GQL language, an <edge pattern> shall be immediately preceded and followed by a <node pattern>. 16) Without Feature G048, “Parenthesized path pattern: subpath variable declaration”, conforming GQL language shall not contain a <parenthesized path pattern expression> that simply contains a <subpath variable declaration>. 17) Without Feature G049, “Parenthesized path pattern: path mode prefix”, conforming GQL language shall not contain a <parenthesized path pattern expression> that immediately contains a <path mode prefix>. 18) Without Feature G050, “Parenthesized path pattern: WHERE clause”, conforming GQL language shall not contain a <parenthesized path pattern where clause>. 19) Without Feature G051, “Parenthesized path pattern: non-local predicates”, in conforming GQL language, a <parenthesized path pattern where clause> simply contained in a <parenthesized path pattern expression> PPPE shall not reference an <element variable> that is not declared in PPPE. 235 IWD 39075:2023(E) "
  },
  {
    "section": "16.10",
    "title": "<path pattern expression>",
    "text": ""
  },
  {
    "section": "16.11",
    "title": "<insert graph pattern>",
    "text": "Function Define an <insert graph pattern>. Format <insert graph pattern> ::= <insert path pattern list> « Correct applicaton of OHD-012 » <insert path pattern list> ::= <insert path pattern> [ { <comma> <insert path pattern> }... ] <insert path pattern> ::= <insert node pattern> [ { <insert edge pattern> <insert node pattern> }... ] <insert node pattern> ::= <left paren> [ <insert element pattern filler> ] <right paren> <insert edge pattern> ::= <insert edge pointing left> | <insert edge pointing right> | <insert edge undirected> <insert edge pointing left> ::= <left arrow bracket> [ <insert element pattern filler> ] <right bracket minus> <insert edge pointing right> ::= <minus left bracket> [ <insert element pattern filler> ] <bracket right arrow> <insert edge undirected> ::= <tilde left bracket> [ <insert element pattern filler> ] <right bracket tilde> <insert element pattern filler> ::= <element variable declaration> [ <label and property set specification> ] | [ <element variable declaration> ] <label and property set specification> <label and property set specification> ::= <label set specification> [ <element property specification> ] | [ <label set specification> ] <element property specification> <label set specification> ::= <label name> [ { <ampersand> <label name> }... ] Syntax Rules 1) Let IGP be the <insert graph pattern>. 2) Let IDNSET be the empty set. 3) For every <insert element pattern filler> IEPF simply contained in IGP that does not immediately contain an <element variable declaration>: a) Let IDN be an implementation-dependent (UV011) name that is not equal to the name of the <element variable declaration> of any other <element pattern> in IGP, any column name in the declared type of the incoming working table of IGP, any field name in the declared type of the incoming working record of IGP, or any name of a catalog object in the GQL-catalog. 236 IWD 39075:2023(E) "
  },
  {
    "section": "16.11",
    "title": "<insert graph pattern>",
    "text": "b) Include IDN in IDNSET. c) IEPF is effectively replaced by: IDN IEPF 4) The implementation-assigned variable names of IGP are IDNSET. 5) Let IS be the <insert statement> that immediately contains IGP. 6) An <element variable> EV contained in an <element variable declaration> EVD is said to be declared by EVD, and by the <insert node pattern> or <insert edge pattern> EP that simply contains EVD. The <element variable> specifies the name of an element variable, which is also declared by EVD and EP. 7) For every <value expression> VE immediately contained in a <property key value pair> PKVP immediately contained in an <element property specification> simply contained in IGP: a) The declared type of the incoming working record of VE is the declared type of the incoming working record of IS amended with the record type of the declared type of the incoming working table of IS. b) The declared type of the incoming working table of VE is the material unit binding table type. c) The declared type of VE shall be a supported property value type. 8) An insert element pattern is either an <insert node pattern> or an <insert edge pattern> that is simply contained in IGP. 9) A bound insert element pattern is an insert element pattern IEP that declares an <element variable> EV whose name is either the name of a column C of the declared type of the incoming working table of IS or is the name of a field F of the declared type of the incoming working record of IS. The declared type of IEP is the column type of C or the field value type of F. 10) No <property key value pair list> simply contained in a bound insert element pattern shall simply contain two equivalent <property name>s that are each immediately contained in a different <property key value pair>. 11) For every <element variable> EV simply contained in IGP: a) For every bound insert element pattern EP that declares EV: « WG3:CMN-019 P00-USA-102 » i) EP shall be an <insert node pattern>. ii) The declared type of EP shall be a node reference value type. iii) EP shall not simply contain a <label and property set specification>. b) The defining insert element pattern of EV is the first insert element pattern that declares EV. Every insert element pattern that declares EV and is not the defining insert element pattern of EV shall not simply contain a <label and property set specification>. 12) If an <insert edge pattern> EP1 declares an <element variable> EV1, then there shall not be an <insert node pattern> or <insert edge pattern> EP2 that declares an <element variable> EV2 equi- valent to EV1. NOTE 194 — This rule has two consequences. — If an <insert node pattern> declares an <element variable> EV, then there is not an <insert edge pattern> that declares an <element variable> with the same name as EV. 237 IWD 39075:2023(E) "
  },
  {
    "section": "16.11",
    "title": "<insert graph pattern>",
    "text": "— Every <insertedge pattern> is the defininginsertelement pattern of the element variable it declares. General Rules None. Conformance Rules None. 238 IWD 39075:2023(E) "
  },
  {
    "section": "16.11",
    "title": "<insert graph pattern>",
    "text": ""
  },
  {
    "section": "16.12",
    "title": "<label expression>",
    "text": "Function Specify an expression that matches one or more labels of a graph. Format <label expression> ::= <label term> | <label disjunction> <label disjunction> ::= <label expression> <vertical bar> <label term> <label term> ::= <label factor> | <label conjunction> <label conjunction> ::= <label term> <ampersand> <label factor> <label factor> ::= <label primary> | <label negation> <label negation> ::= <exclamation mark> <label primary> <label primary> ::= <label name> | <wildcard label> | <parenthesized label expression> <wildcard label> ::= <percent> <parenthesized label expression> ::= <left paren> <label expression> <right paren> Syntax Rules 1) Let LE be the <label expression> and let GP be the <graph pattern> that simply contains LE. 2) Let PG be the current working graph available at LE. NOTE 195 — If no current working graph is available at LE, then this rule cannot be satisfied. See Subclause 4.7.3, “Working objects”. 3) Every <label name> contained in LE shall identify a label of PG. 4) Case: a) If LE is simply contained in a <node pattern>, then LE is a node <label expression>. Every <label name> contained in LE shall identify a node label of PG. b) Otherwise, LE is an edge <label expression>. Every <label name> contained in LE shall identify an edge label of PG. 239 IWD 39075:2023(E) "
  },
  {
    "section": "16.12",
    "title": "<label expression>",
    "text": "General Rules None. Conformance Rules 1) Without Feature G074, “Label expression: wildcard label”, conforming GQL language shall not contain a <wildcard label>. 240 IWD 39075:2023(E) "
  },
  {
    "section": "16.12",
    "title": "<label expression>",
    "text": ""
  },
  {
    "section": "16.13",
    "title": "<graph pattern quantifier>",
    "text": "Function Specify a graph pattern quantifier. Format <graph pattern quantifier> ::= <asterisk> | <plus sign> | <fixed quantifier> | <general quantifier> <fixed quantifier> ::= <left brace> <unsigned integer> <right brace> <general quantifier> ::= <left brace> [ <lower bound> ] <comma> [ <upper bound> ] <right brace> <lower bound> ::= <unsigned integer> <upper bound> ::= <unsigned integer> Syntax Rules 1) The maximum value of <upper bound> is implementation-defined (IL018). <upper bound>, if spe- cified, shall not be greater than this value. 2) Every <graph pattern quantifier> is normalized, as follows: a) <asterisk> is equivalent to: {0,} b) <plus sign> is equivalent to: {1,} c) If <fixed quantifier> FQ is specified, then let UI be the <unsigned integer> contained in FQ. FQ is equivalent to: {UI,UI} d) If<general quantifier>GQisspecified,andif<lowerbound>isnotspecified,thenthe<unsigned integer> 0 (zero) is supplied as the <lower bound>. 3) If <general quantifier> GQ is specified or implied by the preceding normalizations, then Case: a) If <upper bound> is specified, then: i) The value of <upper bound> VUP shall be greater than 0 (zero). ii) The value of <lower bound> LUP shall be less than or equal to VUP. 241 IWD 39075:2023(E) "
  },
  {
    "section": "16.13",
    "title": "<graph pattern quantifier>",
    "text": "iii) If LUP equals VUP, then GQ is a fixed quantifier. iv) GQ is a bounded quantifier. b) Otherwise, GQ is an unbounded quantifier. 4) A <graph pattern quantifier> that is not a fixed quantifier is a variable quantifier. General Rules None. Conformance Rules 1) Without Feature G060, “Bounded graph pattern quantifiers”, conforming GQL language shall not contain a <fixed quantifier> or a <general quantifier> that immediately contains an <upper bound>. 2) Without Feature G061, “Unbounded graph pattern quantifiers”, conforming GQL language shall not contain a <graph pattern quantifier> that immediately contains an <asterisk>, a <plus sign>, or a <general quantifier> that does not immediately contain an <upper bound>. 242 IWD 39075:2023(E) "
  },
  {
    "section": "16.13",
    "title": "<graph pattern quantifier>",
    "text": ""
  },
  {
    "section": "16.14",
    "title": "<simplified path pattern expression>",
    "text": "Function Express a path pattern as a regular expression of edge labels. Format <simplified path pattern expression> ::= <simplified defaulting left> | <simplified defaulting undirected> | <simplified defaulting right> | <simplified defaulting left or undirected> | <simplified defaulting undirected or right> | <simplified defaulting left or right> | <simplified defaulting any direction> <simplified defaulting left> ::= <left minus slash> <simplified contents> <slash minus> <simplified defaulting undirected> ::= <tilde slash> <simplified contents> <slash tilde> <simplified defaulting right> ::= <minus slash> <simplified contents> <slash minus right> <simplified defaulting left or undirected> ::= <left tilde slash> <simplified contents> <slash tilde> <simplified defaulting undirected or right> ::= <tilde slash> <simplified contents> <slash tilde right> <simplified defaulting left or right> ::= <left minus slash> <simplified contents> <slash minus right> <simplified defaulting any direction> ::= <minus slash> <simplified contents> <slash minus> <simplified contents> ::= <simplified term> | <simplified path union> | <simplified multiset alternation> <simplified path union> ::= <simplified term> <vertical bar> <simplified term>     [ { <vertical bar> <simplified term> }... ] <simplified multiset alternation> ::= <simplified term> <multiset alternation operator> <simplified term>     [ { <multiset alternation operator> <simplified term> }... ] <simplified term> ::= <simplified factor low> | <simplified concatenation> <simplified concatenation> ::= <simplified term> <simplified factor low> <simplified factor low> ::= <simplified factor high> | <simplified conjunction> 243 IWD 39075:2023(E) "
  },
  {
    "section": "16.14",
    "title": "<simplified path pattern expression>",
    "text": "<simplified conjunction> ::= <simplified factor low> <ampersand> <simplified factor high> <simplified factor high> ::= <simplified tertiary> | <simplified quantified> | <simplified questioned> <simplified quantified> ::= <simplified tertiary> <graph pattern quantifier> <simplified questioned> ::= <simplified tertiary> <question mark> <simplified tertiary> ::= <simplified direction override> | <simplified secondary> <simplified direction override> ::= <simplified override left> | <simplified override undirected> | <simplified override right> | <simplified override left or undirected> | <simplified override undirected or right> | <simplified override left or right> | <simplified override any direction> <simplified override left> ::= <left angle bracket> <simplified secondary> <simplified override undirected> ::= <tilde> <simplified secondary> <simplified override right> ::= <simplified secondary> <right angle bracket> <simplified override left or undirected> ::= <left arrow tilde> <simplified secondary> <simplified override undirected or right> ::= <tilde> <simplified secondary> <right angle bracket> <simplified override left or right> ::= <left angle bracket> <simplified secondary> <right angle bracket> <simplified override any direction> ::= <minus sign> <simplified secondary> <simplified secondary> ::= <simplified primary> | <simplified negation> <simplified negation> ::= <exclamation mark> <simplified primary> <simplified primary> ::= <label name> | <left paren> <simplified contents> <right paren> ** Editor’s Note (number 39) ** It has been proposed that a macro name may be a <simplified primary> in a <simplified path pattern expression>. See Language Opportunity GQL-034 . 244 IWD 39075:2023(E) "
  },
  {
    "section": "16.14",
    "title": "<simplified path pattern expression>",
    "text": "Syntax Rules 1) A <simplified negation> shall not contain a <simplified concatenation>, <simplified quantified>, <simplified questioned>, or <simplified multiset alternation>. 2) A <simplified direction override> shall not contain another <simplified direction override>. 3) A <simplified direction override> shall not contain <simplified concatenation>, <simplified quanti- fied>, <simplified questioned>, or <simplified multiset alternation>. 4) A <simplified conjunction> shall not contain a <simplified concatenation>, <simplified quantified>, <simplified questioned>, or <simplified multiset alternation>. 5) A <simplified path pattern expression> SPPE is replaced by: ( SPPE ) NOTE 196 — This is done once for each <simplified path pattern expression> prior to the following recursive transformation and not with each iteration of the transformation. 6) The following rules are recursively applied until no <simplified path pattern expression>s remain. NOTE 197 — The rules work from the root of the parse tree of a <simplified path pattern expression>. At each step, the coarsest analysis of a <simplified path pattern expression> is replaced, eliminating at least one level of the parse tree, measured from the root. Note that each replacement can create more <simplified path pattern expression>s than before, but these replacements have less depth. Eventually the recursion replaces <simplified path pattern expression> with <edge pattern>. a) Let SPPE be a <simplified path pattern expression>. i) Let SC be the <simplified contents> contained in SPPE. ii) Let PREFIX be the <minus slash>, <left minus slash>, <tilde slash>, <left tilde slash>, or <left minus slash> contained in SPPE. iii) Let SUFFIX be the <slash minus right>, <slash minus>, <slash tilde>, or <slash tilde right> contained in SPPE. iv) Let EDGEPRE and EDGESUF be determined by Table 3, “Conversion of simplified syntax delimiters to default edge delimiters”, from the row containing the values of PREFIX and SUFFIX. Table 3 — Conversion of simplified syntax delimiters to default edge delimiters EDGESUF EDGEPRE SUFFIX PREFIX ]-> -[ /-> -/ ]- <-[ /- <-/ ]~ ~[ /~ ~/ ]~> ~[ /~> ~/ ]~ <~[ /~ <~/ ]-> <-[ /-> <-/ ]- -[ /- -/ 245 IWD 39075:2023(E) "
  },
  {
    "section": "16.14",
    "title": "<simplified path pattern expression>",
    "text": "b) Case: i) If SC is a <simplified path union> SPU, then let N be the number of <simplified term>s simply contained in SPU, and let ST1, ..., STN be those <simplified term>s; SPPE is replaced by: PREFIX ST1 SUFFIX | PREFIX ST2 SUFFIX | ... | PREFIX STN SUFFIX ii) If SC is a <simplified multiset alternation> SMA, then let N be the number of <simplified term>s simply contained in SMA, and let ST1, ..., STN be those <simplified term>s; SPPE is replaced by: PREFIX ST1 SUFFIX |+| PREFIX ST2 SUFFIX |+| ... |+| PREFIX STN SUFFIX iii) If SC is a <simplified concatenation> SCAT, then let ST be the <simplified term> and let SFL be the <simplified factor low> simply contained in SCAT; SPPE is replaced by: PREFIX ST SUFFIX PREFIX SFL SUFFIX iv) If SC is a <simplified conjunction> SAND, then SPPE is replaced by: EDGEPRE IS SAND EDGESUF NOTE 198 — As a result, SAND is now interpreted as a <label expression> within an <edge pattern>. By earlier Syntax Rules, there are no operators allowed in SAND that cannot be interpreted as operators of a <label expression>. v) If SC is a <simplified quantified> SQ, then let ST be the <simplified tertiary> simply contained in SC and let GPQ be the <graph pattern quantifier> simply contained in SQ; SPPE is replaced by: ( PREFIX ST SUFFIX ) GPQ vi) If SC is a <simplified questioned> SQU, then let ST be the <simplified tertiary> simply contained in SC; SPPE is replaced by: ( PREFIX ST SUFFIX ) ? vii) If SC is a <simplified direction override> SDO, then let SS be the <simplified secondary> simply contained in SDO. Case: NOTE 199 — As a result of the following replacements, SDO is now interpreted as a <label expression> within an <edge pattern>. By earlier Syntax Rules, there are no operators allowed in SDO that cannot be interpreted as operators of a <label expression>. 1) If SDO is <simplified override left>, then SPPE is replaced by: <-[ IS SS ]- 2) If SDO is <simplified override undirected>, then SPPE is replaced by: ~[ IS SS ]~ 3) If SDO is <simplified override left or undirected>, then SPPE is replaced by: <~[ IS SS ]~ 4) If SDO is <simplified override undirected or right>, then SPPE is replaced by: 246 IWD 39075:2023(E) "
  },
  {
    "section": "16.14",
    "title": "<simplified path pattern expression>",
    "text": "~[ IS SS ]~> 5) If SDO is <simplified override left or right>, then SPPE is replaced by: <-[ IS SS ]-> 6) If SDO is <simplified override any direction>, then SPPE is replaced by: -[ IS SS ]- viii) If SC is a <simplified negation> SN, then SPPE is replaced by: EDGEPRE IS SN EDGESUF NOTE 200 — As a result, SN is now interpreted as a <label expression> within an <edge pattern>. By earlier Syntax Rules, there are no operators allowed in SN that cannot be interpreted as operators of a <label expression>. ix) If SC is a <simplified primary> SP, then Case: 1) If SP is a <label name>, then SPPE is replaced by: EDGEPRE IS SP EDGESUF 2) Otherwise, let INNER be the <simplified contents> simply contained in SC; SPPE is replaced by: ( PREFIX INNER SUFFIX ) 7) The Conformance Rules of Subclause 16.10, “<path pattern expression>” are applied to the result of the previous syntactic transformation. General Rules None. Conformance Rules 1) WithoutFeatureG039,“Simplifiedpathpatternexpression:fulldefaulting”,conformingGQLlanguage shall not contain a <simplified path pattern expression> that is not a <simplified defaulting left>, a <simplified defaulting right>, or a <simplified defaulting any direction>. 2) Without Feature G080, “Simplified path pattern expression: basic defaulting”, conforming GQL language shall not contain a <simplified defaulting left>, a <simplified defaulting right>, or a <sim- plified defaulting any direction>. 3) WithoutFeatureG081,“Simplifiedpathpatternexpression:fulloverrides”,conformingGQLlanguage shall not contain a <simplified direction override> that is not a <simplified override left>, a <simpli- fied override right>, or a <simplified override any direction>. 4) Without Feature G082, “Simplified path pattern expression: basic overrides”, conforming GQL lan- guage shall not contain a <simplified override left>, a <simplified override right>, or a <simplified override any direction>. 247 IWD 39075:2023(E) "
  },
  {
    "section": "16.14",
    "title": "<simplified path pattern expression>",
    "text": ""
  },
  {
    "section": "16.15",
    "title": "<where clause>",
    "text": "Function Compute a new binding table by selecting records from the current working table fulfilling the specified <search condition>. Format <where clause> ::= WHERE <search condition> Syntax Rules 1) Let WC be the <where clause> and let SC be the <search condition> immediately contained in WC. 2) The declared type of the incoming working record of SC is the declared type of the incoming working record of WC amended with the record type of the declared type of the incoming working table of WC. 3) The declared type of the incoming working table of SC is the material unit binding table type. 4) The declared type of WC is the declared type of incoming working table of WC. General Rules 1) Let WHERE be a new empty binding table. 2) For each record R of the current working table: a) Let INCLUDE be the result of SC in a new child execution context amended with R. « WG3:CMN-019 P00-USA-351 » b) If INCLUDE is True, then R is added to WHERE. 3) The result of WC is WHERE. Conformance Rules None. 248 IWD 39075:2023(E) "
  },
  {
    "section": "16.15",
    "title": "<where clause>",
    "text": ""
  },
  {
    "section": "16.16",
    "title": "<yield clause>",
    "text": "Function Select and rename columns of a binding table. Format <yield clause> ::= YIELD <yield item list> <yield item list> ::= <yield item> [ { <comma> <yield item> }... ] <yield item> ::= { <yield item name> [ <yield item alias> ] } <yield item name> ::= <field name> <yield item alias> ::= AS <binding variable> Syntax Rules 1) Let YC be the <yield clause>. 2) Let COYI be the collection of <yield item>s simply contained in YC. « WG3:CMN-019 P00-USA-207 » 3) Let N be the number of <yield item>s in COYI. 4) For each <yield item> YIi, 1 (one) ≤i ≤N, in COYI: a) Let YINi be the <yield item name> specified by YIi. b) If YIi does not immediately contain a <yield item alias>, then: i) YINi shall be a <binding variable>. ii) YIi is effectively replaced by: YINi AS YINi « WG3:CMN-019 P00-USA-207 » 5) Let YCT be the <yield clause> after the preceding transformation and let COYIT be the collection of N <yield item>s simply contained in YCT. 6) If COYIT simply contains a <yield item alias> that simply contains a <binding variable> YIABV1, then COYIT shall not simply contain another <yield item alias> that simply contains a <binding variable> YIABV2 such that YIABV1 and YIABV2 are equivalent. 7) The declared type of YCT is a binding table type BTT defined as follows: « WG3:CMN-019 P00-USA-207 » a) BTT has N columns. 249 IWD 39075:2023(E) "
  },
  {
    "section": "16.16",
    "title": "<yield clause>",
    "text": "b) For each <yield item> YIi, 1 (one) ≤i ≤N in COYIT: i) Let YINi be the <yield item name> specified by YIi. ii) Let YIAi be the <binding variable> simply contained in the <yield item alias> specified by YIi. iii) The declared type of the incoming working table of YC shall have a column SC with column name YINi. iv) BTT has a column TC. v) The column type of TC is the column type of SC. General Rules 1) Let YIELD be a new empty binding table. 2) For each record R of the current working table in a new child execution context amended with R: a) Let T be a new empty record. « WG3:CMN-019 P00-USA-207 » b) For each <yield item> YIi, 1 (one) ≤i ≤N, from COYIT: i) Let YINi be the <yield item name> specified by YIi. ii) Let Fi be the field of the current working record whose field name is YINi. iii) Let YIVi be the field value of Fi. NOTE 201 — As opposed to the General Rules for <binding variable>, <yield item>s only considerthe current working record and ignore the working records of any parent execution contexts that precede the current execution context in the current execution stack. iv) Let YIAi be the <binding variable> simply contained in the <yield item alias> specified by YIi. « WG3:CMN-019 P00-USA-351 » v) A new field with field name YIAi and with field value YIVi is added to T. c) T is added to YIELD. 3) The result of YCT is YIELD. Conformance Rules None. 250 IWD 39075:2023(E) "
  },
  {
    "section": "16.16",
    "title": "<yield clause>",
    "text": ""
  },
  {
    "section": "16.17",
    "title": "<group by clause>",
    "text": "Function Define a <group by clause> for specifying the set of grouping keys to be used during grouping. ** Editor’s Note (number 40) ** Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 . Format <group by clause> ::= GROUP BY <grouping element list> « WG3:CMN-019 P00-USA-104 » <grouping element list> ::= <grouping element> [ { <comma> <grouping element> }... ] | <empty grouping set> <grouping element> ::= <binding variable reference> <empty grouping set> ::= <left paren> <right paren> Syntax Rules 1) Let GBC be the <group by clause> and let GEL be the <grouping element list>. 2) Let COLS be the sequence of columns defined as follows. Case: « WG3:CMN-019 P00-NLD-060 » a) If GEL is the <empty grouping set>, then COLS is the empty sequence. b) Otherwise: i) Let GESEQ be the sequence of <grouping element>s immediately contained in GEL and let NGESEQ be the number of such <grouping element>s in GESEQ. ii) For every i-th element GEi of GESEQ, 1 (one) ≤i ≤NGESEQ: 1) Let BVRi be the <binding variable reference> immediately contained in GEi. 2) The declared type of the incoming working record of BVRi is the declared type of the incoming working record of GBC amended with the record type of the declared type of the incoming working table of GBC. 3) The declared type of the incoming working table of BVRi is the unit binding table type. 4) BVRi is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations”, apply. 251 IWD 39075:2023(E) "
  },
  {
    "section": "16.17",
    "title": "<group by clause>",
    "text": "5) Let GEBVi be the name of the binding variable referenced by BVRi. 6) Let COLi be the column whose name is GEBVi and whose type is the declared type of BVRi. 7) Append COL to COLS. 3) The declared type of the outgoing working table of GBC is a material binding table whose set of columns is COLS. 4) The declared type of the outgoing working record of GBC is the declared type of the incoming working record of GBC. 5) The declared type of GBC is the declared type of the outgoing working table of GBC. General Rules 1) Case: a) If GEL is the <empty grouping set>, then let GROUP_BY be a unit binding table. b) Otherwise: i) For i, 1 (one) ≤i ≤NGESEQ, let GEibe the i-th element of GESEQ and let GEBVi be the <binding variable reference> simply contained in GEBVi. ii) Let GROUP_BY be a new empty binding table with the column set COLS. iii) Foreachrecord R ofthecurrent working table in a new childexecutioncontext amended with R: 1) Let T be a new record comprising fields Fi, 1 (one) ≤i ≤NGESEQ, such that the field name of Fi is the column name of COLSi and the field value of Fi is the value of GEBVi in R. 2) If T is distinct from every record in GROUP_BY, then T is added to GROUP_BY. 2) The result of GBC is GROUP_BY. Conformance Rules 1) Without Feature GQ15, “GROUP BY clause”, conforming GQL language shall not contain <group by clause>. 252 IWD 39075:2023(E) "
  },
  {
    "section": "16.17",
    "title": "<group by clause>",
    "text": ""
  },
  {
    "section": "16.18",
    "title": "<order by clause>",
    "text": "Function Apply a <sort specification list> to the current working table. Format <order by clause> ::= ORDER BY <sort specification list> Syntax Rules 1) Let OBC be the <order by clause>. 2) Let SSL be the <sort specification list> that is immediately contained in OBC. 3) The declared type of OBC is the declared type of the incoming working table of OBC. General Rules 1) The result of OBC is the result of SSL. Conformance Rules None. 253 IWD 39075:2023(E) "
  },
  {
    "section": "16.18",
    "title": "<order by clause>",
    "text": ""
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": "Function Specify a value computed from a collection of records. ** Editor’s Note (number 41) ** Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 . Format <aggregate function> ::= COUNT <left paren> <asterisk> <right paren> | <general set function> | <binary set function> ** Editor’s Note (number 42) ** Consider inclusion of aggregate function calls to procedures with formal parameters of multiple parameter car- dinality. See Language Opportunity GQL-186 . <general set function> ::= <general set function type> <left paren> [ <set quantifier> ] <value expression> <right paren> <binary set function> ::= <binary set function type> <left paren> <dependent value expression> <comma> <independent value expression> <right paren> <general set function type> ::= AVG | COUNT | MAX | MIN | SUM | COLLECT_LIST | STDDEV_SAMP | STDDEV_POP <set quantifier> ::= DISTINCT | ALL <binary set function type> ::= PERCENTILE_CONT | PERCENTILE_DISC <dependent value expression> ::= [ <set quantifier> ] <numeric value expression> <independent value expression> ::= <numeric value expression> 254 IWD 39075:2023(E) "
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": "Syntax Rules 1) Let AF be the <aggregate function>. 2) If AF immediately contains a <general set function> that does not specify the <set quantifier>, then ALL is implicit. 3) AF shall not contain a <procedure body>. « WG3:CMN-019 P00-USA-105 One SR removed » 4) Let the <value expression> or the <dependent value expression> VE be defined as follows. Case: a) If AF is directly contained in a <value expression> that is not immediately contained in an <aggregating value expression>, then VE is the <value expression> or the <dependent value expression> immediately contained in AF. b) If AF immediately contains a <general set function> GSF, then VE is the <value expression> immediately contained in GSF. c) Otherwise, AF immediately contains a <binary set function> BSF and VE is the <dependent value expression> immediately contained in BSF. 5) Let DT be the declared type of VE. 6) If AF immediately contains COUNT, then: a) If AF immediately contains <asterisk>, then AF shall be directly contained in an <aggregating value expression>. b) The declared type of the result is an implementation-defined(ID059) exact numeric type with scale 0 (zero). 7) If AF immediately contains a <general set function>, then: a) If AF specifies a <general set function> whose <set quantifier> is DISTINCT, then VE is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations”, apply. b) If AF specifies a <general set function type> that is MAX or MIN, then VE is an operand of an ordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13, “Ordering operations”, apply. c) If MAX or MIN is specified, then the declared type of the result is DT. d) If SUM or AVG is specified, then: i) DT shall be a numeric type. ii) If SUM is specified and DT is exact numeric with scale S, then the declared type of the result is an implementation-defined (ID095) exact numeric type with scale S. iii) If AVG is specified and DT is exact numeric, then the declared type of the result is an implementation-defined (ID096) exact numeric type with precision not less than the precision of DT and scale not less than the scale of DT. iv) If DT is approximate numeric, then the declared type of the result is an implementation- defined (ID097) approximate numeric type with precision not less than the precision of DT. 255 IWD 39075:2023(E) "
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": "e) IfSTDDEV_POP orSTDDEV_SAMPisspecified,thenDTshallbeanumerictypeandthedeclared type of the result shall be an implementation-defined (ID098) approximate numeric type. If DT is an approximate numeric type, then the precisionof the result is not less than the precision of DT. f) If COLLECT_LIST is specified, then the declared type of the result is the regular list value type whose list element type is DT. 8) If AF immediately contains a <binary set function>, then: a) Let DVEXP be the <numeric value expression> immediately contained in the <dependent value expression> immediately contained in AF. b) Let IVE be the <independent value expression> simply contained in AF. c) If AF specifies no <set quantifier>, then ALL is implicit. d) The declared type of the incoming working record of the DVEXP is the declared type of the incomingworking record ofAF amendedwiththerecord typeofdeclaredtypeoftheincoming working table of AF. e) The declared type of the incoming working table of DVEXP is the material unit binding table type. f) The declared type of the incoming working record of IVE is the declared type of the incoming working record of AF. g) The declared type of the incoming working table of IVE is the material unit binding table type. h) Let DTIVE be the declared type of IVE. i) The declared type of the result is an implementation-defined (ID099) approximate numeric type. If DT is an approximate numeric type, then the precision of the result is not less than the precision of DT. If DTIVE is an approximate numeric type, then the precision of the result is not less than the precision of DTIVE. General Rules 1) Let TABLE be the current working table. 2) If AF is COUNT(*), then the result of AF is the count of records in TABLE and no further General Rules are applied. 3) If, during the computation of the result of AF, an intermediate result is not representable in the declared type of the site that contains that intermediate result, then Case: a) If the most specific type of the result of AF is a list value type, then an exception condition is raised: data exception — list data, right truncation (22G0B). b) If the most specifictype of the result of AF is a character string type, then an exception condition is raised: data exception — string data, right truncation (22001). c) Otherwise, an exception condition is raised: data exception — numeric value out of range (22003). 4) Let SQ be defined as follows. Case: 256 IWD 39075:2023(E) "
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": "a) If AF is a <general set function> GSF, then SQ is the <set quantifier> immediately contained in GSF. b) Otherwise, AF is a <binary set function> BSF and SQ is the <set quantifier> immediately con- tained in the <dependent value expression> immediately contained in BSF. 5) Let the collection VALUES be determined as follows. Case: a) If AF is directly contained in a <value expression> that is not immediately contained in an <aggregating value expression>, then: i) Let GLBV be the binding variable referenced by <binding variable reference>s simply contained in AF without an intervening instance of <independent value expression> whose declared type is the group list value type. ii) General Rules of Subclause 22.7, “Evaluation of an expression on a group variable”, are applied with GLBV as GROUP LIST BINDING VARIABLE and VE as EXPRESSION; let VALUES be the LIST VALUE returned from the application of those General Rules. b) Otherwise: i) Initially, VALUES is an empty collection. ii) For each record R of TABLE in a new child execution context amended with R: 1) Let EXPRE be the result of VE. 2) Case: A) If EXPRE is null, then a completion condition is raised: warning — null value eliminated in set function (01G11). B) Otherwise, Case: I) If SQ is DISTINCT and EXPRE is not in VALUES, then EXPRE is added to VALUES; II) Otherwise, SQ is ALL and EXPRE is added to VALUES. 6) Let N be the cardinality of VALUES. 7) Let RESULT be defined as follows. Case: a) If AF is the <general set function> GSF, then Case: i) If COUNT is specified, then RESULT is N. ii) If VALUES is empty, then RESULT is defined as follows: Case: 1) If AF is COLLECT_LIST, then RESULT is the empty list. 2) Otherwise, RESULT is the null value. 257 IWD 39075:2023(E) "
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": "iii) If MAX or MIN is specified, then RESULT is the result, respectively, of the maximum value or the minimum value in VALUES. RESULT is determined using the comparison rules specified in Subclause 19.3, “<comparison predicate>”. iv) If SUM is specified, then RESULT is the sum of the values in VALUES. If RESULT is not within the range of the declared type of RESULT, then an exception condition is raised: data exception — numeric value out of range (22003). v) IfSTDDEV_POPorSTDDEV_SAMPisspecified,thenletSXbethesumofvaluesinVALUES and let SXS be the sum of the squares of the values in VALUES. 1) If STDDEV_POPis specified,then RESULT istheresultofSQRT((SXS-SX*SX/N)/N). 2) If STDDEV_SAMP is specified, then Case: A) If N is 1 (one), then RESULT is the null value. B) Otherwise, then RESULT is the result of SQRT((SXS-SX*SX/N)/(N - 1)). 3) If COLLECT_LIST is specified, then RESULT is the list comprised of all values in VALUES. If RESULT is not within the range of the declared type of RESULT, then an exception condition is raised: data exception — list data, right truncation (22G0B). b) Otherwise,AFisthe<binarysetfunction>BSF. LetIVE bethe<independentvalueexpression> immediately contained in BSF, let IVERE be the result of evaluating IVE in a new child execution context, and Case: i) If VALUES is empty, then RESULT is the null value. ii) EXP is an operand of an ordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13, “Ordering operations”, apply. iii) Let ORDERED_VALUES be the sequence of non-null elements in VALUES ordered from least to greatest. ORDERED_VALUES is determined using the comparison rules specified in Subclause 19.3, “<comparison predicate>”. Let N_ORDERED_VALUES be the cardin- ality of ORDERED_VALUES. iv) Let INDEX be the result of 1 + (IVERE * (N_ORDERED_VALUES - 1)). v) If PERCENTILE_CONT is specified, then Case: 1) If INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position INDEX. 2) Otherwise: A) Let INDEX_FLOOR be the largest integer less than INDEX and let RESULT_FLOOR be the value in ORDERED_VALUES at position INDEX_FLOOR. B) Let INDEX_CEILING be the smallest integer greater than INDEX and let RESULT_CEILING be the value in ORDERED_VALUES at position INDEX_CEILING. C) RESULT is the result of (INDEX_CEILING - INDEX) * RESULT_FLOOR 258 IWD 39075:2023(E) "
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": "+ (INDEX - INDEX_FLOOR) * RESULT_CEILING. vi) If PERCENTILE_DISC is specified, then Case: 1) If INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position INDEX. 2) Otherwise, RESULT is the value in ORDERED_VALUES at the position obtained as a result of rounding or truncating INDEX. The choice of whether to round or truncate is implementation-defined (IA027). 8) The result of evaluating AF is RESULT. Conformance Rules 1) Without Feature GF10, “Advanced aggregate functions: general set functions”, conforming GQL language shall not contain an <aggregate function>that immediately containsa <general set function type> that is that is COLLECT_LIST, STDDEV_SAMP, or STDDEV_POP. 2) Without Feature GF11, “Advanced aggregate functions: binary set functions”, conforming GQL lan- guage shall not contain an <aggregate function> that immediately contains a <binary set function type>. 259 IWD 39075:2023(E) "
  },
  {
    "section": "16.19",
    "title": "<aggregate function>",
    "text": ""
  },
  {
    "section": "16.20",
    "title": "<sort specification list>",
    "text": "Function Obtaining an ordered binding table from the current working table. Format <sort specification list> ::= <sort specification> [ { <comma> <sort specification> }... ] <sort specification> ::= <sort key> [ <ordering specification> ] [ <null ordering> ] <sort key> ::= <aggregating value expression> <ordering specification> ::= ASC | ASCENDING | DESC | DESCENDING <null ordering> ::= NULLS FIRST | NULLS LAST Syntax Rules 1) Each <value expression>immediately contained in the <sort key> contained in a <sort specification> is an operand of an ordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13, “Ordering operations”, apply. 2) Let SSL be the <sort specification list> 3) Let NSS be the number of <sort specification>s immediately contained in SSL. « WG3:CMN-019 P00-NLD-050 » 4) For i, 1 (one) ≤i ≤NSS, let SSi be the i-th <sort specification> immediately contained in SSL. 5) For each SSi, 1 (one) ≤i ≤NSS: a) Let SKi be the <sort key> immediately contained in SSi. b) If SSi does not immediately contain an <ordering specification>, then SSi is effectively replaced by: SKi ASC c) The declared type of the incoming working record of SKi is the declared type of the incoming working record of SSL amended with the record type of the declared type of the incoming working table of SSL. d) The declared type of the incoming working table of SKi is the material unit binding table type. e) ThedeclaredtypeofSKi isthedeclaredtypeofthe<aggregating value expression>immediately contained in SKi. 260 IWD 39075:2023(E) "
  },
  {
    "section": "16.20",
    "title": "<sort specification list>",
    "text": "6) If <null ordering> is not specified, then an implementation-defined (IS001) <null ordering> is implicit. The implementation-defined default for <null ordering> shall not depend on the context outside of <sort specification list>. 7) The declared type of SSL is the declared type of the incoming working table of SSL. General Rules 1) Let SORTED be a new ordered binding table created from the collection of records of the current working table by ordering the records, as follows: a) Let N be the number of <sort specification>s. « WG3:CMN-019 P00-NLD-050 » b) For i, 1 (one) ≤i ≤N, let Ki be the <sort key> contained in the i-th <sort specification>. c) Each <sort specification> specifies the sort direction for the corresponding sort key Ki. If neither DESC nor DESCENDING is specified in the i-th <sort specification>, then the sort dir- ectionforKi isascendingand theapplicable<compop>isthe<lessthan operator>; otherwise, the sort direction for Ki is descending and the applicable <comp op> is the <greater than operator>. d) Let P be any record of the collection of records to be ordered, and let Q be any other record of the same collection of records. e) Let PVi be the result of Ki in a new child execution context amended with P. f) Let QVi be the result of Ki in a new child execution context amended with Q. g) The relative position of records P and Q in the result is determined by comparing PVi and QVi as follows: i) The comparison is performed according to the General Rules of Subclause 19.3, “<comparison predicate>”, where the <comp op> is the applicable <comp op> for Ki. ii) The comparison is performed with the following special treatment of null values. Case: 1) If PVi and QVi are both the null value, then they are considered equal to each other. 2) If PVi is the null value and QVi is not the null value, then Case: A) If NULLS FIRST is specifiedor implied, then PVi <comp op> QVi is considered to be True. B) If NULLS LAST is specified or implied, then PVi <comp op> QVi is considered to be False. 3) If PVi is not the null value and QVi is the null value, then Case: A) If NULLS FIRST is specifiedor implied, then PVi <comp op> QVi is considered to be False. 261 IWD 39075:2023(E) "
  },
  {
    "section": "16.20",
    "title": "<sort specification list>",
    "text": "B) If NULLS LAST is specified or implied, then PVi <comp op> QVi is considered to be True. h) PVi is said to precede QVi if the result of the <comparison predicate> “PVi <comp op> QVi” is True for the applicable <comp op>. i) If PVi and QVi are not the null value and the result of “PVi <comp op> QVi” is Unknown, then the relative ordering of PVi and QVi is implementation-dependent (US007). « WG3:CMN-019 P00-NLD-050 » j) The relative position of record P is before record Q if for some n, 1 (one) ≤n ≤N, PVn precedes QVn and PVi is not distinct from QVi for all i < n. k) Two records that are not distinct with respect to the <sort specification>s are said to be peers of each other. The relative ordering of peers is implementation-dependent (US006). l) The result of SSL is SORTED. Conformance Rules 1) Without Feature GA03, “Explicit ordering of nulls”, conforming GQL language shall not contain a <null ordering>. 262 IWD 39075:2023(E) "
  },
  {
    "section": "16.20",
    "title": "<sort specification list>",
    "text": ""
  },
  {
    "section": "16.21",
    "title": "<limit clause>",
    "text": "Function Obtain a new binding table that retains only a limited number of records of the current working table. Format <limit clause> ::= LIMIT <unsigned integer specification> ** Editor’s Note (number 43) ** WITH TIES, ONLY, RECORDS, and GROUPS to be added. See Language Opportunity GQL-161 Syntax Rules 1) Let LC be the <limit clause>. 2) The declared type of LC is the declared type of the incoming working table of LC. General Rules 1) Let TABLE be the current working table. 2) If TABLE is not ordered, then let ORDERED_TABLE be a new ordered binding table created from the result of sorting the collection of all records of TABLE according to an implementation-dependent (US001) order; otherwise, let ORDERED_TABLE be TABLE. 3) Let V be the result of the <unsigned integer specification>. 4) Let LIMIT be a new ordered binding table obtained by selecting only the first V records of ORDERED_TABLE and discarding all subsequent records. NOTE 202 — If the order of the result of LC has no effect on the outcome of a <GQL-program>, there is no need for LIMIT to be indicated as ordered. 5) The result of LC is LIMIT. Conformance Rules None. 263 IWD 39075:2023(E) "
  },
  {
    "section": "16.21",
    "title": "<limit clause>",
    "text": ""
  },
  {
    "section": "16.22",
    "title": "<offset clause>",
    "text": "Function Obtaining a new binding table that retains all records of the current working table except for some dis- carded initial records. Format <offset clause> ::= <offset synonym> <unsigned integer specification> <offset synonym> ::= OFFSET | SKIP ** Editor’s Note (number 44) ** WITH TIES, ONLY, RECORDS, and GROUPS to be added. See Language Opportunity GQL-162 . Syntax Rules 1) Let OC be the <offset clause>. 2) The declared type of OC is the declared type of the incoming working table of OC. General Rules 1) Let TABLE be the current working table. 2) If TABLE is not ordered, then let ORDERED_TABLE be a new ordered binding table created from the result of sorting the collection of all records of TABLE according to an implementation-dependent (US001) order; otherwise, let ORDERED_TABLE be TABLE. NOTE 203 — If the order of the result of OC has no effect on the outcome of a <GQL-program>, there is no need for OFFSET to be indicated as ordered. 3) Let V be the result of the <unsigned integer specification>. 4) Let OFFSET be a new ordered binding table obtained from all but the first V records of ORDERED_TABLE. 5) The result of OC is OFFSET. Conformance Rules None. 264 IWD 39075:2023(E) "
  },
  {
    "section": "16.22",
    "title": "<offset clause>",
    "text": ""
  }
]